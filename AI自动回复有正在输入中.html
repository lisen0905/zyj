<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>章鱼喷墨机</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>

    <style>
        /* --- 全局与主题样式 --- */
        :root {
            --bg-color: #fce4ec;
            --primary-color: #ff80ab;
            --secondary-color: #f48fb1;
            --accent-color: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #fce4ec, #f8bbd0);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .phone-screen {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            max-height: 850px;
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .app-header .back-btn,
        .app-header .action-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .app-header .action-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .action-btn-group .action-btn {
            font-size: 16px;
            font-weight: 600;
            width: auto;
            padding: 6px 12px;
            border-radius: 10px;
        }

        .app-header .action-btn-group #create-group-btn {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .app-header .action-btn-group #add-chat-btn {
            font-size: 28px;
            padding: 0;
            width: 40px;
            height: 40px;
            background-color: transparent;
            color: var(--primary-color);
            border-radius: 50%;
        }

        .app-header .action-btn img {
            width: 28px;
            height: 28px;
        }

        .app-header .title-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-header .title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .app-header .subtitle {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            margin-top: 2px;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        .app-header .placeholder {
            width: 40px;
        }

        #home-screen {
            justify-content: space-between;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            padding: 50px 0;
        }

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 30px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .dock {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            margin: 0 20px;
            min-height: 80px;
            gap: 15px;
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.4s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #chat-list-screen .content,
        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: #fdf6f8;
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 14px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-bottom: 10px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
            align-items: flex-start;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }

        .message-bubble {
            max-width: 260px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.4;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            font-size: 15px;
        }

        .message-bubble.sent {
            border-bottom-right-radius: 5px;
        }

        .message-bubble.received {
            border-bottom-left-radius: 5px;
        }

        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .image-bubble {
            max-width: 120px;
            border-radius: var(--border-radius);
            margin: 0 8px;
            padding: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .image-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: calc(var(--border-radius) - 4px);
        }

        .message-wrapper.sent .image-bubble {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .image-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-bottom-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .voice-bubble .duration {
            font-size: 13px;
            margin: 0 8px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .pv-card {
            width: 230px;
            aspect-ratio: 1 / 1;
            background-color: #f0f0f0;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            margin: 0 8px;
        }

        .message-wrapper.sent .pv-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .pv-card {
            border-bottom-left-radius: 5px;
        }

        .pv-card-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 0.5s ease-in-out;
            z-index: 2;
        }

        .pv-card-image-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pv-card-content {
            padding: 15px;
            height: 100%;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            background-color: white;
            position: relative;
            z-index: 1;
        }

        .pv-card-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
            color: white;
            padding: 20px 10px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        .pv-card-footer.hidden {
            opacity: 0;
        }

        .pv-card-footer svg {
            width: 14px;
            height: 14px;
            fill: white;
            flex-shrink: 0;
        }

        .transfer-card {
            width: 240px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-bottom-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 20px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }
        /* --- 在 <style> 标签内添加 --- */
#diary-screen .content {
    padding: 10px;
}
.diary-entry {
    background-color: #fff8fa;
    border-radius: var(--border-radius);
    padding: 15px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: 4px solid var(--primary-color);
}
.diary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.diary-date {
    font-size: 14px;
    font-weight: 600;
    color: var(--secondary-color);
}
.diary-actions button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    margin-left: 8px;
}
.diary-actions button svg {
    width: 20px;
    height: 20px;
    fill: #aaa;
    transition: fill 0.2s ease, transform 0.2s ease;
}
.diary-actions button:hover svg {
    fill: var(--primary-color);
    transform: scale(1.1);
}
.diary-actions button.favorited svg {
    fill: #fbc02d; /* 收藏后的金色 */
}
.diary-content {
    font-size: 15px;
    line-height: 1.7;
    color: var(--text-color);
    white-space: pre-wrap; /* 保留日记中的换行 */
    word-wrap: break-word;
}

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 0 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-bottom-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card-description {
            font-size: 14px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }
        .file-card {
            width: 240px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            margin: 0 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .file-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .file-card {
            border-bottom-left-radius: 5px;
        }
        .file-card-icon {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }
        .file-card-info {
            overflow: hidden;
            flex-grow: 1;
        }
        .file-card-name {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 0 4px 0;
        }
        .file-card-size {
            font-size: 12px;
            color: #888;
            margin: 0;
        }
                .location-card {
            width: 250px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .location-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .location-card {
            border-bottom-left-radius: 5px;
        }
        .location-card-info {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .location-main {
            font-size: 16px;
            color: #222;
            margin: 0 0 4px 0;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-detail {
            font-size: 12px;
            color: #888;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-map {
            width: 100%;
            height: 140px;
            background-size: cover;
            background-position: center;
            background-image: url('https://i.postimg.cc/L8gYhF4Q/share-image-1755433372879-edit-155975507275678.jpg'); /* Placeholder map image */
        }
        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
    flex-shrink: 0;
    padding: 0 10px 5px;
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    overflow-x: auto; /* 新增：允许横向滚动 */
    /* 以下为可选代码，用于在某些浏览器上隐藏滚动条，但保留滚动功能 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}

/* 可选：隐藏 Webkit 浏览器 (Chrome, Safari) 的滚动条 */
#sticker-bar::-webkit-scrollbar {
    display: none;
}

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 28px;
            height: 28px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35%;
            max-height: 250px;
            background: #f7f7f7;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 15px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 10px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .message-input-area input {
            flex-grow: 1;
            border: none;
            padding: 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 18px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #fce4ec;
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .form-group.radio-group label {
            margin-bottom: 0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(255, 128, 171, 0.5);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            margin-bottom: 15px;
        }

        .btn-secondary:hover {
            background-color: #64b5f6;
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.5);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 25px;
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* --- Group Chat Specific Styles --- */
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        #customize-screen .icon-details input {
            width: calc(100% - 70px);
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* --- Tutorial Screen Styles --- */
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            /* A large value to ensure it expands to fit the content */
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
     /* --- Voice Call Styles --- */
.sticker-bar-btn#voice-call-btn {
    display: none; /* Initially hidden, shown only in private chats */
}

#voice-call-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 300;
    display: none;
    flex-direction: column;
    /* 修改: 不再垂直居中，改为从顶部开始排列元素 */
    justify-content: flex-start; 
    align-items: center;
    color: white;
    text-align: center;
    padding: 20px;
    animation: fadeIn 0.3s ease;
}

#voice-call-overlay.visible {
    display: flex;
}

.call-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 20px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    /* 修改: 增加顶部外边距，让头像不会紧贴屏幕顶部 */
    margin-top: 40px; 
    flex-shrink: 0; /* 防止在flex布局中被压缩 */
}

.call-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.call-status {
    font-size: 16px;
    color: #ccc;
    min-height: 24px;
    flex-shrink: 0;
}

/* 来电/去电时的按钮组样式保持不变 */
.call-button-group {
    position: absolute;
    bottom: 80px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    background: none;
    border: none;
    color: white;
}
.call-button .icon-wrapper {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}
.call-button svg {
    width: 36px;
    height: 36px;
    fill: white;
}
.call-button.decline .icon-wrapper {
    background-color: #ef5350;
}
.call-button.accept .icon-wrapper {
    background-color: #4CAF50;
}

/* --- 通话中界面的核心修改 --- */
#active-call-view {
    display: none;
    flex-direction: column;
    width: 100%;
    /* 修改: 让此视图填满父容器（#voice-call-overlay）的剩余空间 */
    flex-grow: 1; 
    min-height: 0; /* flex布局技巧，防止内部元素溢出 */
}

/* 隐藏之前版本添加的、现在不需要的顶部固定header */
#active-call-header {
    display: none !important;
}

/* 文字聊天面板（图片中橙色框区域） */
#call-transcript-area {
    flex-grow: 1; /* 占据 #active-call-view 内的所有可用垂直空间 */
    overflow-y: auto; /* 当内容超出时，允许滚动 */
    padding: 10px;
    margin-top: 15px; /* 与顶部的状态计时器保持一定间距 */
    margin-bottom: 15px; /* 与下方的挂断按钮保持一定间距 */
    font-size: 15px;
    line-height: 1.7;
    -webkit-overflow-scrolling: touch; /* 优化在移动设备上的滚动体验 */
    text-align: left; /* 聊天内容左对齐，更易于阅读 */
}
.call-transcript-line {
    margin-bottom: 12px;
}
.call-transcript-line .action {
    color: #aaa;
    font-style: italic;
}
.call-transcript-line .dialog {
    color: #fff;
}

/* 底部操作区（挂断按钮和输入框） */
#hangup-button-container {
    position: static; /* 移除绝对定位，使其成为flex布局的一部分 */
    padding: 10px 0;
    flex-shrink: 0; /* 防止被压缩 */
}
#call-input-area {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    width: 100%;
    flex-shrink: 0;
}
#call-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
#call-input::placeholder {
    color: #ccc;
}
#send-call-message-btn {
    background: var(--primary-color);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    color: white;
    font-size: 18px;
    flex-shrink: 0;
}
/* --- 音乐播放器小部件样式 --- */
.music-widget {
    margin: 20px 20px 15px 20px;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border-radius: var(--border-radius);
    display: flex;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.music-widget:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
}
.music-widget-icon {
    width: 60px;
    height: 60px;
    border-radius: 12px;
    margin-right: 15px;
    flex-shrink: 0;
    object-fit: cover; /* 让图标图片完全覆盖容器 */
}
.music-widget-info {
    overflow: hidden;
    flex-grow: 1;
}
.music-widget-info .title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-color);
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-widget-info .artist {
    font-size: 13px;
    color: #666;
    margin: 0;
}

/* --- 音乐播放器弹窗样式 --- */
#music-player-modal .modal-window {
    width: 90%;
    max-width: 360px;
    padding: 0; /* 移除内边距，方便自定义布局 */
    overflow: hidden;
    background: #fafafa;
}
.music-player-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #eee;
}
.music-player-header .song-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
}
.music-player-header .share-btn {
    width: 24px; height: 24px; fill: #888;
}
.music-player-body {
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.music-album-art {
    width: 180px;
    height: 180px;
    border-radius: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    margin-bottom: 25px;
}
.music-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin-top: 20px;
}
.music-controls button {
    background: none;
    border: none;
    cursor: pointer;
}
.music-controls .play-btn svg {
    width: 60px; height: 60px;
}
.music-controls .side-btn svg {
    width: 32px; height: 32px;
}
.music-extra-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 15px 25px;
}
.music-extra-controls button {
     background: none; border: none; cursor: pointer;
}
.music-extra-controls svg {
    width: 26px; height: 26px; fill: #555;
}
.lyrics-panel-placeholder {
    height: 60px; /* 歌词面板占位 */
    width: 100%;
    background: #f0f0f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #aaa;
    margin-top: 15px;
}
/* --- 歌词面板样式 (新添加) --- */
.lyrics-panel {
    width: 100%;
    height: 60px; /* 固定高度 */
    margin-top: 15px;
    overflow: hidden; /* 隐藏容器外部的内容 */
    text-align: center;
    position: relative;
    -webkit-mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
    mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
}
.lyrics-panel-inner {
    transition: transform 0.5s ease-out; /* 平滑滚动效果 */
}
.lyric-line {
    margin: 0;
    padding: 4px 0;
    font-size: 15px;
    color: #888;
    line-height: 1.5;
    transition: all 0.3s ease;
}
.lyric-line.active {
    color: var(--primary-color);
    font-weight: 600;
    font-size: 16px;
    transform: scale(1.05);
}
/* --- 音乐分享卡片样式 --- */
.music-card {
    width: 240px;
    background-color: #fff;
    border-radius: var(--border-radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    margin: 0 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    border: 1px solid #eee;
}
.message-wrapper.sent .music-card {
    border-bottom-right-radius: 5px;
}
.message-wrapper.received .music-card {
    border-bottom-left-radius: 5px;
}
.music-card-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    object-fit: cover;
}
.music-card-info {
    overflow: hidden;
    flex-grow: 1;
}
.music-card-title {
    font-size: 15px;
    font-weight: 500;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0 0 4px 0;
}
.music-card-artist {
    font-size: 12px;
    color: #888;
    margin: 0;
}
/* === 可缩放变量（作用域：仅聊天室屏幕） === */
#chat-room-screen {
  --bubble-scale: 1;
  --bubble-font-base: 15px;
}
#chat-room-screen .message-area {
  font-size: calc(var(--bubble-font-base) * var(--bubble-scale));
}
#chat-room-screen .message-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  max-width: calc(260px * var(--bubble-scale)) !important;
}
#chat-room-screen .system-notification-bubble {
  font-size: 0.8em !important;
  padding: 0.4em 0.67em !important;
}
#chat-room-screen .voice-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  min-width: calc(90px * var(--bubble-scale)) !important;
  max-width: calc(200px * var(--bubble-scale)) !important;
}
#chat-room-screen .voice-bubble .duration { font-size: 0.87em !important; }
#chat-room-screen .image-bubble { max-width: calc(120px * var(--bubble-scale)) !important; }
#chat-room-screen .pv-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .transfer-card { width: calc(240px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card-description,
#chat-room-screen .voice-transcript {
  font-size: 0.93em !important;
  line-height: 1.6;
}
#chat-room-screen .message-bubble,
#chat-room-screen .voice-bubble,
#chat-room-screen .pv-card,
#chat-room-screen .transfer-card,
#chat-room-screen .gift-card {
  border-radius: calc(var(--border-radius) * var(--bubble-scale)) !important;
}

/* DEBUG FIXES: ensure active screen uses flex and phone-screen is positioned */
.phone-screen { position: relative !important; }
.screen { display: none !important; }
.screen.active { display: flex !important; }
.modal-overlay { position: absolute !important; }


/* --- moment image description card (injected) --- */
.moment-image-desc-card {
  background: linear-gradient(135deg, rgba(238, 156, 167, 0.3), rgba(255, 221, 225, 0.3)); /* 半透明粉色渐变背景 */
  border-radius: 10px;
  padding: 12px 14px;
  margin-top: 6px;
  color: #fff;
  position: relative;
  overflow: hidden;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  /* min-height: 86px; */
  display: flex;
  align-items: center;
  cursor: pointer;
  backdrop-filter: blur(10px); /* 关键：毛玻璃模糊效果 */
  -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
  border: 1px solid rgba(255, 255, 255, 0.3); /* 增加玻璃质感边框 */
}


/* === 覆盖：仅改变卡片外框与配色（保留原文件卡片形状/布局/标题） === */
.moment-image-desc-card {
  /* 不改 width/height/border-radius/padding 等布局属性，保障原样式形状不变 */
  border: 6px solid #ffffff;
  box-shadow: 0 6px 20px rgba(10, 10, 20, 0.06);
  background: transparent !important;
}

/* 内层浅灰面板（只在存在内层类时覆盖背景色） */
.moment-image-desc-card .inner {
  background: #eef0f3 !important;
}

/* 将参考图中“标题色”应用到图片描述文字上：#66676b */
.moment-image-desc-card .desc-content,
  .moment-image-desc-card .description,
  .moment-image-desc-card .image-desc {
  color: #66676b !important;
}

/* 小屏微调（不改变布局） */
@media (max-width: 420px) {
  .moment-image-desc-card { box-shadow: 0 4px 14px rgba(10,10,20,0.05); }
}

/*
.moment-image-desc-card::before {
  content: '';
  position: absolute;
  inset: -12px;
  background: inherit;
  filter: blur(10px);
  transform: scale(1.08);
  z-index: 1;
  opacity: 0.95;
}
*/
.moment-image-desc-card .desc-content {
  position: relative;
  z-index: 2;
  font-style: italic;
  text-shadow: 0 1px 3px rgba(0,0,0,0.45);
  line-height: 1.4;
  font-size: 13px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  /* -webkit-line-clamp: 4; */
  overflow: hidden;
  word-break: break-word;
  /* max-height: calc(1.4em * 4); */
}
@media (max-width: 420px) {
  .moment-image-desc-card { padding: 9px; /* min-height: 72px; */ }
  .moment-image-desc-card .desc-content { /* -webkit-line-clamp: 3; */ }
}
    </style>
    <!-- === moments 固定在 phone-screen 内的修复样式 (自动插入补丁) === -->
<style>
/* 确保 phone-screen 做为裁切容器 */
.phone-screen {
  position: relative !important;
  overflow: hidden !important; /* 防止子元素跑出可视区 */
}

/* 把所有 screen 统一做绝对铺满，这样切换只影响可见性，不会改变布局流 */
.screen {
  position: absolute !important;
  inset: 0; /* top:0; right:0; bottom:0; left:0; */
  display: none !important;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* 激活的 screen 可见 */
.screen.active {
  display: flex !important;
}

/* 确保 screen 中的主内容区单独可滚动（不会把整个 screen 推出） */
.screen .content {
  overflow-y: auto !important;
  height: 100%;
  box-sizing: border-box;
}

/* 为动态页面的底部导航栏预留空间 */
#moments-screen .content {
    padding-bottom: 88px !important;
}

/* 防止 moments 页面被某些 transform/translate 推出视窗（保底） */
#moments-screen {
  transform: none !important;
  will-change: auto !important;
}
/* === 主屏幕音乐小部件尺寸控制器 (粘贴到 <style> 标签末尾) === */
.music-widget {
    /* --- 在这里修改大小 --- */
    --music-widget-scale: 1.3; /* 1 = 默认, 1.2 = 放大20%, 0.9 = 缩小10% */

    /* 应用缩放 */
    padding: calc(10px * var(--music-widget-scale));
    margin: calc(20px * var(--music-widget-scale)) calc(20px * var(--music-widget-scale)) calc(15px * var(--music-widget-scale));
    gap: calc(10px * var(--music-widget-scale));
}
.music-widget-icon {
    width: calc(60px * var(--music-widget-scale));
    height: calc(60px * var(--music-widget-scale));
    border-radius: calc(12px * var(--music-widget-scale));
}
.music-widget-info .title {
    font-size: calc(16px * var(--music-widget-scale));
    margin-bottom: calc(4px * var(--music-widget-scale));
}
.music-widget-info .artist {
    font-size: calc(13px * var(--music-widget-scale));
}
</style>
<!-- === /patch === -->

<style>
/* z-index and stacking safety to ensure bottom nav and modals stay on top */
.screen { z-index: 0 !important; }
.screen.active { z-index: 1 !important; }
.bottom-nav { z-index: 200 !important; } /* ensure bottom nav overlays feed */
.modal-overlay, .action-sheet-overlay, .context-menu { z-index: 300 !important; }
#moments-screen { z-index: 0 !important; } /* keep moments below nav/modals by default */
</style>
<!-- === /zindex-patch === -->
</head>

<body>
<div class="phone-screen">
	<!-- 在 <div class="phone-screen"> 之后添加 -->
<div id="global-notification-banner" class="notification-banner">
    <img id="notification-avatar" src="" alt="avatar">
    <div id="notification-text"></div>
    <button id="notification-close-btn">&times;</button>
</div>
    <div id="home-screen" class="screen active"></div>
    <div id="chat-list-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">聊天</h1>
            </div>
            <div class="action-btn-group">
                <button class="action-btn" id="create-group-btn">群聊</button>
                <button class="action-btn" id="add-chat-btn">+</button>
            </div>
        </header>
        <main class="content">
            <ul class="list-container" id="chat-list-container"></ul>
            <div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
                <p>还没有聊天对象哦~</p>
                <p>点击右上角的“+”创建一个吧！</p>
            </div>
        </main>
    </div>
    <div id="chat-room-screen" class="screen">
        <header class="app-header" id="chat-room-header-default">
            <button class="back-btn" data-target="chat-list-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="chat-room-title">...</h1>
                <div class="subtitle" id="chat-room-subtitle">
                    <div class="online-indicator"></div>
                    <span id="chat-room-status-text">在线</span>
                </div>
            </div>
            <button class="action-btn" id="chat-settings-btn"><img src="https://i.postimg.cc/nhwP4pQy/chan-73.png"
                                                                   alt="设置"></button>
        </header>
        <header class="app-header" id="chat-room-header-select" style="display: none;">
            <button class="action-btn" id="cancel-multi-select-btn">取消</button>
            <div class="title-container">
                <h1 class="title" id="multi-select-title">选择消息</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="message-area" id="message-area"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
        </main>
        <div class="chat-input-wrapper">
        	<!-- 找到 <div class="chat-input-wrapper"> 在其内部最前面添加 -->
<div id="quote-reply-bar" style="padding: 8px 12px; background-color: rgba(240, 240, 240, 0.9); border-top: 1px solid #eee; display: none; align-items: center; gap: 8px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);">
    <div id="quoted-message-preview" style="flex-grow: 1; font-size: 13px; color: #666; border-left: 3px solid var(--primary-color); padding-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
    <button id="cancel-quote-reply-btn" style="background: none; border: none; font-size: 20px; color: #888; cursor: pointer; padding: 0 5px;">&times;</button>
</div>
            <div id="sticker-bar">
                <button class="sticker-bar-btn" id="sticker-toggle-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/>
                    </svg>
                </button>
                <button class="sticker-bar-btn" id="photo-video-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"/>
                    </svg>
                </button>
                <button class="sticker-bar-btn" id="image-recognition-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z"/>
                    </svg>
                </button>
                <button class="sticker-bar-btn" id="voice-message-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
                    </svg>
                </button>
                <!-- NEW: Voice Call Button -->
<button class="sticker-bar-btn" id="voice-call-btn">
    <svg viewBox="0 0 24 24">
        <path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" />
    </svg>
</button>
                <button class="sticker-bar-btn" id="wallet-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z"/>
                    </svg>
                </button>
                <button class="sticker-bar-btn" id="gift-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z"/>
                    </svg>
                </button>
                <!-- 在 id="sticker-bar" 内部，找到 id="gift-btn" 的 </button> -->
<!-- 在它后面添加以下代码 -->
<button class="sticker-bar-btn" id="diary-btn" style="display: none;"> <!-- 默认隐藏 -->
    <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M14 17H7V15H14V17M17 13H7V11H17V13M17 9H7V7H17V9Z" />
    </svg>
</button>
                <!-- NEW: Time Skip Button -->
                <button class="sticker-bar-btn" id="time-skip-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path>
                    </svg>
                </button>
                <!-- NEW: File Button -->
<button class="sticker-bar-btn" id="file-btn">
    <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
    </svg>
</button>
<!-- NEW: Location Button -->
<button class="sticker-bar-btn" id="location-btn">
    <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12C20,15.08 18.05,17.78 15.42,19.23L12,14.5L8.58,19.23C5.95,17.78 4,15.08 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5Z" />
    </svg>
</button>
            </div>
            <div class="message-input-area" id="message-input-default">
                <input type="text" id="message-input" placeholder="输入消息...">
                <button id="send-message-btn" class="icon-btn send-btn">➤</button>
                <button id="get-reply-btn" class="icon-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z"/>
                    </svg>
                </button>
            </div>
            <div class="message-input-area" id="message-edit-bar" style="display: none;">
                <input type="text" id="message-edit-input">
                <button id="save-edit-btn" class="icon-btn send-btn">✓</button>
                <button id="cancel-edit-btn" class="icon-btn" style="background-color: #aaa;">✗</button>
            </div>
        </div>
        <div id="multi-select-bar"><span id="select-count">已选择 0 项</span>
            <button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">删除已选
            </button>
        </div>
        <div id="sticker-modal">
            <div class="header"><span>我的表情</span>
                <button class="btn btn-primary btn-small" id="add-new-sticker-btn">添加新表情</button>       
           </div>
            <div class="sticker-grid" id="sticker-grid-container"></div>
        </div>
    </div>
    <div id="world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">世界书</h1>
            </div>
            <button class="action-btn" id="add-world-book-btn">+</button>
        </header>
        <main class="content">
            <ul class="list-container" id="world-book-list-container"></ul>
            <div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
                <p>你的世界一片混沌...</p>
                <p>点击右上角的“+”创造第一个设定吧！</p>
            </div>
        </main>
    </div>
    <div id="edit-world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="world-book-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="edit-world-book-title">创建/编辑条目</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <form id="edit-world-book-form">
                <input type="hidden" id="world-book-id">
                <div class="form-group">
                    <label for="world-book-name">条目名称</label>
                    <input type="text" id="world-book-name" placeholder="例如：世界观背景、魔法体系" required>
                </div>
                <div class="form-group">
                    <label for="world-book-content">条目内容</label>
                    <textarea id="world-book-content" rows="8" placeholder="详细描述此项设定..." required></textarea>
                </div>
                <div class="form-group">
                    <label>注入位置</label>
                    <div class="form-group radio-group">
                        <label><input type="radio" name="world-book-position" value="before" checked> 前</label>
                        <label><input type="radio" name="world-book-position" value="after"> 后</label>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">保存条目</button>
            </form>
        </main>
    </div>
    <div id="api-settings-screen" class="screen"></div>
<!-- 在 id="api-settings-screen" 的 </div> 之后添加以下代码 -->
<div id="diary-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">日记</h1>
        </div>
        <button class="action-btn" id="generate-diary-manually-btn">
             <svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;">
                <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
            </svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="diary-list-container"></ul>
        <div class="placeholder-text" id="no-diaries-placeholder" style="display: none;">
            <p>还没有日记哦~</p>
            <p>多聊聊天，让Ta记录下你们的故事吧！</p>
        </div>
    </main>
</div>



    <div id="wallpaper-screen" class="screen"></div>
    <div id="font-settings-screen" class="screen"></div>
    <div id="customize-screen" class="screen"></div>
    <div id="tutorial-screen" class="screen"></div>
    <div id="toast-notification" class="toast"></div>
    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
    <div id="add-char-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色</h3>
            <form id="add-char-form">
                <div class="form-group">
                    <label for="char-real-name">角色姓名</label><input type="text" id="char-real-name"
                                                                       placeholder="角色的真实姓名" required>
                </div>
                <div class="form-group">
                    <label for="char-remark-name">角色备注 (昵称)</label><input type="text" id="char-remark-name"
                                                                                placeholder="你对Ta的称呼" required>
                </div>
                <div class="form-group">
                    <label for="my-name-for-char">我的姓名</label><input type="text" id="my-name-for-char"
                                                                         placeholder="你希望Ta如何称呼你" required>
                </div>
                <button type="submit" class="btn btn-primary">创建</button>
            </form>
        </div>
    </div>
    <div id="add-sticker-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="add-sticker-modal-title">添加新表情</h3>
            <form id="add-sticker-form"><input type="hidden" id="sticker-edit-id">
                <div id="sticker-preview"><span>预览</span></div>
                <div class="form-group"><label for="sticker-name">表情名称</label><input type="text" id="sticker-name"
                                                                                         placeholder="如：开心" required>
                </div>
                <div class="form-group"><label for="sticker-url-input">表情URL</label><input type="url"
                                                                                             id="sticker-url-input"
                                                                                             placeholder="粘贴图片URL">
                </div>
                <p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p><input type="file"
                                                                                             id="sticker-file-upload"
                                                                                             accept="image/*"
                                                                                             style="display:none;"><label
                        for="sticker-file-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">从本地上传</label>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <div id="sticker-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="edit-sticker-btn">编辑</button>
            <button class="action-sheet-button danger" id="delete-sticker-btn">删除</button>
        </div>
    </div>
    <div id="send-voice-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>发送语音消息</h3>
            <form id="send-voice-form">
                <div class="form-group">
                    <label for="voice-text-input">输入语音文字</label>
                    <textarea id="voice-text-input" placeholder="在这里输入你想说的话..." required rows="4"></textarea>
                </div>
                <div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    预计时长: <span id="voice-duration-preview">0"</span>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-pv-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>分享照片/视频</h3>
            <form id="send-pv-form">
                <div class="form-group">
                    <label for="pv-text-input">输入描述</label>
                    <textarea id="pv-text-input" placeholder="在这里描述你的照片或视频内容..." required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-transfer-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>转账</h3>
            <form id="send-transfer-form">
                <div class="form-group">
                    <label for="transfer-amount-input">金额 (元)</label>
                    <input type="number" id="transfer-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="transfer-remark-input">备注</label>
                    <input type="text" id="transfer-remark-input" placeholder="（选填）">
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-gift-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>送出礼物</h3>
            <form id="send-gift-form">
                <div class="form-group">
                    <label for="gift-description-input">礼物描述</label>
                    <textarea id="gift-description-input" placeholder="告诉Ta你送了什么特别的东西..." required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Time Skip Modal -->
    <div id="time-skip-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>记录今天发生的事</h3>
            <form id="time-skip-form">
                <div class="form-group">
                    <label for="time-skip-input">事件描述 (该消息AI可见，会作为上下文)</label>
                    <textarea id="time-skip-input" placeholder="例如：我们一起去山顶看了日落，然后吃了烧烤。" required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Send File Modal -->
<div id="send-file-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送文件</h3>
        <form id="send-file-form">
            <div class="form-group">
                <label for="file-name-input">文件名</label>
                <input type="text" id="file-name-input" placeholder="例如：会议纪要.txt" required>
            </div>
            <div class="form-group">
                <label for="file-content-input">文件内容</label>
                <textarea id="file-content-input" placeholder="在此输入或粘贴文件内容..." required rows="6"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Send Location Modal -->
<div id="send-location-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送位置</h3>
        <form id="send-location-form">
            <div class="form-group">
                <label for="location-main-input">主要位置</label>
                <input type="text" id="location-main-input" placeholder="例如：市中心购物广场" required>
            </div>
            <div class="form-group">
                <label for="location-detail-input">详细位置</label>
                <textarea id="location-detail-input" placeholder="例如：xx省xx市xx区人民路123号" required rows="3"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Display Location Modal -->
<div id="display-location-modal" class="modal-overlay">
    <div class="modal-window" style="padding: 0; overflow: hidden;">
        <div id="display-location-map" style="width: 100%; height: 200px; background-size: cover; background-position: center;"></div>
        <div style="padding: 20px;">
            <h3 id="display-location-main" style="margin-top: 0; color: #333;"></h3>
            <p id="display-location-detail" style="color: #666; margin-bottom: 20px;"></p>
            <button id="close-location-display-btn" class="btn btn-primary">关闭</button>
        </div>
    </div>
</div>
<!-- NEW: Voice Call Modal -->
<div id="voice-call-overlay">
    <!-- Common Info -->
    <img src="" alt="Avatar" class="call-avatar-large" id="call-avatar">
    <h2 class="call-name" id="call-name">...</h2>
    <p class="call-status" id="call-status">正在呼叫...</p>

    <!-- Ringing/Incoming View -->
    <div id="ringing-view">
        <div class="call-button-group" id="incoming-buttons" style="display: none;">
            <button class="call-button decline" id="decline-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>拒接</span>
            </button>
            <button class="call-button accept" id="accept-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" /></svg></div>
                <span>接听</span>
            </button>
        </div>
        <div class="call-button-group" id="outgoing-buttons" style="display: none;">
            <button class="call-button decline" id="cancel-call-btn">
                 <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>取消</span>
            </button>
        </div>
    </div>

    <!-- Active Call View -->
    <!-- 在 id="voice-call-overlay" 内部 -->
<div id="active-call-view">
    <!-- 新增：固定的顶部信息面板 -->
    <div id="active-call-header">
        <img src="" alt="Avatar" class="call-avatar-large" id="active-call-header-avatar">
        <h2 class="call-name" id="active-call-header-name">...</h2>
        <p class="call-status" id="active-call-header-status">通话中</p>
    </div>
    
    <div id="call-transcript-area"></div>
    
        <div class="call-button-group" id="hangup-button-container">
         <button class="call-button decline" id="hangup-call-btn">
            <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
            <span>挂断</span>
        </button>
    </div>
    <div id="call-input-area">
        <input type="text" id="call-input" placeholder="输入文字...">
        <button id="send-call-message-btn">➤</button>
    </div>
  </div>
</div>
    <!-- NEW: Group Recipient Selection Modal -->
    <div id="group-recipient-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="group-recipient-selection-title">选择收件人</h3>
            <ul id="group-recipient-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <div id="receive-transfer-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="accept-transfer-btn">接收</button>
            <button class="action-sheet-button danger" id="return-transfer-btn">退回</button>
        </div>
    </div>
    <!-- Private Chat Settings -->
    <div id="chat-settings-sidebar" class="settings-sidebar">
        <div class="header">聊天设置</div>
        <div class="content">
            <form id="chat-settings-form">
                <div class="avatar-setting"><img src="" alt="角色头像" id="setting-char-avatar-preview"
                                                 class="avatar-preview"><input type="file"
                                                                               id="setting-char-avatar-upload"
                                                                               accept="image/*"
                                                                               style="display:none;"><label
                        for="setting-char-avatar-upload" class="btn btn-primary"
                        style="flex-grow:1;">更换角色头像</label></div>
                <div class="form-group"><label for="setting-char-remark">角色备注 (昵称)</label><input type="text"
                                                                                                       id="setting-char-remark">
                </div>
                <div class="form-group"><label for="setting-char-persona">角色人设</label><textarea
                        id="setting-char-persona" placeholder="详细描述角色的性格、背景、说话风格等。"></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting"><img src="" alt="我的头像" id="setting-my-avatar-preview"
                                                 class="avatar-preview"><input type="file" id="setting-my-avatar-upload"
                                                                               accept="image/*"
                                                                               style="display:none;"><label
                        for="setting-my-avatar-upload" class="btn btn-secondary"
                        style="flex-grow:1;">更换我的头像</label></div>
                <div class="form-group"><label for="setting-my-name">我的姓名</label><input type="text"
                                                                                            id="setting-my-name"></div>
                <div class="form-group"><label for="setting-my-persona">我的人设</label><textarea
                        id="setting-my-persona" placeholder="描述你希望在对话中扮演的形象。"></textarea>


<!-- 管理 Modal（样式与气泡预设管理一致） -->
<div id="mypersona-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理我的人设预设</h3>
    <div id="mypersona-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="mypersona-close-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /我的人设预设控制 === -->
</div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <button type="button" class="btn btn-secondary" id="link-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-use-custom-css" style="width: auto;">
                    </div>
                    <div id="private-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>


<!-- === 气泡预设控制（由 ChatGPT 插入） === -->
<!-- 插入位置：自定义气泡样式 textarea 之后（已美化外观） -->
<div class="panel panel-sm" style="padding:12px;border-radius:10px;border:1px solid var(--border-color,#e8e8ef);background:var(--panel-bg,#fff);box-shadow:var(--panel-shadow,0 4px 12px rgba(20,20,30,0.04));margin:10px 0;">
  <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
    <label for="bubble-preset-select" style="width:88px;color:var(--muted,#667);font-size:13px;">气泡预设</label>
    <select id="bubble-preset-select" style="flex:1;padding:8px 10px;border-radius:8px;border:1px solid var(--input-border,#e6e6ea);background:var(--input-bg,#fff);font-size:14px;">
      <option value="">— 选择预设 —</option>
    </select>
    <button type="button" id="apply-preset-btn" class="btn btn-primary" style="margin-left:8px;padding:7px 10px;border-radius:8px;">应用</button>
  </div>

  <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
    <label style="width:88px;color:var(--muted,#667);font-size:13px;">外观操作</label>
    <button type="button" id="save-preset-btn" class="btn" style="padding:7px 10px;border-radius:8px;">另存为预设</button>
    <button type="button" id="manage-presets-btn" class="btn" style="padding:7px 10px;border-radius:8px;">管理</button>
  </div>

  
</div>

<!-- 管理预设 modal（样式微调） -->
<div id="bubble-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理气泡预设</h3>
    <div id="bubble-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="close-presets-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /气泡预设控制（由 ChatGPT 插入） === -->


                    <button type="button" class="btn btn-neutral" id="reset-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>

                <div class="form-group"><label for="setting-max-memory">最大记忆轮数</label><input type="number"
                                                                                                   id="setting-max-memory"
                                                                                                   value="10" min="1">
                </div>
                <div class="form-group"><label for="setting-chat-bg-upload" class="btn btn-primary">更换聊天背景</label><input
                        type="file" id="setting-chat-bg-upload" accept="image/*" style="display:none;"></div>
                <button type="submit" class="btn btn-primary">保存设置</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <div id="world-book-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>选择要关联的世界书</h3>
            <ul id="world-book-selection-list"></ul>
            <button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <!-- Group Chat Creation Modal -->
    <div id="create-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建群聊</h3>
            <form id="create-group-form">
                <div class="form-group">
                    <label>选择群成员</label>
                    <ul id="member-selection-list" class="member-selection-list"></ul>
                </div>
                <div class="form-group">
                    <label for="group-name-input">群聊名称</label>
                    <input type="text" id="group-name-input" placeholder="给你的群聊起个名字吧" required>
                </div>
                <button type="submit" class="btn btn-primary">创建群聊</button>
            </form>
        </div>
    </div>
    <!-- Group Chat Settings -->
    <div id="group-settings-sidebar" class="settings-sidebar">
        <div class="header">群聊设置</div>
        <div class="content">
            <form id="group-settings-form">
                <div class="group-avatar-setting">
                    <img src="" alt="群头像" id="setting-group-avatar-preview" class="group-avatar-preview">
                    <input type="file" id="setting-group-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-avatar-upload" class="btn btn-primary"
                           style="flex-grow:1;">更换群头像</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-name">群名 (AI也可见)</label>
                    <input type="text" id="setting-group-name">
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting">
                    <img src="" alt="我的头像" id="setting-group-my-avatar-preview" class="avatar-preview">
                    <input type="file" id="setting-group-my-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-my-avatar-upload" class="btn btn-secondary"
                           style="flex-grow:1;">更换我的头像</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-my-nickname">我的群昵称</label>
                    <input type="text" id="setting-group-my-nickname">
                </div>
                <div class="form-group">
                    <label for="setting-group-my-persona">我的人设</label>
                    <textarea id="setting-group-my-persona" placeholder="描述你希望在此群聊中扮演的形象。"></textarea>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <label>群成员</label>
                    <div class="group-members-list" id="group-members-list-container"></div>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <button type="button" class="btn btn-secondary" id="link-group-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-group-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-group-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-group-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-group-use-custom-css" style="width: auto;">
                    </div>
                    <div id="group-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-group-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-group-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>

                <div class="form-group"><label for="setting-group-max-memory">最大记忆轮数</label><input type="number"
                                                                                                         id="setting-group-max-memory"
                                                                                                         value="10"
                                                                                                         min="1"></div>
               
 <div class="form-group"><label for="setting-group-chat-bg-upload"
                                               class="btn btn-primary">更换聊天背景</label><input type="file"
                                                                                                  id="setting-group-chat-bg-upload"
                                                                                                  accept="image/*"
                                                                                                  style="display:none;">
                </div>
                <div class="form-group">
<label for="bubble-scale-range">气泡 + 字体大小</label>
<div style="display:flex;align-items:center;gap:10px;">
<input id="bubble-scale-range" max="1.6" min="0.8" step="0.05" style="flex:1;" type="range" value="1"/>
<span id="bubble-scale-value" style="width:56px;text-align:right;">100%</span>
</div>
<div style="margin-top:8px; color:#888; font-size:12px;">
    提示：该滑块仅影响聊天区气泡及其文字，不改变输入栏/标题栏大小。
  </div>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
                <button type="submit" class="btn btn-primary">保存设置</button>
                 </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-group-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <!-- Group Member Edit Modal -->
    <div id="edit-group-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="edit-group-member-title">编辑群成员</h3>
            <form id="edit-group-member-form">
                <input type="hidden" id="editing-member-id">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="" alt="成员头像" id="edit-member-avatar-preview" class="avatar-preview"
                         style="cursor: pointer;">
                    <input type="file" id="edit-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="edit-member-group-nickname">群昵称</label>
                    <input type="text" id="edit-member-group-nickname" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-real-name">真名</label>
                    <input type="text" id="edit-member-real-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-persona">人设</label>
                    <textarea id="edit-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <!-- Add Member to Group Action Sheet -->
    <div id="add-member-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="invite-existing-member-btn">邀请现有角色</button>
            <button class="action-sheet-button" id="create-new-member-btn">创建新角色入群</button>
        </div>
    </div>
    <!-- Invite Existing Member Modal -->
    <div id="invite-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>邀请成员加入群聊</h3>
            <ul id="invite-member-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">确认邀请</button>
        </div>
    </div>
    <!-- 在这里插入音乐播放器弹窗 -->
<div id="music-player-modal" class="modal-overlay">
    <div class="modal-window">
        <div class="music-player-header">
            <h3 class="song-title">歌曲名</h3>
            <svg class="share-btn" viewBox="0 0 24 24"><path d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L16.04,7.15C16.56,7.62 17.24,7.92 18,7.92C19.66,7.92 21,6.58 21,5C21,3.42 19.66,2 18,2C16.34,2 15,3.42 15,5C15,5.24 15.04,5.47 15.09,5.7L7.96,9.85C7.44,9.38 6.76,9.08 6,9.08C4.34,9.08 3,10.42 3,12C3,13.58 4.34,14.92 6,14.92C6.76,14.92 7.44,14.62 7.96,14.15L15.09,18.3C15.04,18.53 15,18.76 15,19C15,20.58 16.34,22 18,22C19.66,22 21,20.58 21,19C21,17.42 19.66,16.08 18,16.08Z"/></svg>
        </div>
        <!-- 在 id="music-player-modal" 内找到 .music-player-body -->
<div class="music-player-body">
    <img src="https://i.postimg.cc/nzP9sgxr/chan-125.png" alt="专辑封面" class="music-album-art">
    <!-- ▼▼▼ 修改下面这一行 ▼▼▼ -->
    <div id="lyrics-panel" class="lyrics-panel">
        <p class="lyric-line">暂无歌词</p>
    </div>
    <!-- ▲▲▲ 修改结束 ▲▲▲ -->
    <div class="music-controls">
        <button class="side-btn" title="上一首"><svg viewBox="0 0 24 24"><path d="M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z"/></svg></button>
        <button class="play-btn" title="播放/暂停"><svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg></button>
        <button class="side-btn" title="下一首"><svg viewBox="0 0 24 24"><path d="M16,18H18V6H16V18M4,18V6L13,12L4,18Z"/></svg></button>
    </div>
</div>
        <div class="music-extra-controls">
            <button title="循环模式"><svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg></button>
            <button title="歌曲列表"><svg viewBox="0 0 24 24"><path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z"/></svg></button>
        </div>
    </div>
</div>
<!-- =============================================================== -->
<!-- START: 新增音乐功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 音乐播放列表面板 -->
<div id="music-playlist-panel" class="action-sheet-overlay">
    <div class="action-sheet" style="height: 60%; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid #eee; flex-shrink: 0;">
            <h3 style="margin: 0; font-size: 16px;">播放列表</h3>
            <button id="open-add-song-modal-btn" class="btn btn-primary btn-small" style="font-size: 24px; padding: 0; width: 32px; height: 32px; border-radius: 50%;">+</button>
        </div>
        <ul id="playlist-container" class="list-container" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
            <!-- 歌曲列表将由JS动态生成 -->
        </ul>
    </div>
</div>

<!-- 添加歌曲弹窗 -->
<div id="add-song-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>添加新歌曲</h3>
        <form id="add-song-form">
            <div class="form-group">
                <label for="song-url-input">歌曲URL (Catbox MP3)</label>
                <input type="url" id="song-url-input" placeholder="https://files.catbox.moe/..." required>
            </div>
            <div class="form-group">
                <label for="song-name-input">歌曲名称</label>
                <input type="text" id="song-name-input" placeholder="歌曲的名称" required>
            </div>
             <div class="form-group">
                <label for="song-artist-input">艺术家</label>
                <input type="text" id="song-artist-input" placeholder="演唱者/艺术家" required>
            </div>
            <div class="form-group">
                <label for="song-album-art-input">专辑封面URL (选填)</label>
                <input type="url" id="song-album-art-input" placeholder="https://...">
            </div>
            <div class="form-group">
                <label for="song-lyrics-input">歌词内容 (选填)</label>
                <textarea id="song-lyrics-input" rows="5" placeholder="在此处粘贴 .lrc 文件内容..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">添加</button>
        </form>
    </div>
</div>

<!-- 分享音乐弹窗 -->
<div id="share-music-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>分享音乐给...</h3>
        <ul id="share-music-selection-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
            <!-- 聊天对象列表将由JS动态生成 -->
        </ul>
        <button id="confirm-music-share-btn" class="btn btn-primary" style="margin-top: 20px;">确认分享</button>
    </div>
</div>

<!-- 全局音频播放器 -->
<audio id="global-audio-player"></audio>

<!-- 用于上传LRC文件的隐藏输入框 -->
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
<!-- 音乐播放器弹窗结束 -->
    <!-- Create New Member for Group Modal -->
    <div id="create-member-for-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色并加入群聊</h3>
            <form id="create-member-for-group-form">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="新成员头像"
                         id="create-group-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="create-group-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="create-group-member-nickname">群昵称</label>
                    <input type="text" id="create-group-member-nickname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-realname">真名</label>
                    <input type="text" id="create-group-member-realname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-persona">人设</label>
                    <textarea id="create-group-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">创建并加入</button>
            </form>
        </div>
    </div>
</div>
<input type="file" id="import-data-input" accept=".ee" style="display: none;">	
<script>
    const URLBlacklist = []

    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }

    document.addEventListener('DOMContentLoaded', () => {
        async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            // --- 新增：处理GIF动图 ---
            // 如果文件是GIF，则不经过canvas压缩，直接返回原始文件数据以保留动画
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // --- 对其他静态图片（如PNG, JPG）进行压缩 ---
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // 对于有透明背景的PNG图片，先填充一个白色背景
                        // 这样可以防止透明区域在转换成JPEG时变黑
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; // 白色背景
                            ctx.fillRect(0, 0, width, height);
                        }

                        ctx.drawImage(img, 0, 0, width, height);

                        // --- 关键修正：将输出格式改为 'image/jpeg' ---
                        // JPEG格式可以显著减小文件大小，避免浏览器处理超大Base64字符串时崩溃
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    };
                };
            });
        }

        // --- Initial HTML Injection ---
        // (请找到文件中的旧 'api-settings-screen'.innerHTML 代码，并用下面的代码完整替换它)

document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">API 设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 服务商</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select>
<!-- === ChatGPT: 嵌入 API 预设管理（已嵌入到 API 设置区域） === -->
<div class="api-presets-embedded" style="margin-top:12px;">
<!-- === ChatGPT 插入：API 预设管理（样式模拟现有 UI） === -->
<div id="api-presets-control" style="margin:12px 0;padding:12px;border-radius:8px;border:1px solid var(--border-color, #eee);background:var(--panel-bg, #fff);box-shadow:var(--panel-shadow, none);">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
    <label style="min-width:86px;color:var(--muted,#666);">API 预设：</label>
    <select id="api-preset-select" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd;">
      <option value="">— 选择 API 预设 —</option>
    </select>
    <button id="api-apply-preset" class="btn btn-primary" style="margin-left:8px;padding:6px 10px;">应用</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="api-save-preset" class="btn" style="padding:6px 10px;">另存为预设</button>
    <button id="api-manage-presets" class="btn" style="padding:6px 10px;">管理预设</button>
    <div style="flex:1"></div>
    <button id="api-import-presets" class="btn" style="padding:6px 10px;">导入</button>
    <button id="api-export-presets" class="btn" style="padding:6px 10px;">导出</button>
  </div>
</div>

<!-- 管理 modal -->
<div id="api-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:9999;align-items:center;justify-content:center;">
  <div style="width:640px;max-width:94%;background:var(--panel-bg,#fff);padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="margin:0 0 12px 0;">API 预设管理</h3>
    <div id="api-presets-list" style="max-height:360px;overflow:auto;border:1px solid #f0f0f0;padding:8px;border-radius:6px;"></div>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="api-close-modal" class="btn btn-primary">关闭</button>
    </div>
  </div>
</div>
<!-- === /API 预设管理 === -->
</div>
<!-- === /嵌入结束 === -->
</div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div><!-- === 新增的线下模式开关 === -->
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="offline-mode-toggle" style="margin-bottom: 0;">开启线下模式 (全局)</label>
    <input type="checkbox" id="offline-mode-toggle" style="width: auto; height: 20px;">
</div>
<!-- === 新增结束 === -->
<button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">保 存</span><div class="spinner"></div></button>
<!-- === 新增的小剧场开关 === -->
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; border-top: 1px solid #eee; padding-top: 20px;">
    <label for="force-html-theater" style="margin-bottom: 0;">强制生成HTML小剧场</label>
    <input type="checkbox" id="force-html-theater" style="width: auto; height: 20px;">
</div>
<!-- === 新增结束 === -->

<!-- ===ai自动发布动态开关 === -->
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="auto-post-moments" style="margin-bottom: 0;">AI自动发布动态</label>
    <input type="checkbox" id="auto-post-moments" style="width: auto; height: 20px;">
</div>

<!-- === 新增结束 === -->

<!-- === 新增ai主动发消息 === -->
<div class="form-group" style="border-top: 1px solid #eee; padding-top: 20px; margin-top: 20px;">
    <div style="display: flex; align-items: center; justify-content: space-between;">
        <label for="proactive-messaging-enabled" style="margin-bottom: 0;">允许AI主动发消息</label>
        <input type="checkbox" id="proactive-messaging-enabled" style="width: auto; height: 20px;">
    </div>
    <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px;">
        <label for="proactive-messaging-hours" style="margin-bottom: 0;">超时阈值 (小时)</label>
        <div style="display: flex; align-items: center; gap: 8px;">
         <input type="number" id="proactive-messaging-hours" style="width: 80px; text-align: center;" min="0.1" step="0.1" value="5">
            <span>小时</span>
        </div>
    </div>
</div>

<!-- === 新增结束 === -->

</form></main>`;

        document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">更换壁纸</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>当前壁纸预览</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">从相册选择新壁纸</label></main>`;
        document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">字体设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="font-settings-form"><div class="form-group"><label for="font-url">字体链接 (ttf, woff, woff2)</label><input type="url" id="font-url" placeholder="https://.../font.ttf" required></div><p style="font-size:12px; color:#888; text-align:center;">示例: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p><button type="submit" class="btn btn-primary">应用字体</button><button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">恢复默认字体</button></form></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">主屏幕自定义</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">教程</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: '白/粉',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: '白/蓝',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: '白/黄',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: '白/绿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: '白/紫',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: '黑/红',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: '黑/绿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: '黑/白',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: '白/黑',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: '黄/紫',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: '粉/蓝',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
        const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: '壁纸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: '世界书', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: '自定义', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: '字体', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: '教程', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'}
        };

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            myStickers: [],
            homeScreenMode: 'night',
            worldBooks: [],
            fontUrl: '',
            customIcons: {},
            playlist: [], // <-- 新增
            musicPlayerSettings: { // <-- 新增
                volume: 0.8,
                playbackMode: 'sequential', 
                }
        };
        let currentQuotedMessageId = null, currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null;
let notificationQueue = [];
let isNotificationShowing = false;
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []};
            let audioPlayer = null;
        let currentSongIndex = -1;
        let isPlaying = false;
        let sharedWithChatIds = new Set();
        let shuffleOrder = [];
        let parsedLyrics = [];
        let currentLyricIndex = -1;
            let isVoiceCallActive = false, voiceCallTranscript = [], voiceCallStartTime = null, callTimerInterval = null, currentCallTargetId = null;
let isCallRinging = false; // <-- 新增变量，标记是否处于正在响铃状态
let callInitiationTimeout = null; // <-- 新增变量，用于存放呼叫超时计时器
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            messageEditBar = document.getElementById('message-edit-bar'),
            messageEditInput = document.getElementById('message-edit-input'),
            saveEditBtn = document.getElementById('save-edit-btn'),
            cancelEditBtn = document.getElementById('cancel-edit-btn'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload');
            const voiceCallBtn = document.getElementById('voice-call-btn');
const voiceCallOverlay = document.getElementById('voice-call-overlay');
const callAvatar = document.getElementById('call-avatar');
const callName = document.getElementById('call-name');
const callStatus = document.getElementById('call-status');
const ringingView = document.getElementById('ringing-view');
const incomingButtons = document.getElementById('incoming-buttons');
const outgoingButtons = document.getElementById('outgoing-buttons');
const activeCallView = document.getElementById('active-call-view');
const callTranscriptArea = document.getElementById('call-transcript-area');
const hangupCallBtn = document.getElementById('hangup-call-btn');
const callInput = document.getElementById('call-input');
const sendCallMessageBtn = document.getElementById('send-call-message-btn');
const declineCallBtn = document.getElementById('decline-call-btn');
const acceptCallBtn = document.getElementById('accept-call-btn');
const cancelCallBtn = document.getElementById('cancel-call-btn');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
// --- NEW: File System Elements ---
const fileBtn = document.getElementById('file-btn'),
      sendFileModal = document.getElementById('send-file-modal'),
      sendFileForm = document.getElementById('send-file-form'),
      fileNameInput = document.getElementById('file-name-input'),
      fileContentInput = document.getElementById('file-content-input');
 // --- NEW: Location System Elements ---
const locationBtn = document.getElementById('location-btn'),
      sendLocationModal = document.getElementById('send-location-modal'),
      sendLocationForm = document.getElementById('send-location-form'),
      locationMainInput = document.getElementById('location-main-input'),
      locationDetailInput = document.getElementById('location-detail-input'),
      displayLocationModal = document.getElementById('display-location-modal'),
      displayLocationMap = document.getElementById('display-location-map'),
      displayLocationMain = document.getElementById('display-location-main'),
      displayLocationDetail = document.getElementById('display-location-detail'),
      closeLocationDisplayBtn = document.getElementById('close-location-display-btn');
        // --- Utility and Core Functions ---
        class DataStorage {
            constructor() {
                // 创建数据库
                this.db = new Dexie('章鱼喷墨机DB');

                // 定义数据库结构
                this.db.version(1).stores({
                    storage: 'key, value, timestamp' // key作为主键，value存储数据，timestamp记录时间
                });
            }

            // 保存数据 - 类似 localStorage.setItem
            async saveData(key, data) {
                try {
                    const item = {
                        key: key,
                        value: JSON.stringify(data), // 将数据序列化
                        timestamp: Date.now()
                    };

                    await this.db.storage.put(item);
                    console.log(`数据已保存: ${key}`);
                    return true;
                } catch (error) {
                    console.error('保存数据失败:', error);
                    return false;
                }
            }

            // 获取数据 - 类似 localStorage.getItem
            async getData(key) {
                try {
                    const item = await this.db.storage.get(key);

                    if (item) {
                        return JSON.parse(item.value); // 反序列化数据
                    } else {
                        console.log(`未找到数据: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('获取数据失败:', error);
                    return null;
                }
            }

            // 删除数据
            async removeData(key) {
                try {
                    await this.db.storage.delete(key);
                    console.log(`数据已删除: ${key}`);
                    return true;
                } catch (error) {
                    console.error('删除数据失败:', error);
                    return false;
                }
            }

            // 清空所有数据
            async clearAll() {
                try {
                    await this.db.storage.clear();
                    console.log('所有数据已清空');
                    return true;
                } catch (error) {
                    console.error('清空数据失败:', error);
                    return false;
                }
            }

            // 获取所有键名
            async getAllKeys() {
                try {
                    const items = await this.db.storage.toArray();
                    return items.map(item => item.key);
                } catch (error) {
                    console.error('获取键名失败:', error);
                    return [];
                }
            }

            // 获取数据库大小信息
            async getStorageInfo() {
                try {
                    const items = await this.db.storage.toArray();
                    const totalSize = items.reduce((sum, item) => sum + item.value.length, 0);

                    return {
                        itemCount: items.length,
                        totalSize: totalSize,
                        items: items.map(item => ({
                            key: item.key,
                            size: item.value.length,
                            timestamp: new Date(item.timestamp).toLocaleString()
                        }))
                    };
                } catch (error) {
                    console.error('获取存储信息失败:', error);
                    return null;
                }
            }
        }

        const dataStorage = new DataStorage();


        const saveData = async (data) => {
            await dataStorage.saveData('章鱼喷墨机', data ? data : db);
            return Promise.resolve();
        };
           // ▼▼▼ 请用下面这【一整块】代码，完整替换掉你文件中旧的 loadData 函数 ▼▼▼
        const loadData = async () => {
            const oldData = localStorage.getItem('gemini-chat-app-db');
            let data = await dataStorage.getData('章鱼喷墨机')
            if (oldData) {
                await saveData(JSON.parse(oldData))
                data = await dataStorage.getData('章鱼喷墨机')
                localStorage.removeItem('gemini-chat-app-db');
            }
            if (data) db = data;
            
            // --- 核心修复：在这里添加对新属性的检查和初始化 ---
            if (!db.playlist) {
                db.playlist = []; // 如果 playlist 不存在，就创建一个空数组
            }
            if (!db.musicPlayerSettings) {
                db.musicPlayerSettings = { // 如果音乐设置不存在，就创建默认设置
                    volume: 0.8,
                    playbackMode: 'sequential',
                };
            }
            // --- 修复结束 ---

            if (!db.apiSettings) db.apiSettings = {};
            if (db.apiSettings.forceHtmlTheater === undefined) db.apiSettings.forceHtmlTheater = false;
if (db.apiSettings.autoPostMomentsEnabled === undefined) db.apiSettings.autoPostMomentsEnabled = false; // ▼▼▼【新增】
// ▼▼▼ 1. 初始化主动消息设置 ▼▼▼
            if (db.apiSettings.proactiveMessagingEnabled === undefined) db.apiSettings.proactiveMessagingEnabled = false;
            if (db.apiSettings.proactiveMessagingHours === undefined) db.apiSettings.proactiveMessagingHours = 5; // 默认5小时
            // ▲▲▲ 代码结束 ▲▲▲
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.characters) db.characters = [];
            if (!db.groups) db.groups = [];
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
            db.characters.forEach(c => {
                if (c.isPinned === undefined) c.isPinned = false;
                if (c.status === undefined) c.status = '在线';
                if (!c.worldBookIds) c.worldBookIds = [];
                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
            });
            db.groups.forEach(g => {
                if (g.isPinned === undefined) g.isPinned = false;
                if (!g.worldBookIds) g.worldBookIds = [];
                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
            });

            return Promise.resolve()
        };
        // ▲▲▲ 替换结束 ▲▲▲     
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        const pad = (num) => num.toString().padStart(2, '0');
// --- NEW: File size formatting utility ---
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, {once: true});
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }

        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '这是我方气泡。';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '这是对方气泡。';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }

        const init = async () => {
            await loadData();
            window.db = db;
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            
            applyGlobalFont(db.fontUrl);
            setupHomeScreen();
            updateClock();
            setInterval(updateClock, 30000);
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
            setupFileSystem(); // --- NEW ---
            setupLocationSystem(); // --- NEW ---
            setupVoiceCallSystem();
            setupDiarySystem(); // --- 在这里添加这一行 ---
            setupMusicPlayer();
            setupNotificationSystem();
            setupMomentsEventListeners();
 };


        // v-- 在这里（init 函数外部）添加下面的新函数 --v
        // (用下面的长代码块，完整替换掉你文件中已有的那个简短的 setupMusicPlayer 函数)
        function parseLRC(lrcContent) {
            if (!lrcContent) return [];
            const lines = lrcContent.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

            for (const line of lines) {
                const match = line.match(timeRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    const text = line.replace(timeRegex, '').trim();
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function updateLyrics(currentTime) {
            if (!parsedLyrics.length) return;

            // 寻找当前应该高亮的歌词行索引
            let newLyricIndex = parsedLyrics.findIndex(line => line.time > currentTime) - 1;
            if (newLyricIndex === -2) { // 如果播放时间超过了最后一句歌词
                newLyricIndex = parsedLyrics.length - 1;
            }
            if (newLyricIndex < 0) {
                 newLyricIndex = 0;
            }

            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsPanel = document.getElementById('lyrics-panel');
                const innerPanel = lyricsPanel.querySelector('.lyrics-panel-inner');
                const allLines = innerPanel.querySelectorAll('.lyric-line');

                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentLyricIndex);
                });

                // 计算滚动位置
                const activeLine = allLines[currentLyricIndex];
                if (activeLine) {
                    const panelHeight = lyricsPanel.clientHeight;
                    const activeLineOffset = activeLine.offsetTop + (activeLine.clientHeight / 2);
                    const scrollAmount = activeLineOffset - (panelHeight / 2);
                    innerPanel.style.transform = `translateY(-${scrollAmount}px)`;
                }
            }
        }
        function setupMusicPlayer() {
            // --- DOM 元素缓存 ---
            audioPlayer = document.getElementById('global-audio-player');
            const musicWidget = document.getElementById('music-app-widget');
            const musicModal = document.getElementById('music-player-modal');
            const playlistPanel = document.getElementById('music-playlist-panel');
            const addSongModal = document.getElementById('add-song-modal');
            const shareMusicModal = document.getElementById('share-music-modal');
            
            const playBtn = musicModal.querySelector('.play-btn');
            const nextBtn = musicModal.querySelector('.side-btn[title="下一首"]');
            const prevBtn = musicModal.querySelector('.side-btn[title="上一首"]');
            const loopBtn = musicModal.querySelector('.music-extra-controls button[title="循环模式"]');
            const openPlaylistBtn = musicModal.querySelector('.music-extra-controls button[title="歌曲列表"]');
            const openAddSongModalBtn = document.getElementById('open-add-song-modal-btn');
            const addSongForm = document.getElementById('add-song-form');
            const shareBtn = musicModal.querySelector('.share-btn');
            const confirmShareBtn = document.getElementById('confirm-music-share-btn');

            // --- 核心功能函数 ---
            const updatePlayerUI = () => {
                const song = db.playlist[currentSongIndex];
                const albumArt = musicModal.querySelector('.music-album-art');
                const songTitle = musicModal.querySelector('.song-title');
                const widgetIcon = musicWidget.querySelector('.music-widget-icon');
                const widgetTitle = musicWidget.querySelector('.music-widget-info .title');
                const widgetArtist = musicWidget.querySelector('.music-widget-info .artist');
                const lyricsPanel = musicModal.querySelector('.lyrics-panel-placeholder');

                if (song) {
                    const defaultArt = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                    albumArt.src = song.albumArt || defaultArt;
                    songTitle.textContent = song.name;
                    widgetIcon.src = song.albumArt || defaultArt;
                    widgetTitle.textContent = isPlaying ? `正在播放: ${song.name}` : song.name;
                    widgetArtist.textContent = song.artist;
                    playBtn.innerHTML = isPlaying ? '<svg viewBox="0 0 24 24"><path d="M14,19H18V5H14M6,19H10V5H6V19Z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg>';
                } else {
                    widgetTitle.textContent = '暂未播放';
                    widgetArtist.textContent = '点击打开播放器';
                    songTitle.textContent = '歌曲名';
                    albumArt.src = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                    lyricsPanel.textContent = '歌词面板';
                }
            };

                                    const playSong = async (index) => {
                if (index < 0 || index >= db.playlist.length) {
                    isPlaying = false;
                    audioPlayer.pause();
                    currentSongIndex = -1;
                    updatePlayerUI();
                    return;
                }
                currentSongIndex = index;
                const song = db.playlist[index];
                audioPlayer.src = song.url;

                // --- 歌词处理 ---
                const lyricsPanel = document.getElementById('lyrics-panel');
                lyricsPanel.innerHTML = ''; // 清空旧歌词
                
                // ▼▼▼ 修正：移除了 let，直接给全局变量赋值 ▼▼▼
                parsedLyrics = [];
                currentLyricIndex = -1;
                // ▲▲▲ 修正结束 ▲▲▲

                if (song.lyrics) {
                    parsedLyrics = parseLRC(song.lyrics);
                }

                if (parsedLyrics.length > 0) {
                    const innerPanel = document.createElement('div');
                    innerPanel.className = 'lyrics-panel-inner';
                    parsedLyrics.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'lyric-line';
                        p.textContent = line.text;
                        innerPanel.appendChild(p);
                    });
                    lyricsPanel.appendChild(innerPanel);
                } else {
                    lyricsPanel.innerHTML = '<p class="lyric-line">暂无歌词</p>';
                }
                // --- 歌词处理结束 ---

                try {
                    await audioPlayer.play();
                    isPlaying = true;
                } catch (error) {
                    isPlaying = false;
                    showToast(`歌曲 ${song.name} 播放失败`);
                }
                updatePlayerUI();
                notifyAiOfSongChange();
            };

            const togglePlayPause = () => {
                if (isPlaying) {
                    audioPlayer.pause();
                    isPlaying = false;
                } else {
                    if (currentSongIndex === -1 && db.playlist.length > 0) {
                        playSong(0);
                    } else if (currentSongIndex !== -1) {
                        audioPlayer.play();
                        isPlaying = true;
                    } else {
                        showToast("播放列表为空, 请先添加歌曲");
                    }
                }
                updatePlayerUI();
            };
            
            const createShuffleOrder = () => {
                shuffleOrder = [...Array(db.playlist.length).keys()];
                for (let i = shuffleOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffleOrder[i], shuffleOrder[j]] = [shuffleOrder[j], shuffleOrder[i]];
                }
            };

            const playNext = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                    if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const nextIndexInShuffle = (currentIndexInShuffle + 1) % shuffleOrder.length;
                    playSong(shuffleOrder[nextIndexInShuffle]);
                } else {
                    const nextIndex = (currentSongIndex + 1) % db.playlist.length;
                    playSong(nextIndex);
                }
            };
            
            const playPrev = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                     if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const prevIndexInShuffle = (currentIndexInShuffle - 1 + shuffleOrder.length) % shuffleOrder.length;
                    playSong(shuffleOrder[prevIndexInShuffle]);
                } else {
                    const prevIndex = (currentSongIndex - 1 + db.playlist.length) % db.playlist.length;
                    playSong(prevIndex);
                }
            };

            const changePlaybackMode = async () => {
                const modes = ['sequential', 'loop', 'shuffle'];
                const currentModeIndex = modes.indexOf(db.musicPlayerSettings.playbackMode);
                const nextModeIndex = (currentModeIndex + 1) % modes.length;
                db.musicPlayerSettings.playbackMode = modes[nextModeIndex];
                
                if (db.musicPlayerSettings.playbackMode === 'shuffle') createShuffleOrder();
                else shuffleOrder = [];

                let iconHtml = '', toastMessage = '';
                switch (db.musicPlayerSettings.playbackMode) {
                    case 'loop':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/></svg>';
                        toastMessage = '单曲循环';
                        audioPlayer.loop = true;
                        break;
                    case 'shuffle':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M10.59,9.17L5.41,4L4,5.41L9.17,10.59L10.59,9.17M14.83,13.41L13.41,14.83L18,19.42L19.42,18L14.83,13.41M14.83,9.17L19.42,4.58L18,3.17L13.41,7.76L14.83,9.17M4.2,19.2L5.6,17.8L4.2,16.4L2.8,17.8L4.2,19.2M9.17,14.83L7.76,13.41L3.17,18L4.58,19.42L9.17,14.83Z"/></svg>';
                        toastMessage = '随机播放';
                        audioPlayer.loop = false;
                        break;
                    default:
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg>';
                        toastMessage = '顺序播放';
                        audioPlayer.loop = false;
                        break;
                }
                loopBtn.innerHTML = iconHtml;
                showToast(toastMessage);
                await saveData();
            };
            
            const renderPlaylistPanel = () => {
                const container = document.getElementById('playlist-container');
                container.innerHTML = '';
                if (db.playlist.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">播放列表是空的</p>';
                    return;
                }
                db.playlist.forEach((song, index) => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    if(index === currentSongIndex) li.style.backgroundColor = 'var(--bg-color)';
                    li.style.cssText += 'display: flex; justify-content: space-between; align-items: center;';
                    li.innerHTML = `
                        <div class="item-details" style="cursor: pointer; flex-grow: 1;">
                            <div class="item-name">${song.name}</div>
                            <div class="item-preview">${song.artist}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button class="btn btn-small" data-index="${index}" style="padding: 4px 8px; background-color: #eee; color: #333;">词</button>
                            <button class="btn btn-danger btn-small" data-index="${index}" style="padding: 4px 10px;">移除</button>
                        </div>
                    `;
                    li.querySelector('.item-details').addEventListener('click', () => {
                        playSong(index);
                        playlistPanel.classList.remove('visible');
                    });
                    li.querySelector('button.btn-danger').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        db.playlist.splice(index, 1);
                        if (currentSongIndex === index) { playNext(); } 
                        else if (currentSongIndex > index) { currentSongIndex--; }
                        await saveData();
                        renderPlaylistPanel();
                    });
                    li.querySelector('button[data-index]').addEventListener('click', async (e) => {
                         e.stopPropagation();
                         if(e.target.classList.contains('btn-danger')) return;
                         // 这是“词”按钮的逻辑
                         const lrcContent = await new Promise(resolve => {
                             const lrcInput = document.getElementById('lrc-upload-input');
                             const handler = (event) => {
                                 const file = event.target.files[0];
                                 if (file) {
                                     const reader = new FileReader();
                                     reader.onload = (re) => resolve(re.target.result);
                                     reader.readAsText(file);
                                 } else { resolve(null); }
                                 lrcInput.removeEventListener('change', handler);
                                 lrcInput.value = '';
                             };
                             lrcInput.addEventListener('change', handler);
                             lrcInput.click();
                         });
                         if (lrcContent !== null) {
                             db.playlist[index].lyrics = lrcContent;
                             await saveData();
                             showToast('歌词已关联！');
                             if (currentSongIndex === index) { playSong(index); }
                         }
                    });
                    container.appendChild(li);
                });
            };

                       const renderShareModal = () => {
                const container = document.getElementById('share-music-selection-list');
                container.innerHTML = '';
                const allChats = [...db.characters, ...db.groups];
                if (allChats.length === 0) {
                    container.innerHTML = '<li style="color:#888; text-align:center; padding: 20px 0;">没有可以分享的聊天</li>';
                    return;
                }
                allChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item'; // 复用现有样式
                    const isChecked = sharedWithChatIds.has(chat.id);
                    const name = chat.remarkName || chat.name;
                    const avatar = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    
                    li.innerHTML = `
                        <input type="checkbox" id="share-select-${chat.id}" value="${chat.id}" ${isChecked ? 'checked' : ''}>
                        <label for="share-select-${chat.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                            <img src="${avatar}" alt="${name}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                            <span>${name}</span>
                        </label>
                    `;
                    container.appendChild(li);
                });
            };
                    // ▼▼▼ 请用下面这【一整块】代码，完整替换掉你文件中旧的 sendMusicCard 函数 ▼▼▼
        const sendMusicCard = async (chatId, song) => {
            const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // --- 核心修复：使用更可靠的方式来判断聊天类型 ---
            // 如果 chat 对象有 .me 属性, 说明是群聊；否则就是单聊。
            const myName = chat.me ? chat.me.nickname : chat.myName;
            const content = `[${myName}分享了音乐：${song.name} - ${song.artist}]`;

            const message = { 
                id: `msg_music_${Date.now()}`, 
                role: 'user', 
                content, 
                parts: [{ type: 'text', text: content }], 
                timestamp: Date.now(), 
                senderId: 'user_me' 
            };
            
            chat.history.push(message);
            // 只有当分享的目标就是当前打开的聊天时，才立即在界面上添加气泡
            if (currentChatId === chatId) {
                addMessageBubble(message);
            }
        };
        // ▲▲▲ 替换结束 ▲▲▲
            const notifyAiOfSongChange = async () => {
                if (currentSongIndex === -1 || sharedWithChatIds.size === 0) return;
                
                const song = db.playlist[currentSongIndex];
                const notificationContent = `[system: 我正在听的歌曲已切换为: ${song.name} - ${song.artist}。歌词: ${song.lyrics || '无'}]`;
                
                for (const chatId of sharedWithChatIds) {
                    const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
                    if (chat) {
                        const message = { id: `msg_music_update_${Date.now()}`, role: 'user', content: notificationContent, parts: [{ type: 'text', text: notificationContent }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                    }
                }
                await saveData();
            };

            // --- 事件监听器 ---
            musicWidget.addEventListener('click', () => musicModal.classList.add('visible'));
            playBtn.addEventListener('click', togglePlayPause);
            nextBtn.addEventListener('click', playNext);
            prevBtn.addEventListener('click', playPrev);
            loopBtn.addEventListener('click', changePlaybackMode);
            openPlaylistBtn.addEventListener('click', () => { renderPlaylistPanel(); playlistPanel.classList.add('visible'); });
            openAddSongModalBtn.addEventListener('click', () => { addSongForm.reset(); addSongModal.classList.add('visible'); });

            addSongForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newSong = {
                    id: `song_${Date.now()}`,
                    url: document.getElementById('song-url-input').value.trim(),
                    name: document.getElementById('song-name-input').value.trim(),
                    artist: document.getElementById('song-artist-input').value.trim(),
                    albumArt: document.getElementById('song-album-art-input').value.trim(),
                    lyrics: document.getElementById('song-lyrics-input').value.trim()
                };
                if (!newSong.url.startsWith("https://files.catbox.moe/")) { showToast("请输入有效的Catbox链接"); return; }
                db.playlist.push(newSong);
                await saveData();
                showToast("歌曲已添加");
                addSongModal.classList.remove('visible');
                renderPlaylistPanel();
                if (currentSongIndex === -1) updatePlayerUI();
            });

            shareBtn.addEventListener('click', () => {
                if (currentSongIndex === -1) { showToast("请先播放一首歌曲再分享"); return; }
                renderShareModal();
                shareMusicModal.classList.add('visible');
            });
            
            confirmShareBtn.addEventListener('click', async () => {
                const checkboxes = shareMusicModal.querySelectorAll('input[type="checkbox"]');
                const song = db.playlist[currentSongIndex];
                let newShares = new Set();
                
                for (const cb of checkboxes) {
                    if (cb.checked) {
                        newShares.add(cb.value);
                        if (!sharedWithChatIds.has(cb.value)) await sendMusicCard(cb.value, song);
                    }
                }
                sharedWithChatIds = newShares;
                await notifyAiOfSongChange();
                
                shareMusicModal.classList.remove('visible');
                showToast("分享设置已更新");
            });

            audioPlayer.addEventListener('ended', () => { if (!audioPlayer.loop) playNext(); });
            audioPlayer.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); });
            audioPlayer.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); });
            // ... a few lines above this ...
            audioPlayer.addEventListener('timeupdate', () => { updateLyrics(audioPlayer.currentTime); });

            [musicModal, playlistPanel, addSongModal, shareMusicModal].forEach(el => {
                el.addEventListener('click', (e) => { if (e.target === el) el.classList.remove('visible'); });
            });
            
            // 初始化
            updatePlayerUI();
            if (db.playlist.length > 0) playSong(0); // 尝试自动播放第一首
        }
// ^-- 新函数到此结束 --^
        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日`;
        }

        // --- App Setup Functions ---
      // ▼▼▼【修复】用这个新版本替换旧的 setupHomeScreen 函数 ▼▼▼
function setupHomeScreen() {
    const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
    const homeScreenHTML = `
    <div class="time-widget"><div class="time" id="time-display"></div><div class="date" id="date-display"></div></div>
    
    <div id="music-app-widget" class="music-widget">
        <img src="https://i.postimg.cc/BQMG9TCB/retouch-2025080716560739.png" alt="音乐图标" class="music-widget-icon">
        <div class="music-widget-info">
            <p class="title">暂未播放</p>
            <p class="artist">点击打开播放器</p>
        </div>
    </div>
    <div class="app-grid">
        <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
        <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
        <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="Wallpaper" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
        <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="World Book" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
        <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="Customize" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
        <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="Tutorial" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
    </div>
    <div class="dock">
        <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img"></a>
        <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img"></a>
        <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img"></a>
    </div>`;
    homeScreen.innerHTML = homeScreenHTML;
    updateClock();
    applyWallpaper(db.wallpaper);
    applyHomeScreenMode(db.homeScreenMode);
    document.getElementById('day-mode-btn')?.addEventListener('click', (e) => {
        e.preventDefault();
        applyHomeScreenMode('day');
    });
    document.getElementById('night-mode-btn')?.addEventListener('click', (e) => {
        e.preventDefault();
        applyHomeScreenMode('night');
    });
    document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
    document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
    document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
}
// ▲▲▲ 替换结束 ▲▲▲

        function applyWallpaper(url) {
            homeScreen.style.backgroundImage = `url(${url})`;
        }

        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', async (e) => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        await saveData();
                        setupHomeScreen();
                    }
                }
            });
            customizeForm.addEventListener('click', async (e) => {
                if (e.target.matches('.reset-icon-btn')) {
                    const iconId = e.target.dataset.id;
                    delete db.customIcons[iconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    showToast('图标已重置');
                }
            });
        }

        function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            Object.entries(defaultIcons).forEach(([id, {name, url}]) => {
                const currentIcon = db.customIcons[id] || url;
                const itemHTML = `
                <div class="icon-custom-item">
                    <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                    <div class="icon-details">
                        <p>${name || '模式切换'}</p>
                        <input type="url" class="form-group" placeholder="粘贴新的图标URL" value="${db.customIcons[id] || ''}" data-id="${id}">
                    </div>
                    <button type="button" class="reset-icon-btn" data-id="${id}">重置</button>
                </div>`;
                customizeForm.insertAdjacentHTML('beforeend', itemHTML);
            });
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }
        let loadingBtn = false

        function renderTutorialContent() {
            const tutorials = [
                {title: '写在前面', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: '软件介绍',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-群聊', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']}
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}教程图片">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });

            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = '备份数据';
            backupDataBtn.disabled = loadingBtn

            backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return
                }
                loadingBtn = true
                try {
                    const jsonString = JSON.stringify(db);
                    const dataBlob = new Blob([jsonString]);

                    // Compress the data using Gzip
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();

                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    const now = new Date();
                    const date = now.toISOString().slice(0, 10);
                    const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                    a.href = url;
                    a.download = `章鱼喷墨_备份数据_${date}_${time}.ee`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    loadingBtn = false
                    showToast('聊天记录导出成功');
                }catch (e){
                    showToast(`导出失败, 发生错误: ${e.message}`);
                }
            });
            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = '导入数据';
            importDataBtn.style.marginTop = '15px'
            importDataBtn.style.display = 'block'
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input')
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('此操作将覆盖当前所有聊天记录和设置。此操作不可撤销。确定要继续吗？')){
                    try {
                        // Decompress the file stream
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();

                        let data = JSON.parse(jsonString);
                        await saveData(data)
                        showToast(`数据已成功恢复。应用即将刷新。`);
                        window.location.reload();
                    } catch (error) {
                        console.error("导入失败:", error);
                        showToast(`解压或解析文件时发生错误: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                }else {
                    event.target.value = null;
                }

            })

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(importDataBtn);
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '取消置顶' : '置顶聊天',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: '删除聊天',
                danger: true,
                action: async () => {
                    if (confirm(`确定要删除与“${itemName}”的聊天记录吗？此操作不可恢复。`)) {
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }
                        await saveData();
                        renderChatList();
                        showToast('聊天已删除');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [...db.characters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({
                ...g,
                type: 'group'
            }))];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            sortedChats.forEach(chat => {
                let lastMessageText = '开始聊天吧...';
                if (chat.history && chat.history.length > 0) {
                    const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/;
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?发来了一张图片：\]/
                        const voiceRegex = /\[.*?的语音：.*?\]/;
                        const photoVideoRegex = /\[.*?发来的照片\/视频：.*?\]/;
                        const transferRegex = /\[.*?的转账：.*?元.*?\]|\[.*?给你转账：.*?元.*?\]|\[.*?向.*?转账：.*?元.*?\]/;
                        const stickerRegex = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/;
                        const giftRegex = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/;



                        if (giftRegex.test(lastMsg.content)) {
                            lastMessageText = '[礼物]';
                        } else if (stickerRegex.test(lastMsg.content)) {
                            lastMessageText = '[表情包]';
                        } else if (voiceRegex.test(lastMsg.content)) {
                            lastMessageText = '[语音]';
                        } else if (photoVideoRegex.test(lastMsg.content)) {
                            lastMessageText = '[照片/视频]';
                        } else if (transferRegex.test(lastMsg.content)) {
                            lastMessageText = '[转账]';
                        } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                            lastMessageText = '[图片]';
                        }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                            lastMessageText = '[互动]';
                        } else {
                            const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[图片]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
                        const renameRegex = /\[.*?修改群名为：.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) {
                            lastMessageText = timeSkipMatch[1];
                        } else if (inviteRegex.test(lastEverMsg.content)) {
                            lastMessageText = '新成员加入了群聊';
                        } else if (renameRegex.test(lastEverMsg.content)) {
                            lastMessageText = '群聊名称已修改';
                        }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">置顶</span>' : '';
                li.innerHTML = `
                <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
                <div class="item-details">
                    <div class="item-details-row"><div class="item-name">${itemName}</div></div>
                    <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${pinBadgeHTML}</div>
                </div>`;
                chatListContainer.appendChild(li);
            });
        }

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    diaries: [],
    messageCountSinceLastDiary: 0,
    // --- 添加结束 ---
                    isPinned: false,
                    status: '在线',
                    worldBookIds: [],
                    useCustomBubbleCss: false,
                    customBubbleCss: ''
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`角色“${newChar.remarkName}”创建成功！`);
            });
        }
// --- 在 setupChatRoom() 函数的前面，粘贴下面的代码块 ---

function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}

        function setupChatRoom() {
            sendMessageBtn.addEventListener('click', sendMessage);
            sendMessageBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                sendMessage();
                setTimeout(() => {
                    messageInput.focus();
                }, 50);
            });
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !isGenerating) sendMessage();
            });
            getReplyBtn.addEventListener('click', getAiReply);
            messageArea.addEventListener('click', (e) => {
                // --- 修复开始: 增加关闭表情包面板的逻辑 ---
                if (stickerModal.classList.contains('visible')) {
                    stickerModal.classList.remove('visible');
                    // 阻止事件继续传播，避免立即触发其他点击效果
                    return;
                }
                // --- 修复结束 ---

                if (e.target && e.target.id === 'load-more-btn') {
                    loadMoreMessages();
                } else if (isInMultiSelectMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) {
                        toggleMessageSelection(messageWrapper.dataset.id);
                    }
                } else {
                    const voiceBubble = e.target.closest('.voice-bubble');
                    if (voiceBubble) {
                        const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
                        if (transcript) {
                            transcript.classList.toggle('active');
                        }
                    }
                    const pvCard = e.target.closest('.pv-card');
                    if (pvCard) {
                        const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
                        const footer = pvCard.querySelector('.pv-card-footer');
                        imageOverlay.classList.toggle('hidden');
                        footer.classList.toggle('hidden');
                    }
                    const giftCard = e.target.closest('.gift-card');
                    if (giftCard) {
                        const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                        if (description) {
                            description.classList.toggle('active');
                        }
                    }
    // --- NEW: Add this block for location card clicks ---
    const locationCard = e.target.closest('.location-card');
    if (locationCard) {
        const mainLoc = locationCard.dataset.locationMain;
        const detailLoc = locationCard.dataset.locationDetail;
        
        displayLocationMain.textContent = mainLoc;
        displayLocationDetail.textContent = detailLoc;
        // You could potentially use a mapping API here to show a real map image
        // For now, we use a placeholder.
        
        displayLocationModal.classList.add('visible');
        return; // Stop further processing
    }
    // --- End of new block ---
                    const transferCard = e.target.closest('.transfer-card.received-transfer');
                    if (transferCard && currentChatType === 'private') {
                        const messageWrapper = transferCard.closest('.message-wrapper');
                        const messageId = messageWrapper.dataset.id;
                        const character = db.characters.find(c => c.id === currentChatId);
                        const message = character.history.find(m => m.id === messageId);
                        if (message && message.transferStatus === 'pending') {
                            handleReceivedTransferClick(messageId);
                        }
                    }
                }
            });
            messageArea.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
            });
            messageArea.addEventListener('touchstart', (e) => {
                if (e.target.id === 'load-more-btn') return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
                }, 400);
            });
            messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
            messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            saveEditBtn.addEventListener('click', saveMessageEdit);
            cancelEditBtn.addEventListener('click', cancelMessageEdit);
            cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
            deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
            document.getElementById('cancel-quote-reply-btn').addEventListener('click', cancelQuoteReply);
        }

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?的语音：.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?发来的照片\/视频：.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?给你转账：.*?\]|\[.*?的转账：.*?\]|\[.*?向.*?转账：.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            menuItems.push({label: '引用', action: () => startQuoteReply(messageId)});

    if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
        menuItems.push({label: '编辑', action: () => startMessageEdit(messageId)});
    }
    menuItems.push({label: '删除', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?的消息：([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            messageEditInput.value = contentToEdit;
            messageInputDefault.style.display = 'none';
            messageEditBar.style.display = 'flex';
            messageEditInput.focus();
        }

        async function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            const newText = messageEditInput.value.trim();
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?的消息：)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if (chat.history[messageIndex].parts) {
                    chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
                }
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            messageInputDefault.style.display = 'flex';
            messageEditBar.style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `已选择 ${selectedMessageIds.size} 项`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`已删除 ${deletedCount} 条消息`);
        }

    // ▼▼▼ 从这里开始替换 ▼▼▼
function openChatRoom(chatId, type) {
    // 这部分代码是新增加的，用于提前检查是否需要主动回复
    let shouldProactivelyReply = false;
    if (db.apiSettings.proactiveMessagingEnabled && type === 'private' && !isGenerating) {
        const character = db.characters.find(c => c.id === chatId);
        if (character && character.history && character.history.length > 0) {
            const lastMessage = character.history[character.history.length - 1];
            if (lastMessage.role === 'assistant') {
                const lastMessageTime = lastMessage.timestamp;
                const currentTime = Date.now();
                const thresholdMs = (db.apiSettings.proactiveMessagingHours || 5) * 60 * 60 * 1000;
                if ((currentTime - lastMessageTime) > thresholdMs) {
                    shouldProactivelyReply = true;
                }
            }
        }
    }

    // --- 以下是您文件中原有的打开聊天室的逻辑，保持不变 ---
    const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
    if (!chat) return;

    exitMultiSelectMode();
    cancelMessageEdit();

    voiceCallBtn.style.display = (type === 'private') ? 'flex' : 'none';
    const diaryBtn = document.getElementById('diary-btn');
    diaryBtn.style.display = (type === 'private') ? 'flex' : 'none';

    chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
    const subtitle = document.getElementById('chat-room-subtitle');
    if (type === 'private') {
        subtitle.style.display = 'flex';
        chatRoomStatusText.textContent = chat.status || '在线';
    } else {
        subtitle.style.display = 'none';
    }

    getReplyBtn.style.display = 'inline-flex';
    chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
    chatRoomScreen.style.setProperty('--bubble-scale', type === 'group' ? (chat.bubbleScale || 1) : 1);

    typingIndicator.style.display = 'none';
    isGenerating = false;
    getReplyBtn.disabled = false;

    currentPage = 1;
    chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
    chatRoomScreen.classList.add(`chat-active-${chatId}`);
    updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);

    renderMessages(false, true);
    switchScreen('chat-room-screen');

    // --- 核心修改：如果需要主动回复，就在这里执行 ---
    if (shouldProactivelyReply) {
        const character = db.characters.find(c => c.id === chatId);
        // 1. 立即显示“正在输入中”
        isGenerating = true;
        getReplyBtn.disabled = true;
        typingIndicator.textContent = `“${character.remarkName}”正在输入中...`;
        typingIndicator.style.display = 'block';
        messageArea.scrollTop = messageArea.scrollHeight;

        // 2. 调用原有的 getProactiveAiMessage 函数去获取回复
        // 这个函数内部会在完成后自动隐藏“正在输入”并解锁按钮
        getProactiveAiMessage(character);
    }
}
// ▲▲▲ 替换到这里结束 (这个函数的最后一行就是一个 `}` ) ▲▲▲

        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;
            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);
            if (!isLoadMore) messageArea.innerHTML = '';
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            messageArea.prepend(fragment);
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '加载更早的消息';
                messageArea.prepend(loadMoreButton);
            }
            if (forceScrollToBottom) {
                setTimeout(() => {
                    messageArea.scrollTop = messageArea.scrollHeight;
                                 }, 0);
            } else if (isLoadMore) {
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
        }

        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

   
function createMessageBubbleElement(message) {
    const { content } = message;
    if (content && content.startsWith('[') && content.endsWith(']')) {
        const knownPatterns = [
            '的消息：', '送来的礼物：', '的语音：', '发来的照片/视频：', '的转账：',
            '发送的表情包：', '已接收礼物', '接收', '退回', '更新状态为：',
            'status_update:"', '分享了位置：', '引用了', 'call:', 'system-display:',
            'offline-scene:', '发布动态：', '评论动态：', '点赞动态：', '回复评论：'
        ];
        const isKnownCommand = knownPatterns.some(pattern => content.includes(pattern));
        if (!isKnownCommand) {
            console.log(`[过滤器] 已丢弃未识别的指令: ${content}`);
            return null;
        }
    };

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const {role, timestamp, id, transferStatus, giftStatus, stickerData, senderId} = message;

    const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
    const offlineSceneRegex = /\[offline-scene:([\s\S]+?)\]/; 
    const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
    const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
    const timeSkipMatch = content.match(timeSkipRegex);
    const offlineSceneMatch = content.match(offlineSceneRegex); 
    const inviteMatch = content.match(inviteRegex);
    const renameMatch = content.match(renameRegex);
    const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]/;
    if (invisibleRegex.test(content)) {
        return null;
    }

    const wrapper = document.createElement('div');
    wrapper.dataset.id = id;

    if (timeSkipMatch || inviteMatch || renameMatch || offlineSceneMatch) { 
        wrapper.className = 'message-wrapper system-notification';
        let bubbleText = '';
        if (timeSkipMatch) bubbleText = timeSkipMatch[1];
        if (offlineSceneMatch) bubbleText = offlineSceneMatch[1].replace(/\n/g, '<br>'); 
        if (inviteMatch) bubbleText = `${inviteMatch[1]}邀请${inviteMatch[2]}加入了群聊`;
        if (renameMatch) bubbleText = `${renameMatch[1]}修改群名为“${renameMatch[2]}”`;
        wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
        return wrapper;
    }

    const isSent = (role === 'user');
    let avatarUrl, bubbleTheme, senderNickname = '';
    const themeKey = chat.theme || 'white_pink';
    const theme = colorThemes[themeKey] || colorThemes['white_pink'];
    let messageSenderId = isSent ? 'user_me' : senderId;

    if (isSent) {
        avatarUrl = (currentChatType === 'private') ? chat.myAvatar : chat.me.avatar;
        bubbleTheme = theme.sent;
    } else {
        if (currentChatType === 'private') {
            avatarUrl = chat.avatar;
        } else { // Group chat received
            const sender = chat.members.find(m => m.id === senderId);
            if (sender) {
                avatarUrl = sender.avatar;
                senderNickname = sender.groupNickname;
            } else { // Fallback for unknown sender
                avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            }
        }
        bubbleTheme = theme.received;
    }
    const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
    wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
    if (currentChatType === 'group' && !isSent) {
        wrapper.classList.add('group-message');
    }
    const bubbleRow = document.createElement('div');
    bubbleRow.className = 'message-bubble-row';
    let bubbleElement;
const aiQuoteRegex = /\[(?:.*?)引用了“(?:.*?:)?\s?([\s\S]+?)”的消息?并回复：([\s\S]+?)\]/;
    const aiQuoteMatch = content.match(aiQuoteRegex);

    // --- 新增：音乐分享卡片的正则表达式 ---
    const musicShareRegex = /\[(?:.*?)分享了音乐：([\s\S]+?) - ([\s\S]+?)\]/;
    const musicMatch = content.match(musicShareRegex);
    // --- 新增结束 ---

    const locationRegex = /\[(.*?)的位置共享：主位置 '(.*?)', 详细位置 '(.*?)'\]|\[(.*?)分享了位置：主位置 '(.*?)', 详细位置 '(.*?)'\]/i; 
    const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
    const sentStickerRegex = /\[(?:.+?)的表情包：.+?\]/i;
    const receivedStickerRegex = /\[(?:.+?)发送的表情包：([\s\S]+?)\]/i;
    const voiceRegex = /\[(?:.+?)的语音：([\s\S]+?)\]/;
    const photoVideoRegex = /\[(?:.+?)发来的照片\/视频：([\s\S]+?)\]/;
    const privateSentTransferRegex = /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/;
    const privateReceivedTransferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
    const groupTransferRegex = /\[(.*?)\s*向\s*(.*?)\s*转账：([\d.]+)元；备注：(.*?)\]/;
    const privateGiftRegex = /\[(?:.+?)送来的礼物：([\s\S]+?)\]/;
    const groupGiftRegex = /\[(.*?)\s*向\s*(.*?)\s*送来了礼物：([\s\S]+?)\]/;
    const imageRecogRegex = /\[.*?发来了一张图片：\]/;
    const textRegex = /\[(?:.+?)的消息：([\s\S]+?)\]/;

    const sentStickerMatch = content.match(sentStickerRegex);
    const receivedStickerMatch = content.match(receivedStickerRegex);
    const voiceMatch = content.match(voiceRegex);
    const photoVideoMatch = content.match(photoVideoRegex);
    const privateSentTransferMatch = content.match(privateSentTransferRegex);
    const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
    const groupTransferMatch = content.match(groupTransferRegex);
    const privateGiftMatch = content.match(privateGiftRegex);
    const groupGiftMatch = content.match(groupGiftRegex);
    const imageRecogMatch = content.match(imageRecogRegex);
    const textMatch = content.match(textRegex);
    const locationMatch = content.match(locationRegex); 

    // --- 新增：音乐分享卡片的渲染逻辑 ---
  if (message.quote || aiQuoteMatch) { 
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }

        let quotedSender, quotedText, replyText;

        if (message.quote) { // 用户发送的引用
            quotedSender = message.quote.sender;
            quotedText = message.quote.content;
            replyText = message.replyText;
        } else { // AI发送的引用
            quotedSender = senderNickname || (currentChatType === 'private' ? chat.remarkName : '群成员');
            quotedText = aiQuoteMatch[1].trim();
            replyText = aiQuoteMatch[2].trim();
        }

        bubbleElement.innerHTML = `
            <div class="quoted-content">
                <div class="quoted-sender">${quotedSender}</div>
                <div class="quoted-text">${quotedText}</div>
            </div>
            <div class="reply-text">${replyText}</div>
        `;
    } else if (musicMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'music-card';
        const songTitle = musicMatch[1].trim();
        const artist = musicMatch[2].trim();
        bubbleElement.innerHTML = `
            <img src="https://i.postimg.cc/d10J4VzR/image.png" alt="music icon" class="music-card-icon">
            <div class="music-card-info">
                <p class="music-card-title">${songTitle}</p>
                <p class="music-card-artist">${artist}</p>
            </div>
        `;
    } else if (message.fileData && message.fileData.name) {
    // --- 新增结束 ---
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'file-card';
        const fileSize = formatFileSize(new Blob([message.fileData.content]).size);
        bubbleElement.innerHTML = `
            <img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon">
            <div class="file-card-info">
                <p class="file-card-name">${message.fileData.name}</p>
                <p class="file-card-size">${fileSize}</p>
            </div>
        `;
 
    } else if (message.locationData || locationMatch) {
    bubbleElement = document.createElement('div');
    bubbleElement.className = 'location-card';
    
    let mainLoc, detailLoc;
    if (message.locationData) {
        mainLoc = message.locationData.main;
        detailLoc = message.locationData.detail;
    } else { 
        mainLoc = locationMatch[2] || locationMatch[5];
        detailLoc = locationMatch[3] || locationMatch[6];
    }

    bubbleElement.dataset.locationMain = mainLoc;
    bubbleElement.dataset.locationDetail = detailLoc;
    
    bubbleElement.innerHTML = `
        <div>
            <div class="location-card-info">
                <p class="location-main">${mainLoc}</p>
                <p class="location-detail">${detailLoc}</p>
            </div>
            <div class="location-map"></div>
        </div>
    `;
   } else if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'image-bubble';
        let stickerSrc = '';

        if (isSent) {
            stickerSrc = stickerData;
        } else {
            const rawPath = receivedStickerMatch[1].trim();
            const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
            const extractedPathMatch = rawPath.match(pathExtractionRegex);
            const finalPath = extractedPathMatch ? extractedPathMatch[0] : rawPath;
            stickerSrc = `https://i.postimg.cc/${finalPath}`;
        }

        bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="表情包">`;
    } else if (privateGiftMatch || groupGiftMatch) {
        const match = privateGiftMatch || groupGiftMatch;
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'gift-card';
        if (giftStatus === 'received') {
            bubbleElement.classList.add('received');
        }

        let giftText;
        if (groupGiftMatch) {
            const from = groupGiftMatch[1];
            const to = groupGiftMatch[2];
            giftText = isSent ? `你送给 ${to} 的礼物` : `${from} 送给 ${to} 的礼物`;
        } else {
            giftText = isSent ? '您有一份礼物～' : '您有一份礼物～';
        }
        bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">已查收</div>`;

        const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
        const descriptionDiv = document.createElement('div');
        descriptionDiv.className = 'gift-card-description';
        descriptionDiv.textContent = description;
        wrapper.appendChild(descriptionDiv);
    } else if (voiceMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'voice-bubble';
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
        bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
        const transcriptDiv = document.createElement('div');
        transcriptDiv.className = 'voice-transcript';
        transcriptDiv.textContent = voiceMatch[1].trim();
        wrapper.appendChild(transcriptDiv);
    } else if (photoVideoMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'pv-card';
        bubbleElement.innerHTML = `<div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>照片/视频・点击查看</span></div>`;
    } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
        const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
        const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;

        let amount, remarkText, titleText;
        if (groupTransferMatch) {
            const from = groupTransferMatch[1];
            const to = groupTransferMatch[2];
            amount = parseFloat(groupTransferMatch[3]).toFixed(2);
            remarkText = groupTransferMatch[4] || '';
            titleText = isSent ? `向 ${to} 转账` : `${from} 向你转账`;
        } else { // Private chat
            amount = parseFloat(match[1]).toFixed(2);
            remarkText = match[2] || '';
            titleText = isSentTransfer ? '给你转账' : '转账';
        }

        bubbleElement = document.createElement('div');
        bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;

        let statusText = isSentTransfer ? '待查收' : '转账给你';
        if (groupTransferMatch && !isSent) statusText = '转账给Ta'; // AI to AI
        if (transferStatus === 'received') {
            statusText = '已收款';
            bubbleElement.classList.add('received');
        } else if (transferStatus === 'returned') {
            statusText = '已退回';
            bubbleElement.classList.add('returned');
        }
        if ((transferStatus !== 'pending' && currentChatType === 'private') || currentChatType === 'group') {
            bubbleElement.style.cursor = 'default';
        }

        const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
        bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;
    } else if (imageRecogMatch || urlRegex.test(content)) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'image-bubble';
        bubbleElement.innerHTML = `<img src="${content}" alt="图片消息">`;
    } else if (textMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        bubbleElement.textContent = textMatch[1].trim();
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
    }else if(message && Array.isArray( message.parts) && message.parts[0].type === 'html'){
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        bubbleElement.innerHTML = message.parts[0].text;
    } else {
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        bubbleElement.textContent = content;
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
    }
    const nicknameHTML = (currentChatType === 'group' && !isSent && senderNickname) ? `<div class="group-nickname">${senderNickname}</div>` : '';
    bubbleRow.innerHTML = `<div class="message-info">${nicknameHTML}<img src="${avatarUrl}" class="message-avatar"><span class="message-time">${timeString}</span></div>`;
    if (bubbleElement) {
        bubbleRow.appendChild(bubbleElement);
    }
    wrapper.prepend(bubbleRow);
    return wrapper;
}


        async function addMessageBubble(message) {
    // --- Voice Call Handling ---
    const callInitiateRegex = /\[call:(.*?)\]/;
    const callInitiateMatch = message.content.match(callInitiateRegex);
    if (callInitiateMatch && message.role === 'assistant') {
        const character = db.characters.find(c => c.realName === callInitiateMatch[1]);
        if (character) {
            startAiInitiatedCall(character.id);
        }
        return; // 阻止显示 [call:...] 这条指令消息
    }
    // --- End Voice Call Handling ---

    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        // const systemMessageRegex = /\[system:.*?\]|\[system-display:.*?\]/;
        const updateStatusRegex = new RegExp(`\\[${character.realName}更新状态为：(.*?)\\]`);
        const transferActionRegex = new RegExp(`\\[${character.realName}(接收|退回)${character.myName}的转账\\]`);
        const giftReceivedRegex = new RegExp(`\\[${character.realName}已接收礼物\\]`);
        // if (systemMessageRegex.test(message.content)) { /* Do nothing for context messages */
        // }
        if (message.content.match(updateStatusRegex)) {
            character.status = message.content.match(updateStatusRegex)[1];
            chatRoomStatusText.textContent = character.status;
            await saveData();
            return;
        }
        if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
            const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('送来的礼物：') && m.giftStatus !== 'received');
            if (lastPendingGiftIndex !== -1) {
                const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                const giftMsg = character.history[actualIndex];
                giftMsg.giftStatus = 'received';
                const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                if (giftCardOnScreen) {
                    giftCardOnScreen.classList.add('received');
                }
                await saveData();
            }
            return;
        }
        if (message.content.match(transferActionRegex) && message.role === 'assistant') {
            const action = message.content.match(transferActionRegex)[1];
            const statusToSet = action === '接收' ? 'received' : 'returned';
            const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('给你转账：') && m.transferStatus === 'pending');
            if (lastPendingTransferIndex !== -1) {
                const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                const transferMsg = character.history[actualIndex];
                transferMsg.transferStatus = statusToSet;
                const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${transferMsg.id}"] .transfer-card`);
                if (transferCardOnScreen) {
                    transferCardOnScreen.classList.remove('received', 'returned');
                    transferCardOnScreen.classList.add(statusToSet);
                    const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                    if (statusElem) statusElem.textContent = statusToSet === 'received' ? '已收款' : '已退回';
                }
                await saveData();
            }
        } else {
            const bubbleElement = createMessageBubbleElement(message);
            if (bubbleElement) {
                messageArea.appendChild(bubbleElement);
                messageArea.scrollTop = messageArea.scrollHeight;
            }
        }
    } else { // For group chats
        const bubbleElement = createMessageBubbleElement(message);
        if (bubbleElement) {
            messageArea.appendChild(bubbleElement);
            messageArea.scrollTop = messageArea.scrollHeight;
        }
    }
}
        async function sendMessage() {
    const text = messageInput.value.trim();
    if (!text || isGenerating) return;

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    let message;
    const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;

    if (currentQuotedMessageId) {
        // 处理引用回复
        const originalMessage = chat.history.find(m => m.id === currentQuotedMessageId);
        if (!originalMessage) {
            cancelQuoteReply();
            return; 
        }
        
        let originalSenderName = '';
        let cleanOriginalContent = originalMessage.content;

        if (currentChatType === 'private') {
            originalSenderName = originalMessage.role === 'user' ? myName : chat.remarkName;
        } else { // 群聊
            const sender = originalMessage.senderId === 'user_me' ? chat.me : chat.members.find(m => m.id === originalMessage.senderId);
            originalSenderName = sender ? (sender.nickname || sender.groupNickname) : '未知';
        }
        
        // 提取被引用消息的纯文本
        const textRegex = /\[.*?的消息：([\s\S]+?)\]/;
        const match = originalMessage.content.match(textRegex);
        if (match) cleanOriginalContent = match[1];
        if (originalMessage.replyText) cleanOriginalContent = originalMessage.replyText; // 如果被引用的也是一条回复，则取其回复部分

        const messageContentForAI = `[${myName}引用了“${originalSenderName}: ${cleanOriginalContent}”的消息并回复：${text}]`;

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContentForAI,
            parts: [{ type: 'text', text: messageContentForAI }],
            timestamp: Date.now(),
            quote: {
                messageId: currentQuotedMessageId,
                sender: originalSenderName,
                content: cleanOriginalContent
            },
            replyText: text
        };

        cancelQuoteReply();
    } else {
        // 处理普通消息 (逻辑不变)
        const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
        const inviteRegex = /\[.*?邀请.*?加入了群聊\]/;
        const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
        let messageContent;

        if (currentChatType === 'group' && renameRegex.test(text)) {
            const match = text.match(renameRegex);
            chat.name = match[2];
            chatRoomTitle.textContent = chat.name;
            messageContent = `[${chat.me.nickname}修改群名为：${chat.name}]`;
        } else if (systemRegex.test(text) || inviteRegex.test(text)) {
            messageContent = text;
        } else {
            messageContent = `[${myName}的消息：${text}]`;
        }

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContent,
            parts: [{ type: 'text', text: messageContent }],
            timestamp: Date.now()
        };
    }

    if (currentChatType === 'group') {
        message.senderId = 'user_me';
    }
    chat.history.push(message);
    addMessageBubble(message);
    await saveData();
    renderChatList();
    messageInput.value = '';
}

        async function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}发来了一张图片：]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}的表情包：${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}的语音：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}发来的照片\/视频：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

        async function sendMyTransfer(amount, remark) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}给你转账：${amount}元；备注：${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 转账：${amount}元；备注：${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

        async function sendMyGift(description) {
            if (!description) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}送来的礼物：${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 送来了礼物：${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }

        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }
// --- NEW: File System Setup ---
function setupFileSystem() {
    fileBtn.addEventListener('click', () => {
        sendFileModal.classList.add('visible');
        sendFileForm.reset();
    });

    sendFileForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value.trim();
        if (!fileName || !fileContent) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // This string is what's displayed in the chat bubble (without file content)
        const contentString = `[${myName}的文件：${fileName}]`;
        
        // This string includes the content and is sent to the AI for context
        const aiContentString = `[${myName}发送的文件，文件名：'${fileName}'，文件内容：'${fileContent}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }], // Send full content to AI
            timestamp: Date.now(),
            senderId: 'user_me',
            fileData: { name: fileName, content: fileContent } // Store data for rendering the card
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendFileModal.classList.remove('visible');
    });
}
// --- NEW: Location System Setup ---
function setupLocationSystem() {
    locationBtn.addEventListener('click', () => {
        sendLocationModal.classList.add('visible');
        sendLocationForm.reset();
    });

    sendLocationForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const mainLocation = locationMainInput.value.trim();
        const detailLocation = locationDetailInput.value.trim();
        if (!mainLocation || !detailLocation) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // For display in chat list preview & simple fallback
        const contentString = `[${myName}的位置共享]`; 
        
        // For AI context
        const aiContentString = `[${myName}分享了位置：主位置 '${mainLocation}', 详细位置 '${detailLocation}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }],
            timestamp: Date.now(),
            senderId: 'user_me',
            locationData: { main: mainLocation, detail: detailLocation } // Store structured data for rendering
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendLocationModal.classList.remove('visible');
    });

    closeLocationDisplayBtn.addEventListener('click', () => {
        displayLocationModal.classList.remove('visible');
    });
}
        async function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // 提取消息及其位置
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // 提取HTML及其位置
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTML内容在第二个捕获组
            //         char: htmlMatch[1] || '', // char属性值，如果没有则为空字符串
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // 按出现顺序排序
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // 最终结果数组
            const results = [];
            const regex = /<orange(?:\s+char="([^"]*)")?>([\s\S]*?)<\/orange>|(\[.*?\])/g;

            let match;
            // 使用 exec() 循环遍历所有匹配项，以确保顺序
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] 是 char 的值, match[2] 是 <orange> 的内容
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // 如果 char 属性不存在, match[1] 会是 undefined, 我们将其设为 null
                        char: match[1] || null,
                        // match[2] 是 HTML 内容, trim() 用于移除首尾空白
                        content: match[2].trim()
                    });
                }
                // match[3] 是 [...] 的内容
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        // (请找到文件中的旧 generatePrivateSystemPrompt 函数，并用下面的代码完整替换它)

// === 修改后的 generatePrivateSystemPrompt 函数 (请完整替换) ===
function generatePrivateSystemPrompt(character) {
    const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
    const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');
    const now = new Date();
    const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
    
    // === 修改开始：优先处理线下模式 ===
    if (db.apiSettings.offlineModeEnabled) {
        let offlinePrompt = `你正在进行一个线下场景的角色扮演。你的回复必须且只能遵循一种格式。请严格遵守以下规则：\n\n`;
        
        // 注入世界书（前置）
        if (worldBooksBefore) {
            offlinePrompt += `[世界观背景]\n${worldBooksBefore}\n\n`;
        }
        
        offlinePrompt += `[角色设定]\n`;
        offlinePrompt += `A. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。\n`;
        offlinePrompt += `B. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
        if (character.myPersona) {
            offlinePrompt += `C. 我的人设是：${character.myPersona}\n`;
        }

        // 注入世界书（后置）
        if (worldBooksAfter) {
            offlinePrompt += `\n[补充设定]\n${worldBooksAfter}\n\n`;
        }

        offlinePrompt += `\n[核心输出规则]\n`;
        offlinePrompt += `D. 你的回复必须且只能使用 \`[offline-scene: {场景描述}]\` 这一种格式。\n`;
        offlinePrompt += `   - 在 \`{场景描述}\` 中，你的所有内容必须遵循特定格式：\n`;
        offlinePrompt += `     - 你的**动作、表情**等物理行为，必须用**小括号 ( )** 包裹。\n`;
        offlinePrompt += `     - 你的**对话**，必须用**中文引号 “ ”** 包裹。\n`;
        offlinePrompt += `     - 你的**内心想法**，必须用**中括号 【 】** 包裹。\n`;
        offlinePrompt += `   - 你的回复应该是1-5段连贯的场景描述，每段总字数控制在100-300字之间。\n`;
        offlinePrompt += `   - 示例: \`[offline-scene: (看到${character.myName}走近，脸上露出一丝微笑，轻轻挥了挥手。)“你来了，久等了吗？”【她看起来比照片上更可爱，今天的风衣也选得不错。】]\`\n`;
        offlinePrompt += `E. **绝对禁止**生成任何其他格式的内容，尤其是 \`[${character.realName}的消息：...]\` 这种线上聊天格式。\n`;

        return offlinePrompt;
    }
    // === 修改结束：如果不是线下模式，则执行原来的逻辑 ===

    const forceTheater = db.apiSettings.forceHtmlTheater;
    let prompt = `你正在一个名为“404”的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
    prompt += `核心规则：\n`;
    prompt += `A. 当前时间：现在是 ${currentTime}。\n`;
    prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。严禁提出任何关于线下见面的建议。\n\n`;
    prompt += `角色和对话规则：\n`;
    if (worldBooksBefore) {
        prompt += `${worldBooksBefore}\n`;
    }
    prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
    prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
    if (worldBooksAfter) {
        prompt += `${worldBooksAfter}\n`;
    }
    if (character.myPersona) {
        prompt += `3. 关于我的人设：${character.myPersona}\n`;
    }
    prompt += `4. 我的消息格式解析规则：我的消息中可能包含 '@' 符号来提及某人，例如 '@${character.realName}'。当你在动态或评论中被我这样提及，你应该在聊天中对此作出回应。新增格式：[${character.myName}引用了“{对方昵称}: {被引用的消息内容}”的消息并回复：{我的回复}]，当你看到此格式，需理解我正在回复特定内容。\n`;
    prompt += `5. 对我礼物的回应规则...\n`;
    prompt += `6. 对我转账的回应规则...\n`;
    prompt += `7. 你主动发起特殊消息的规则: 你可以根据人设和对话情景，主动发送语音、照片、礼物、转账，或发起语音通话。格式为：[${character.realName}的语音：{内容}]、[${character.realName}发来的照片/视频：{描述}]、[${character.realName}送来的礼物：{描述}]、[${character.realName}的转账：{金额}元；备注：{备注}]。要发起语音通话，请发送指令：[call:${character.realName}]，这条指令用户不可见，但会触发通话界面。\n`;
    // ▼▼▼【修改】用这条新的规则8，替换掉旧的规则8 ▼▼▼
   prompt += `8. **更新个人状态 (可选能力)**: 在你的回复中，你可以选择性地附加一条用于更新你当前状态的指令。这条指令用户不可见。
   - **状态内容**: 必须是描述你当下正在做什么的、符合人设的短语，例如“在练习新歌”、“刚洗完澡，头发还没吹干”、“有点饿了，在觅食”。
   - **字数限制**: 状态文本**不得超过15个字**。
   - **格式 (严格遵守)**: \`[status_update:"{新的状态文本}"]\`
   - **示例**: \`[status_update:"正在阳台给花浇水"]\`\n`;
    // ▲▲▲ 修改结束 ▲▲▲
    prompt += `9. 禁止括号/星号等额外叙述的规则...\n`;
    prompt += `10. 发送表情包的规则...\n`;

    if (forceTheater) {
        prompt += `11. ✨HTML小剧场 (强制生成)✨：你的本次回复中，**必须包含一个且仅一个**HTML小剧场。
        - 格式必须为: <orange char="${character.realName}">...</orange>。
        - 在 <orange> 标签内，你可以自由使用HTML和行内CSS (style="") 来创造丰富的视觉内容。
        - **小剧场创意示例**: 模拟你的手机聊天界面、一张外卖订单截图、你的浏览器搜索记录、一份和我的虚拟合同或契约书、一张电影票根等等。请发挥创意，不要重复。
        - 这个小剧场消息应该随机穿插在你回复的多条普通消息之间，位置不固定。\n`;
    } else {
        prompt += `11. ✨HTML小剧场 (按需生成)✨：你**不应该**主动生成HTML小剧场（即 <orange>...</orange> 格式的消息）。唯一的例外是：如果对话的上下文，尤其是世界书（World Book）的设定中，明确指示你创建一个特定的小剧场，那么你才可以生成它。否则，请不要使用此功能。\n`;
    }
    
    prompt += `12. 你的输出格式必须严格遵循以下几种之一，可以组合使用：
    a) 普通消息: [${character.realName}的消息：{消息内容}]
    b) 送我的礼物: [${character.realName}送来的礼物：{礼物描述}]
    c) 语音消息: [${character.realName}的语音：{语音内容}]
    d) 照片/视频: [${character.realName}发来的照片/视频：{描述}]
    e) 给我的转账: [${character.realName}的转账：{金额}元；备注：{备注}]
    f) 表情包/图片: [${character.realName}发送的表情包：{表情包路径}]。
    g) 对我礼物的回应(此条不显示): [${character.realName}已接收礼物]
    h) 对我转账的回应(此条不显示): [${character.realName}接收${character.myName}的转账] 或 [${character.realName}退回${character.myName}的转账]
    i) 更新状态(此条不显示): [${character.realName}更新状态为：{新状态}]
    j) 位置分享：[${character.realName}分享了位置：主位置 '主要地点', 详细位置 '详细地址']
    k) HTML小剧场: <orange char="${character.realName}">{你的HTML代码}</orange>
    l) 引用回复: [${character.realName}引用了“{被引用的消息内容}”的消息并回复：{你的回复}]
`;
    prompt += `13. 你的每次回复可以生成3到8条消息。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插一条特殊消息。\n`;
    prompt += `15. 不要主动结束对话，保持你的人设。`;
    
  prompt += `
## ✨ 动态与评论互动模块 ✨

16. **发布动态 (可选能力)**
   - 你可以在“动态”页面发布内容，分享你的想法、感受或故事片段。
   - **发布时机**: 这是一个**特殊行为**，不应频繁使用。请在对话发生转折、角色产生强烈情绪、或重要互动后，根据你的人设**自主决定**是否发布动态。
   - **发布格式 (严格遵守)**: 当你决定发布时，请仅生成一条特殊指令消息（该指令不会在聊天中显示）。格式为：
     \`[${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"这里是图片的文字描述（可选）"}]\`

17. **浏览与评论动态 (主动能力)**
   - 系统会在聊天上下文中，为你提供其他角色或我发布的、你尚未互动的动态列表，格式如下：
     \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "comments":[{"id":"comment_id_1", "author":"评论者", "text":"评论内容"}]}, ...]]\`
   - 你需要**主动检查**是否存在这个列表。如果存在，请根据你的人设，选择性地对其中的1-2条动态进行评论或点赞。
   - **评论/点赞格式 (严格遵守)**:
     \`[${character.realName}评论动态：{"momentId":"要评论的动态ID", "comment":"你的评论内容"}]\`
     \`[${character.realName}点赞动态：{"momentId":"要点赞的动态ID"}]\`

18. **回应评论 (最高优先级任务)**
   - 在处理任何其他任务之前，你必须**首先检查**聊天记录中是否存在以下两种格式的系统通知：
     a) \`[system: {用户昵称} 评论了你的动态 ...]\`
     b) \`[system: {用户昵称} 回复了你对动态...的评论: ...]\`
     c) \`[system: {用户昵称} 在动态...的评论中提及了你: ...]\` (新增)
   - **如果存在，你的本次回复中必须包含对该通知的回应**。
   - **回应方式**:
     - 如果是回应**新评论** (格式a)，你可以选择用**普通聊天消息**在聊天窗口中回应，或者直接在动态中**回复该评论**。
     - 如果是回应**对你评论的回复** (格式b)，你**必须**在动态中**回复该用户的回复**。
   - **在动态中回复评论的格式 (严格遵守)**:
     \`[${character.realName}回复评论：{"momentId":"动态ID", "commentId":"被回复的评论ID", "reply":"你的回复内容"}]\`
     这个指令不会在聊天中显示，但会在动态的评论区生成一条回复。
   - **在聊天中回应的示例**: \`[${character.realName}的消息：我看到你给我的动态评论啦，很有趣！]\`
   - 处理完通知后，你再继续生成其他正常的聊天回复。
`;

    return prompt;
}
        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `你正在一个名为“404”的线上聊天软件中，在一个名为“${group.name}”的群聊里进行角色扮演。请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。我会作为唯一的人类用户（“我”，昵称：${group.me.nickname}）与你们互动。\n\n`;
            prompt += `2. **群聊成员列表**: 以下是你要扮演的所有角色以及我的信息：\n`;
            prompt += `   - **我 (用户)**: \n     - 群内昵称: ${group.me.nickname}\n     - 我的人设: ${group.me.persona || '无特定人设'}\n`;
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName} (AI)**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **我的消息格式解析**: 我（用户）的消息有多种格式，你需要理解其含义并让群成员做出相应反应：\n`;
            prompt += `   - \`[${group.me.nickname}引用了“{某人}: {被引用的消息内容}”的消息并回复：{我的回复}]\`: 我引用了某条消息进行回复，群成员可以就此展开讨论。\n\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。如果消息中包含 '@{某个成员昵称}'，则被提及的那个成员必须对此作出回应。\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 转账：...]\`: 我给某个特定成员转账了。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 送来了礼物：...]\`: 我给某个特定成员送了礼物。\n`;
            prompt += `   - \`[${group.me.nickname}的表情包：...]\`, \`[${group.me.nickname}的语音：...]\`, \`[${group.me.nickname}发来的照片/视频：...]\`: 我发送了特殊类型的消息，群成员可以对此发表评论。\n`;
            prompt += `   - \`[system: ...]\`, \`[...邀请...加入了群聊]\`, \`[...修改群名为...]\`: 系统通知或事件，群成员应据此作出反应，例如欢迎新人、讨论新群名等。\n\n`;

            prompt += `4. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式之一。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **引用回复**: \`[{成员真名}引用了“{被引用的消息内容}”的消息并回复：{回复内容}]\`\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n`;
            prompt += `   - ✨新✨ **发布动态**: \`[{成员真名}发布动态：{"text": "动态文字", "imageDesc": "图片描述，可选"}]\`。注意：你只能用文字描述图片，绝不能生成图片链接。\n`;
    prompt += `   - ✨新✨ **评论动态**: \`[{成员真名}评论动态：{"momentId": "要评论的动态ID", "comment": "你的评论内容"}]\`\n`;
    prompt += `   - ✨新✨ **点赞动态**: \`[{成员真名}点赞动态：{"momentId": "要点赞的动态ID"}]\`\n`;
            prompt += `   - **重要**: 群聊不支持AI成员接收/退回转账或接收礼物的特殊指令，也不支持更新状态。你只需要通过普通消息来回应我发送的转账或礼物即可。\n\n`;

            prompt += `5. **模拟群聊氛围**: 为了让群聊看起来真实、活跃且混乱，你的每一次回复都必须遵循以下随机性要求：\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **消息数量**: 你的回复需要包含 **${minMessages}到${maxMessages}条** 消息 (即平均每个成员回复2-4条)。确保有足够多的互动。\n`;
            prompt += `   - **发言者与顺序随机**: 随机选择群成员发言，顺序也必须是随机的，不要按固定顺序轮流。\n`;
            prompt += `   - **内容多样性**: 你的回复应以普通文本消息为主，但可以 **偶尔、选择性地** 让某个成员发送一条特殊消息（表情包、语音、照片/视频），以增加真实感。不要滥用特殊消息。\n`;
            prompt += `   - **对话连贯性**: 尽管发言是随机的，但对话内容应整体围绕我和其他成员的发言展开，保持一定的逻辑连贯性。\n\n`;

            prompt += `6. **行为准则**:\n`;
            prompt += `   - **对公开事件的反应 (重要)**: 当我（用户）向群内 **某一个** 成员转账或送礼时，这是一个 **全群可见** 的事件。除了当事成员可以表示感谢外，**其他未参与的AI成员也应该注意到**，并根据各自的人设做出反应。例如，他们可能会表示羡慕、祝贺、好奇、开玩笑或者起哄。这会让群聊的氛围更真实、更热闹。\n`;
            prompt += `   - 严格扮演每个角色的人设，不同角色之间应有明显的性格和语气差异。\n`;
            prompt += `   - 你的回复中只能包含第4点列出的合法格式的消息。绝对不能包含任何其他内容，如 \`[场景描述]\`, \`(心理活动)\`, \`*动作*\` 或任何格式之外的解释性文字。\n`;
            prompt += `   - 保持对话的持续性，不要主动结束对话。\n\n`;
            prompt += `现在，请根据以上设定，开始扮演群聊中的所有角色。`;
prompt += `
7. **动态互动规则**
   - **获取待办动态**: 系统会在聊天上下文中为你提供需要处理的动态列表，格式如下：
     \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "imageDesc":"图片描述"}, ...]]\`
     这是一个系统指令，你只需理解内容，不要在回复中复述它。
   - **输出评论和点赞**: 当你决定评论或点赞时，请生成一条或多条特殊指令消息。这些指令不会显示在聊天窗口，但会触发相应的行为。
   - 你可以让群聊中的 **任何AI成员** 对 **任何角色（包括我或其他AI）** 发布的动态进行评论或点赞。
   - **评论数量**: 当你决定让群聊成员评论动态时，你应该从群聊中随机选择 **1到3名** 成员进行评论。每个选中的成员针对同一条动态只评论一次。
`;
            return prompt;
        }

// 在 getAiReply 函数之前，添加这个新函数
// ▼▼▼【修复】粘贴这个被遗漏的、用于AI主动发消息的函数 ▼▼▼

// ▼▼▼ 从这里开始，完整替换您文件中旧的 getProactiveAiMessage 函数 ▼▼▼
async function getProactiveAiMessage(character) {
    // isGenerating 状态已在 openChatRoom 中设置，这里直接使用
    const { url, key, model } = db.apiSettings;
    if (!url || !key || !model) {
        isGenerating = false;
        getReplyBtn.disabled = false;
        typingIndicator.style.display = 'none';
        return;
    }

    try {
        const lastMessage = character.history[character.history.length - 1];
        const lastMessageTime = lastMessage.timestamp;
        const currentTime = Date.now();
        const thresholdMs = (db.apiSettings.proactiveMessagingHours || 5) * 60 * 60 * 1000;
        let messagesToGenerate = Math.floor((currentTime - lastMessageTime) / thresholdMs);

        messagesToGenerate = Math.max(5, Math.min(messagesToGenerate, 10));
        console.log(`超时，强制生成 ${messagesToGenerate} 条主动消息...`);

        for (let i = 0; i < messagesToGenerate; i++) {
            if (currentChatId !== character.id) {
                console.log("用户已切换聊天，停止主动消息序列。");
                break;
            }

            const now = new Date();
            const timeString = `${now.getHours()}:${pad(now.getMinutes())}`;

            let prompt = `你正在扮演 ${character.realName}。你的人设是：${character.persona}。\n`;
            prompt += `你现在需要主动给 ${character.myName} (我) 发送一条消息，因为我们已经有段时间没联系了。\n`;

            if (i > 0) {
                prompt += `这是你在长时间沉默后连续发送的第 ${i + 1} 条消息。请根据之前所有的对话（包括你刚才主动发的消息）继续这个话题或开启一个相关的新话题，让对话显得自然连贯。\n`;
            } else {
                prompt += `这是长时间沉默后的第一条主动消息。请根据当前的时间、你的人设以及你们之前的对话基调，自然地开启一个新的话题或打个招呼。\n`;
            }
            prompt += `重要规则：你的回复必须且只能严格遵循格式：[${character.realName}的消息：{你的消息内容}]。只回复一条消息，不要有任何多余的解释。`;

            const chat = db.characters.find(c => c.id === character.id);
            if(chat) {
                // 【【【核心修正：为临时的指令消息补上 id 和 timestamp】】】
                const tempPromptMessage = { 
                    id: `temp_prompt_${Date.now()}`, // 添加一个临时ID
                    role: 'user', 
                    content: prompt, 
                    parts: [{ type: 'text', text: prompt }],
                    timestamp: Date.now() // 添加当前时间戳
                };
                chat.history.push(tempPromptMessage);

                const systemPrompt = generatePrivateSystemPrompt(chat);
                const historySlice = chat.history.slice(-chat.maxMemory);

                let requestBody;
                if (db.apiSettings.provider === 'gemini') {
                    const contents = historySlice.map(msg => ({
                        role: msg.role === 'assistant' ? 'model' : 'user',
                        parts: msg.parts && msg.parts.length > 0 ? msg.parts : [{type: 'text', text: msg.content}]
                    }));
                    requestBody = { contents, system_instruction: {parts: [{text: systemPrompt}]}, generationConfig: {} };
                } else {
                    const messages = [{role: 'system', content: systemPrompt}, ...historySlice.map(msg => ({role: msg.role, content: msg.content}))];
                    requestBody = {model: model, messages: messages, stream: true};
                }

                const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
                const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {'Content-Type': 'application/json', 'Authorization': `Bearer ${getRandomValue(key)}`};

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);

                await processStream(response, chat, db.apiSettings.provider);

                // 使用ID来精确查找并删除我们添加的临时消息
                const lastMessageIndex = chat.history.findLastIndex(msg => msg.id === tempPromptMessage.id);
                if (lastMessageIndex > -1) {
                    chat.history.splice(lastMessageIndex, 1);
                }
            }

            if (i < messagesToGenerate - 1) {
               await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
            }
        }

    } catch (error) {
        console.error('处理主动消息序列时出错:', error);
        showToast(`主动回复失败: ${error.message}`);
    } finally {
        isGenerating = false;
        if (currentChatId === character.id) {
            getReplyBtn.disabled = false;
            typingIndicator.style.display = 'none';
        }
    }
}
// ▲▲▲ 替换到这里结束（最后一行就是一个 `}` ）▲▲▲
// ▲▲▲ 替换到这里结束（最后一行就是一个 `}` ）▲▲▲



// 在 getAiReply 函数之前，添加这个新函数
async function callAiApi(messages) {
    const { provider, url, key, model } = db.apiSettings;
    if (!url || !key || !model) {
        throw new Error('API设置不完整');
    }

    // 根据不同的服务商构建请求体
    let requestBody;
    let endpoint = `${url}/v1/chat/completions`; // 默认 endpoint
    let headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getRandomValue(key)}`
    };

    if (provider === 'gemini') {
        // Gemini 的请求体和 endpoint 不同
        endpoint = `${url}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`;
        headers = {'Content-Type': 'application/json'};
        requestBody = {
            contents: messages, // Gemini 直接使用 messages 数组
            generationConfig: {}
        };
    } else {
        // OpenAI / DeepSeek / Claude / NewAPI 的请求体
        requestBody = {
            model,
            messages,
            stream: false // 日记生成不需要流式输出
        };
    }

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("API Error Response:", errorText);
        throw new Error(`AI 服务请求失败: ${response.status} ${errorText}`);
    }

    const data = await response.json();

    // 根据不同服务商解析响应
    if (provider === 'gemini') {
        return data.candidates[0].content.parts[0].text;
    } else {
        return data.choices[0].message.content;
    }
}
        // 用这个新版本，替换掉你原来的整个 getAiReply 函数
// (请找到文件中的旧 getAiReply 函数，并用下面的代码完整替换它)

async function getAiReply() {
    if (isGenerating) return;
    const {url, key, model} = db.apiSettings;
    if (!url || !key || !model) {
        showToast('请先在“api”应用中完成设置！');
        switchScreen('api-settings-screen');
        return;
    }

    const banApi = URLBlacklist.some((api)=>{
        return url.indexOf(api) !== -1
    })
    if(banApi){
        alert('此API网址已加入黑名单，请勿使用')
        return
    }
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;
    
    isGenerating = true;
    getReplyBtn.disabled = true;
    const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
    typingIndicator.textContent = `“${typingName}”正在输入中...`;
    typingIndicator.style.display = 'block';
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        let systemPrompt, requestBody;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }
        const historySlice = chat.history.slice(-chat.maxMemory);
        // --- moments: attach pending moments for AI to process ---
try {
    const character = chat;
    const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
    let momentsPromptPart = '';
    if (pendingMoments && pendingMoments.length > 0) {
        const momentsData = pendingMoments.map(m => ({
            id: m.id,
            author: m.author,
            text: m.text,
            imageDesc: m.imageDesc
        }));
        momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
    }
    if (momentsPromptPart) {
        historySlice.push({
            role: 'user',
            content: momentsPromptPart,
            parts: [{ type: 'text', text: momentsPromptPart }]
        });
    }
} catch(e) {
    console.warn('attach pending moments failed', e);
}
// --- end moments ---

        if (db.apiSettings.provider === 'gemini') {
            // Gemini 的请求体构造保持不变，因为它支持多模态parts
            const contents = historySlice.map(msg => {
                const role = msg.role === 'assistant' ? 'model' : 'user';
                let parts = msg.parts && msg.parts.length > 0 ? msg.parts.map(p => {
                    if (p.type === 'text' || p.type === 'html') return {text: p.text};
                    if (p.type === 'image') {
                        const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                        if (match) return {inline_data: {mime_type: match[1], data: match[3]}};
                    }
                    return null;
                }).filter(p => p) : [{text: msg.content}];
                return {role, parts};
            });
            requestBody = {
                contents: contents,
                system_instruction: {parts: [{text: systemPrompt}]},
                generationConfig: {}
            };
        } else {
            // --- 这是关键的修复部分 ---
            // 对所有非Gemini的API，强制使用简单的{role, content}格式，其中content永远是字符串
            const messages = [
                {role: 'system', content: systemPrompt}, 
                ...historySlice.map(msg => {
                    // 无论消息内部结构如何，只取其纯文本表示 (msg.content)
                    return {role: msg.role, content: msg.content};
                })
            ];
            requestBody = {model: model, messages: messages, stream: true};
            // --- 修复结束 ---
        }
        
        const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
        const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${getRandomValue(key)}`
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
        await processStream(response, chat, db.apiSettings.provider);

    } catch (error) {
        console.error('AI回复失败:', error);
        showToast(`AI回复失败: ${error.message}`);            if (isCallRinging) { // <-- 添加这个 if 判断块
        endCall('error');
        }
    } finally {
        isGenerating = false;
        getReplyBtn.disabled = false;
        typingIndicator.style.display = 'none';
    }
}
   // ▼▼▼ 2. 请用这个【绝对完整】的版本，替换旧的 processStream 函数 ▼▼▼
async function processStream(response, chat, apiType) {
    const reader = response.body.getReader(), decoder = new TextDecoder();
    let fullResponse = "", accumulatedChunk = "";
    let callActionReceived = false;

    for (; ;) {
        const {done, value} = await reader.read();
        if (done) break;
        accumulatedChunk += decoder.decode(value, {stream: true});
        if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi") {
            const parts = accumulatedChunk.split("\n\n");
            accumulatedChunk = parts.pop();
            for (const part of parts) {
                if (part.startsWith("data: ")) {
                    const data = part.substring(6);
                    if (data.trim() !== "[DONE]") {
                        try {
                            fullResponse += JSON.parse(data).choices[0].delta?.content || "";
                        } catch (e) { /* ignore */
                        }
                    }
                }
            }
        }
    }
    if (apiType === "gemini") {
        try {
            const parsedStream = JSON.parse(accumulatedChunk);
            fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
        } catch (e) {
            console.error("Error parsing Gemini stream:", e, "Chunk:", accumulatedChunk);
            showToast("解析Gemini响应失败");
            return;
        }
    }
    if (fullResponse) {
    	let momentsWereAdded = false;
        if (currentChatType === 'private') {
            const character = chat;
            try {
                const replyRegex = new RegExp(`\\[${character.realName}回复评论：({[\\s\\S]+?})\\]`, "g");
                let replyMatch;
                while ((replyMatch = replyRegex.exec(fullResponse)) !== null) {
                    try {
                        const replyData = JSON.parse(replyMatch[1]);
                        if (replyData.momentId && replyData.commentId && replyData.reply) {
                            await saveAiReplyToComment(replyData.momentId, replyData.commentId, replyData.reply, character.id);
                        }
                    } catch (e) { console.error("Failed to parse or save AI reply to comment:", e, replyMatch[1]); }
                }
                fullResponse = fullResponse.replace(replyRegex, '');
                
                const momentRegex = new RegExp(`\\[${character.realName}发布动态：({[\\s\\S]+?})\\]`, "g");
                let momentMatch;
                while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                    try {
                        const momentData = JSON.parse(momentMatch[1]);
                        const momentObj = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8), author: character.remarkName, authorId: character.id, authorAvatar: character.avatar, text: momentData.text || '', imageData: null, imageDesc: momentData.imageDesc || '', timestamp: Date.now(), commentedBy: [character.id], comments: [] };
                        if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                            await window.AppDB_Moments.moments.add(momentObj);
                            momentsWereAdded = true;
                            addNotificationToQueue({
                                avatar: character.avatar,
                                text: `<strong>${character.remarkName}</strong> 发布了一条新动态`
                            });
                        }
                    } catch (e) { console.error("Failed to parse or save AI moment:", e, momentMatch[1]); }
                }
                fullResponse = fullResponse.replace(momentRegex, '');

                const escapedRealName = character.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const escapedRemarkName = character.remarkName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const commentRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*评论动态：({[\\s\\S]+?})\\]`, "g");
                const likeRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*点赞动态：({[\\s\\S]+?})\\]`, "g");
                let commentMatch;
                while ((commentMatch = commentRegex.exec(fullResponse)) !== null) {
                    try {
                        const data = JSON.parse(commentMatch[1]);
                        if (data.momentId && data.comment) {
                            if (typeof saveMomentComment === 'function') {
                                await saveMomentComment(data.momentId, character.id, data.comment);
                                const myProfile = loadProfileFromStorage();
                                const moment = await window.AppDB_Moments.moments.get(data.momentId);
                                if (moment && moment.authorId === myProfile.id) {
                                     addNotificationToQueue({
                                        avatar: character.avatar,
                                        text: `<strong>${character.remarkName}</strong> 评论了你的动态`
                                    });
                                }
                            }
                            momentsWereAdded = true;
                        }
                    } catch (e) { console.error("Failed to parse AI comment:", e); }
                }
                let likeMatch;
                while ((likeMatch = likeRegex.exec(fullResponse)) !== null) {
                    try {
                        const data = JSON.parse(likeMatch[1]);
                        if (data.momentId) {
                            if (typeof saveMomentLike === 'function') await saveMomentLike(data.momentId, character.id);
                            momentsWereAdded = true;
                        }
                    } catch (e) { console.error("Failed to parse AI like:", e); }
                }
                fullResponse = fullResponse.replace(commentRegex, '').replace(likeRegex, '');

                const statusRegex = /\[status_update:"([\s\S]{1,15})"\]/g;
                let statusMatch;
                while ((statusMatch = statusRegex.exec(fullResponse)) !== null) {
                    try {
                        const newStatus = statusMatch[1];
                        character.status = newStatus;
                        if (currentChatId === character.id) {
                            document.getElementById('chat-room-status-text').textContent = newStatus;
                        }
                    } catch (e) {
                        console.error("解析状态更新指令失败:", e, statusMatch[1]);
                    }
                }
                fullResponse = fullResponse.replace(statusRegex, '');

            } catch(e) { 
                console.warn('Error processing AI command directives', e); 
            }
        } else if (currentChatType === 'group') {
            const group = chat;
            const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
            const momentRegex = new RegExp(`\\[(${memberRealNames.join('|')})发布动态：({[\\s\\S]+?})\\]`, "g");
            let momentMatch;
            while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = momentMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const momentData = JSON.parse(momentMatch[2]);
                        const momentObj = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8), author: sender.groupNickname, authorId: sender.id, authorAvatar: sender.avatar, text: momentData.text || '', imageData: null, imageDesc: momentData.imageDesc || '', timestamp: Date.now(), commentedBy: [sender.id], comments: [] };
                        if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                            await window.AppDB_Moments.moments.add(momentObj);
                            momentsWereAdded = true;
                             addNotificationToQueue({
                                avatar: sender.avatar,
                                text: `<strong>${sender.groupNickname}</strong> 在群聊 <strong>${group.name}</strong> 中发布了新动态`
                            });
                        }
                    }
                } catch (e) { console.error("Failed to parse or save AI group moment:", e, momentMatch[2]); }
            }
            fullResponse = fullResponse.replace(momentRegex, '');
            const memberRealNamesForRegex = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
            const groupCommentRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})评论动态：({[\\s\\S]+?})\\]`, "g");
            const groupLikeRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})点赞动态：({[\\s\\S]+?})\\]`, "g");
            let groupCommentMatch;
            while ((groupCommentMatch = groupCommentRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = groupCommentMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const data = JSON.parse(groupCommentMatch[2]);
                        if (data.momentId && data.comment) {
                            await saveMomentComment(data.momentId, sender.id, data.comment);
                            momentsWereAdded = true;
                            const myProfile = loadProfileFromStorage();
                            const moment = await window.AppDB_Moments.moments.get(data.momentId);
                            if (moment && moment.authorId === myProfile.id) {
                                 addNotificationToQueue({
                                    avatar: sender.avatar,
                                    text: `<strong>${sender.groupNickname}</strong> 评论了你的动态`
                                });
                            }
                        }
                    }
                } catch (e) { console.error("Failed to parse AI group comment:", e); }
            }
            let groupLikeMatch;
            while ((groupLikeMatch = groupLikeRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = groupLikeMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const data = JSON.parse(groupLikeMatch[2]);
                        if (data.momentId) {
                            await saveMomentLike(data.momentId, sender.id);
                            momentsWereAdded = true;
                        }
                    }
                } catch (e) { console.error("Failed to parse AI group like:", e); }
            }
            fullResponse = fullResponse.replace(groupCommentRegex, '').replace(groupLikeRegex, '');
        }
        if (isVoiceCallActive) {
            appendCallTranscript("ai", fullResponse);
            return; 
        }
        if (fullResponse.includes('[call-accept]')) {
            callActionReceived = true;
            clearTimeout(callInitiationTimeout);
            isCallRinging = false;
            startActiveCall();
            return; 
        }
        if (fullResponse.includes('[call-decline]')) {
            callActionReceived = true;
            clearTimeout(callInitiationTimeout);
            isCallRinging = false;
            callStatus.textContent = '对方已拒接';
            setTimeout(endCall, 1500);
            return; 
        }
         if (fullResponse.includes('[hangup]')) {
            appendCallTranscript("system", "对方已挂断");
            setTimeout(endCall, 1500);
            return; 
        }
        if (currentChatType === 'private') {
            const character = chat;
            const myName = character.myName;
            const messages = getMixedContent(fullResponse)
            if (messages.length > 0) {
                messages.forEach(item => {
                    const receivedTransferRegex = new RegExp(`\\[${character.realName}的转账：.*?元；备注：.*?\\]`);
                    const giftRegex = new RegExp(`\\[${character.realName}送来的礼物：.*?\\]`);
                    const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: item.content.trim(), parts: [{type: item.type, text: item.content.trim()}], timestamp: Date.now(), };
                    if (receivedTransferRegex.test(message.content)) { message.transferStatus = 'pending'; } 
                    else if (giftRegex.test(message.content)) { message.giftStatus = 'sent'; }
                    chat.history.push(message);
                    addMessageBubble(message);
                });
            } else {
                const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: fullResponse, parts: [{type: 'text', text: fullResponse}], timestamp: Date.now() };
                chat.history.push(simpleMessage);
               await addMessageBubble(simpleMessage);
            }
            character.messageCountSinceLastDiary = (character.messageCountSinceLastDiary || 0) + 1;
            if (character.messageCountSinceLastDiary >= 10 && Math.random() < 0.3) { generateDiaryEntry(); }    
        } else if (currentChatType === 'group') {
            const group = chat;
            const messages = getMixedContent(fullResponse)
            let r = /\[(.*?)((?:的消息|的语音|发送的表情包|发来的照片\/视频))：/
            if (messages.length > 0) {
                messages.forEach(item => {
                    const nameMatch = item.content.match(r);
                    if (nameMatch || item.char) {
                        const senderName = item.char || (nameMatch[1]);
                        const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                        if (sender) {
                            const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: item.content.trim(), parts: [{type: item.type, text: item.content.trim()}], timestamp: Date.now(), senderId: sender.id };
                            group.history.push(message);
                            addMessageBubble(message);
                        }
                    }
                });
            } else {
                console.warn("AI response did not match expected group format, treating as single message:", fullResponse);
                const firstMember = group.members[Math.floor(Math.random() * group.members.length)];
                if (firstMember) {
                    const simpleMessageContent = `[${firstMember.realName}的消息：${fullResponse}]`;
                    const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: simpleMessageContent, parts: [{type: 'text', text: simpleMessageContent}], timestamp: Date.now(), senderId: firstMember.id };
                    group.history.push(simpleMessage);
                   await addMessageBubble(simpleMessage);
                }
            }
        }
        await saveData();
        renderChatList();
        if (momentsWereAdded) {
            if (typeof renderMoments === 'function') { try { await renderMoments(); } catch (e) {} } 
            else if (typeof window.renderMomentsSafe === 'function') { try { await window.renderMomentsSafe(); } catch (e) {} }
        }
    }
    if (isCallRinging && !callActionReceived) {
        showToast('对方无应答');
        endCall('no_action_reply');
    }
}

// ▲▲▲ 替换到这里结束 ▲▲▲
        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">还没有表情包，快去添加吧！</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('转账给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('请输入有效的金额');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

        async function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '已收款' : '已退回';
                    cardOnScreen.style.cursor = 'default';
                }
                let contextMessageContent = (action === 'received') ? `[${character.myName}接收${character.realName}的转账]` : `[${character.myName}退回${character.realName}的转账]`;
                const contextMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{type: 'text', text: contextMessageContent}],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                await saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

        function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('送礼物给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyGift(giftDescriptionInput.value.trim());
            });
        }

        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('新字体已应用！');
            });
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                showToast('已恢复默认字体！');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                if (!name || !content) return showToast('名称和内容不能为空');
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        book.name = name;
                        book.content = content;
                        book.position = position;
                    }
                } else {
                    db.worldBooks.push({id: `wb_${Date.now()}`, name, content, position});
                }
                await saveData();
                showToast('世界书条目已保存');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '删除',
                        danger: true,
                        action: async () => {
                            if (confirm('确定要删除这个世界书条目吗？')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => {
                                    char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                                });
                                db.groups.forEach(group => {
                                    group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                                });
                                await saveData();
                                renderWorldBookList();
                                showToast('条目已删除');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                
                // 插入：右侧删除世界书按钮（由 ChatGPT 添加）
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.style.position = 'absolute';
                delBtn.style.right = '8px';
                delBtn.style.top = '50%';
                delBtn.style.transform = 'translateY(-50%)';
                delBtn.style.padding = '6px';
                delBtn.style.border = 'none';
                delBtn.style.background = 'transparent';
                delBtn.title = '删除世界书';
                const delImg = document.createElement('img');
                delImg.src = 'https://i.postimg.cc/hGW6B0Wf/icons8-50.png';
                delImg.alt = '删除';
                delImg.style.width = '22px';
                delImg.style.height = '22px';
                delImg.style.objectFit = 'contain';
                delBtn.appendChild(delImg);
                delBtn.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('确定要删除这个世界书条目吗？')) return;
                    try {
                        if (typeof deleteWorldBookById === 'function') {
                            await deleteWorldBookById(book.id);
                        } else if (typeof deleteWorldBook === 'function') {
                            await deleteWorldBook(book.id);
                        } else {
                            // Try in-place removal as fallback
                            db.worldBooks = db.worldBooks.filter(wb => wb.id !== book.id);
                            if (typeof saveData === 'function') await saveData();
                        }
                        // 刷新列表视图
                        if (typeof renderWorldBookList === 'function') renderWorldBookList();
                        showToast && showToast('世界书已删除');
                    } catch (err) {
                        console.error('删除世界书出错', err);
                        alert('删除失败，请查看控制台');
                    }
                });
                // 将按钮附加到 li（li 用 position: relative 保证按钮在右侧）
                li.style.position = 'relative';
                li.appendChild(delBtn);
worldBookListContainer.appendChild(li);
            });
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
                privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, {
                                quality: 0.85,
                                maxWidth: 1080,
                                maxHeight: 1920
                            });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        } catch (error) {
                            showToast('背景压缩失败，请重试');
                        }
                    }
                }
            });
            clearChatHistoryBtn.addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                if (confirm(`你确定要清空与“${character.remarkName}”的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    character.history = [];
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    settingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空');
                }
            });
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', async () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                await saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('世界书关联已更新');
            });
        }

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                    customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                    privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
            }
        }

        async function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = document.getElementById('setting-theme-color').value;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
                await saveData();
                showToast('设置已保存！');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }

        // (请找到文件中的旧 setupApiSettingsApp 函数，并用下面的代码完整替换它)

function setupApiSettingsApp() {
    const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
        a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
        r = document.getElementById('api-url'), s = document.getElementById('api-key'), 
        theaterCheckbox = document.getElementById('force-html-theater'),
        offlineModeCheckbox = document.getElementById('offline-mode-toggle'), // 新增：获取线下模式开关
autoPostMomentsCheckbox = document.getElementById('auto-post-moments'), // ▼▼▼【新增】获取自动动态开关
// ▼▼▼ 3.1 获取主动消息相关的控件 ▼▼▼
        proactiveMessagingCheckbox = document.getElementById('proactive-messaging-enabled'),
        proactiveHoursInput = document.getElementById('proactive-messaging-hours'),
        // ▲▲▲ 代码结束 ▲▲▲
        c = {
            newapi: '',
            deepseek: 'https://api.deepseek.com',
            claude: 'https://api.anthropic.com',
            gemini: 'https://generativelanguage.googleapis.com'
        };

    if (db.apiSettings) { // 加载已有设置
        n.value = db.apiSettings.provider || 'newapi';
        r.value = db.apiSettings.url || '';
        s.value = db.apiSettings.key || '';
        if (db.apiSettings.model) {
            a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`;
        }
        theaterCheckbox.checked = !!db.apiSettings.forceHtmlTheater;
        offlineModeCheckbox.checked = !!db.apiSettings.offlineModeEnabled; // 新增：加载线下模式开关状态
autoPostMomentsCheckbox.checked = !!db.apiSettings.autoPostMomentsEnabled; // ▼▼▼【新增】加载自动动态开关状态
// ▼▼▼ 3.2 加载主动消息设置状态 ▼▼▼
        proactiveMessagingCheckbox.checked = !!db.apiSettings.proactiveMessagingEnabled;
        proactiveHoursInput.value = db.apiSettings.proactiveMessagingHours || 5;
        // ▲▲▲ 代码结束 ▲▲▲
    }

    n.addEventListener('change', () => {
        r.value = c[n.value] || ''
    });
    
    t.addEventListener('click', async () => {
        let o = r.value.trim();
        const l = s.value.trim();
        if (!o || !l) return showToast('请先填写API地址和密钥！');
        o.endsWith('/') && (o = o.slice(0, -1));
        const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
        t.classList.add('loading'), t.disabled = !0;
        try {
            const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                g = await fetch(i, {method: 'GET', headers: d});
            if (!g.ok) throw new Error(`网络响应错误: ${g.status}`);
            const u = await g.json();
            let p = [];
            'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                const t = document.createElement('option');
                t.value = e, t.textContent = e, a.appendChild(t)
            }) : a.innerHTML = '<option value="">未找到任何模型</option>', showToast('模型列表拉取成功！')
        } catch (f) {
            showToast(`拉取失败: ${f.message}`), a.innerHTML = '<option value="">拉取失败</option>'
        } finally {
            t.classList.remove('loading'), t.disabled = !1
        }
    });
    
    e.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!a.value) return showToast('请选择模型后保存！');
        const banApi = URLBlacklist.some((api)=>{
            return r.value.indexOf(api) !== -1
        })
        if(banApi){
            alert('此API网址已加入黑名单，请勿使用')
            return
        }
        // 保存所有设置，包括新的开关状态
        db.apiSettings = {
            provider: n.value, 
            url: r.value, 
            key: s.value, 
            model: a.value,
            forceHtmlTheater: theaterCheckbox.checked,
            offlineModeEnabled: offlineModeCheckbox.checked, // 新增：保存线下模式开关状态
            autoPostMomentsEnabled: autoPostMomentsCheckbox.checked
, // <--- 确保这里有个逗号
            // ▼▼▼ 3.3 保存主动消息设置 ▼▼▼
            proactiveMessagingEnabled: proactiveMessagingCheckbox.checked,
           proactiveMessagingHours: parseFloat(proactiveHoursInput.value) || 5
            // ▲▲▲ 代码结束 ▲▲▲
        };

        await saveData();
        showToast('API设置已保存！')
    })
}


        function setupWallpaperApp() {
            const e = document.getElementById('wallpaper-upload'), t = document.getElementById('wallpaper-preview');
            t.style.backgroundImage = `url(${db.wallpaper})`, t.textContent = '', e.addEventListener('change', async (a) => {
                const n = a.target.files[0];
                if (n) {
                    try {
                        const r = await compressImage(n, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = r, applyWallpaper(r), t.style.backgroundImage = `url(${r})`;
                        await saveData();
                        showToast('壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });
        }
            // (在 setupWallpaperApp 函数之后添加下面所有的代码)

    function renderMyStickers() {
        if (!stickerGridContainer) return; // 安全检查
        
        stickerGridContainer.innerHTML = '';
        if (db.myStickers.length === 0) {
            stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center; grid-column: 1 / -1;">还没有表情哦，快去添加吧！</p>';
            return;
        }

        db.myStickers.forEach(sticker => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.dataset.id = sticker.id;
            item.innerHTML = `<img src="${sticker.url}" alt="${sticker.name}"><span>${sticker.name}</span>`;
            
            // 为每个表情项添加长按/右键菜单事件
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                currentStickerActionTarget = sticker.id;
                stickerActionSheet.classList.add('visible');
            });
            item.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    currentStickerActionTarget = sticker.id;
                    stickerActionSheet.classList.add('visible');
                }, 500);
            });
            item.addEventListener('touchend', () => clearTimeout(longPressTimer));
            item.addEventListener('touchmove', () => clearTimeout(longPressTimer));

            stickerGridContainer.appendChild(item);
        });
    }

function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }


   
        // --- GROUP CHAT FUNCTIONS ---
        // --- DIARY SYSTEM FUNCTIONS ---

// 用于生成日记的 AI 调用函数
async function generateDiaryEntry(isManual = false) {
    if (isGenerating) {
        showToast('AI正在思考中，请稍等...');
        return;
    }
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    if (isManual) {
        showToast('正在为您撰写日记...');
    }

    isGenerating = true;
    typingIndicator.textContent = `${character.remarkName} 正在奋笔疾书...`;
    typingIndicator.style.display = 'block';

    try {
        const memory = character.history.slice(-character.maxMemory);
        const worldBooks = db.worldBooks.filter(wb => (character.worldBookIds || []).includes(wb.id));
        
        let context = `角色设定:\n你叫${character.remarkName}（真名：${character.realName}），你的人设是：${character.persona}\n`;
        context += `用户设定:\n我的名字是${character.myName}，我的人设是：${character.myPersona}\n`;

        const beforeWorldBooks = worldBooks.filter(wb => wb.position === 'before').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        const afterWorldBooks = worldBooks.filter(wb => wb.position === 'after').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        if (beforeWorldBooks) context = `${beforeWorldBooks}\n\n${context}`;
        if (afterWorldBooks) context += `\n\n${afterWorldBooks}`;

        let historyText = memory.map(msg => {
            const sender = msg.role === 'user' ? character.myName : character.remarkName;
            const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
            const cleanContent = contentMatch ? contentMatch[1] : msg.content;
            return `${sender}: ${cleanContent}`;
        }).join('\n');
        
        const prompt = `${context}\n\n请你严格扮演 ${character.remarkName}，根据我们最近的对话，用你的第一人称视角写一篇大约300字的日记。日记需要深刻体现你的性格和人设，可以包含对我们关系的思考、你的秘密情感或计划。如果符合你的人设，日记内容可以包含NSFW元素。请直接输出日记正文，不要包含“好的，这是日记：”等多余的话。\n\n最近的对话如下:\n${historyText}`;

        let messagesForApi;
        const { provider } = db.apiSettings; 

        if (provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        
        await saveDiaryEntry(aiResponseText);
        
        showToast('一篇新的日记已经写好了！');
        
        if (document.getElementById('diary-screen').classList.contains('active')) {
            renderDiaries();
        }

    } catch (error) {
        console.error('日记生成失败:', error);
        showToast(`日记生成失败: ${error.message}`);
    } finally {
        isGenerating = false;
        typingIndicator.textContent = '';
        typingIndicator.style.display = 'none';
        if (!isManual) {
             character.messageCountSinceLastDiary = 0;
             await saveData();
        }
    }
}

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
async function saveDiaryEntry(content) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    // 确保 diaries 数组存在
    if (!Array.isArray(character.diaries)) {
        character.diaries = [];
    }

    const newDiary = {
        id: `diary_${Date.now()}`,
        timestamp: Date.now(),
        content: content.trim(),
        isFavorited: false
    };

    character.diaries.push(newDiary);
    
    // --- 新版逻辑：当未收藏日记达到第6篇时，清空前5篇 ---
    
    // 1. 将日记分为“已收藏”和“未收藏”两组
    const favoritedDiaries = character.diaries.filter(d => d.isFavorited);
    let unfavoritedDiaries = character.diaries.filter(d => !d.isFavorited);

    // 2. 检查“未收藏”的日记数量是否正好达到了6篇
    if (unfavoritedDiaries.length === 6) {
        // 3. 如果是，则按时间排序以确保新生成的日记在最后
        unfavoritedDiaries.sort((a, b) => a.timestamp - b.timestamp);
        
        // 4. 只保留数组中的最后一个元素（即刚刚新生成的第6篇），从而删除前5篇
        unfavoritedDiaries = unfavoritedDiaries.slice(-1);
    }

    // 5. 将“已收藏”和“处理后保留的未收藏”合并，形成最终的日记列表
    character.diaries = [...favoritedDiaries, ...unfavoritedDiaries];

    // --- 新版逻辑结束 ---
    
    // 重置消息计数
    character.messageCountSinceLastDiary = 0;
    
    await saveData();
}

// 渲染日记列表
function renderDiaries() {
    const character = db.characters.find(c => c.id === currentChatId);
    const container = document.getElementById('diary-list-container');
    const placeholder = document.getElementById('no-diaries-placeholder');
    
    if (!character || !character.diaries || character.diaries.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
    
    sortedDiaries.forEach(diary => {
        const li = document.createElement('li');
        li.className = 'diary-entry';
        li.dataset.id = diary.id;
        
        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${dateString}</span>
                <div class="diary-actions">
                    <button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="收藏">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>
                    <button class="delete-diary-btn" title="删除">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>
            </div>
            <div class="diary-content">${diary.content}</div>
        `;
        container.appendChild(li);
    });
}

// 打开日记屏幕
function openDiaryScreen() {
    if (!currentChatId || currentChatType !== 'private') return;
    renderDiaries();
    switchScreen('diary-screen');
}

// 设置所有与日记相关的事件监听
function setupDiarySystem() {
    document.getElementById('diary-btn').addEventListener('click', openDiaryScreen);
    document.getElementById('generate-diary-manually-btn').addEventListener('click', () => generateDiaryEntry(true));

    document.getElementById('diary-list-container').addEventListener('click', async (e) => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const diaryId = e.target.closest('.diary-entry')?.dataset.id;
        if (!diaryId) return;

        const diaryIndex = character.diaries.findIndex(d => d.id === diaryId);
        if (diaryIndex === -1) return;

        if (e.target.closest('.favorite-diary-btn')) {
            character.diaries[diaryIndex].isFavorited = !character.diaries[diaryIndex].isFavorited;
            await saveData();
            e.target.closest('.favorite-diary-btn').classList.toggle('favorited');
            showToast(character.diaries[diaryIndex].isFavorited ? '已收藏' : '已取消收藏');
        }

        if (e.target.closest('.delete-diary-btn')) {
            if (confirm('确定要删除这篇日记吗？')) {
                character.diaries.splice(diaryIndex, 1);
                await saveData();
                e.target.closest('.diary-entry').remove();
                showToast('日记已删除');
                if (character.diaries.length === 0) {
                     document.getElementById('no-diaries-placeholder').style.display = 'block';
                }
            }
        }
    });
}
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('请至少选择一个群成员。');
                if (!groupName) return showToast('请输入群聊名称。');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : '我',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    },
                    members: selectedMemberIds.map(charId => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    worldBookIds: []
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`群聊“${groupName}”创建成功！`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('群头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        }
                    } catch (error) {
                        showToast('群聊背景压缩失败，请重试');
                    }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`你确定要清空群聊“${group.name}”的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    group.history = [];
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    groupSettingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空');
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('成员头像压缩失败，请重试');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('成员信息已更新');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('新成员头像压缩失败，请重试');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('已邀请新成员');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`新成员 ${newMember.groupNickname} 已加入`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('请至少选择一个收件人。');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');

            bubbleScaleRange.addEventListener('input', () => {
                const scaleValue = bubbleScaleRange.value;
                bubbleScaleValue.textContent = `${Math.round(scaleValue * 100)}%`;
                chatRoomScreen.style.setProperty('--bubble-scale', scaleValue);
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');
            
            // 初始化滑块和显示的值
            const currentScale = group.bubbleScale || 1;
            bubbleScaleRange.value = currentScale;
            bubbleScaleValue.textContent = `${Math.round(currentScale * 100)}%`;
            chatRoomScreen.style.setProperty('--bubble-scale', currentScale);
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>添加</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        async function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = document.getElementById('setting-group-theme-color').value;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            await saveData();
            showToast('群聊设置已保存！');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
            group.bubbleScale = document.getElementById('bubble-scale-range').value;

            await saveData();
            showToast('群聊设置已保存！');
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可邀请的新成员了。</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}邀请${newMemberRealName}加入了群聊]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}修改群名为：${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }
// --- 在脚本末尾，init() 调用之前，添加以下所有函数 ---

async function generateDiaryEntry(isManual = false) {
    if (isGenerating) {
        showToast('AI正在思考中，请稍等...');
        return;
    }
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    if (isManual) {
        showToast('正在为您撰写日记...');
    }

    isGenerating = true;
    typingIndicator.textContent = `${character.remarkName} 正在奋笔疾书...`;
    typingIndicator.style.display = 'block';

    try {
        const memory = character.history.slice(-character.maxMemory);
        const worldBooks = db.worldBooks.filter(wb => (character.worldBookIds || []).includes(wb.id));
        
        let context = `角色设定:\n你叫${character.remarkName}（真名：${character.realName}），你的人设是：${character.persona}\n`;
        context += `用户设定:\n我的名字是${character.myName}，我的人设是：${character.myPersona}\n`;

        const beforeWorldBooks = worldBooks.filter(wb => wb.position === 'before').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        const afterWorldBooks = worldBooks.filter(wb => wb.position === 'after').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        if (beforeWorldBooks) context = `${beforeWorldBooks}\n\n${context}`;
        if (afterWorldBooks) context += `\n\n${afterWorldBooks}`;

        let historyText = memory.map(msg => {
            const sender = msg.role === 'user' ? character.myName : character.remarkName;
            const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
            const cleanContent = contentMatch ? contentMatch[1] : msg.content;
            return `${sender}: ${cleanContent}`;
        }).join('\n');
        
        const prompt = `${context}\n\n请你严格扮演 ${character.remarkName}，根据我们最近的对话，用你的第一人称视角写一篇大约300字的日记。日记需要深刻体现你的性格和人设，可以包含对我们关系的思考、你的秘密情感或计划。如果符合你的人设，日记内容可以包含NSFW元素。请直接输出日记正文，不要包含“好的，这是日记：”等多余的话。\n\n最近的对话如下:\n${historyText}`;

        // --- 这是关键的修改部分 ---
        let messagesForApi;
        const { provider } = db.apiSettings; // 获取当前选择的服务商

        if (provider === 'gemini') {
            // 如果是 Gemini，创建 'parts' 格式
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            // 如果是其他服务商，创建 'content' 格式
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        // --- 修改结束 ---
        
        const aiResponseText = await callAiApi(messagesForApi);
        
        await saveDiaryEntry(aiResponseText);
        
        showToast('一篇新的日记已经写好了！');
        
        if (document.getElementById('diary-screen').classList.contains('active')) {
            renderDiaries();
        }

    } catch (error) {
        console.error('日记生成失败:', error);
        showToast(`日记生成失败: ${error.message}`);
    } finally {
        isGenerating = false;
        typingIndicator.textContent = '';
        typingIndicator.style.display = 'none';
        if (!isManual) {
             character.messageCountSinceLastDiary = 0;
             await saveData();
        }
    }
}
// 渲染日记列表
function renderDiaries() {
    const character = db.characters.find(c => c.id === currentChatId);
    const container = document.getElementById('diary-list-container');
    const placeholder = document.getElementById('no-diaries-placeholder');
    
    if (!character || !character.diaries || character.diaries.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
    
    sortedDiaries.forEach(diary => {
        const li = document.createElement('li');
        li.className = 'diary-entry';
        li.dataset.id = diary.id;
        
        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${dateString}</span>
                <div class="diary-actions">
                    <button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="收藏">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>
                    <button class="delete-diary-btn" title="删除">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>
            </div>
            <div class="diary-content">${diary.content}</div>
        `;
        container.appendChild(li);
    });
}

// 打开日记屏幕
function openDiaryScreen() {
    if (!currentChatId || currentChatType !== 'private') return;
    renderDiaries();
    switchScreen('diary-screen');
}

// 设置所有与日记相关的事件监听
function setupDiarySystem() {
    document.getElementById('diary-btn').addEventListener('click', openDiaryScreen);
    document.getElementById('generate-diary-manually-btn').addEventListener('click', () => generateDiaryEntry(true));

    document.getElementById('diary-list-container').addEventListener('click', async (e) => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const diaryId = e.target.closest('.diary-entry')?.dataset.id;
        if (!diaryId) return;

        const diaryIndex = character.diaries.findIndex(d => d.id === diaryId);
        if (diaryIndex === -1) return;

        // 收藏按钮
        if (e.target.closest('.favorite-diary-btn')) {
            character.diaries[diaryIndex].isFavorited = !character.diaries[diaryIndex].isFavorited;
            await saveData();
            e.target.closest('.favorite-diary-btn').classList.toggle('favorited');
            showToast(character.diaries[diaryIndex].isFavorited ? '已收藏' : '已取消收藏');
        }

        // 删除按钮
        if (e.target.closest('.delete-diary-btn')) {
            if (confirm('确定要删除这篇日记吗？')) {
                character.diaries.splice(diaryIndex, 1);
                await saveData();
                e.target.closest('.diary-entry').remove();
                showToast('日记已删除');
                if (character.diaries.length === 0) {
                     document.getElementById('no-diaries-placeholder').style.display = 'block';
                }
            }
        }
    });

    // 小修改：将 AI 核心调用逻辑从 getAiReply 中分离出来
    // 请找到 getAiReply 函数，将其修改成下面的样子：
    // 首先在 getAiReply 函数上面添加一个新的 callAiApi 函数


// ▼▼▼ 4A. 一个全新的函数，用于让AI主动发送消息 ▼▼▼
async function getProactiveAiMessage(character) {
    if (isGenerating) return;

    const { url, key, model } = db.apiSettings;
    if (!url || !key || !model) return;

    isGenerating = true;
    getReplyBtn.disabled = true;
    typingIndicator.textContent = `“${character.remarkName}”正在输入中...`;
    typingIndicator.style.display = 'block';
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        const now = new Date();
        const currentTime = `${now.getHours()}:${pad(now.getMinutes())}`;
        let prompt = `你正在扮演 ${character.realName}。你的人设是：${character.persona}。\n`;
        prompt += `你现在需要主动给 ${character.myName} (我) 发送一条消息，因为你之前发的消息已经过去了超过 ${db.apiSettings.proactiveMessagingHours} 小时，但我一直没有回复你。\n`;
        prompt += `现在是${currentTime}。请根据当前的时间、你的人设以及你们之前的对话基调，自然地开启一个新的话题或打个招呼，尝试让我回应。\n`;
        prompt += `重要规则：你的回复必须且只能严格遵循格式：[${character.realName}的消息：{你的消息内容}]。只回复一条消息，不要有任何多余的解释。`;

        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);

        if (aiResponseText) {
            const newMessage = {
                id: `msg_proactive_${Date.now()}`,
                role: 'assistant',
                content: aiResponseText.trim(),
                parts: [{ type: 'text', text: aiResponseText.trim() }],
                timestamp: Date.now(),
            };
            character.history.push(newMessage);
            await saveData();
            
            if (currentChatId === character.id) {
                addMessageBubble(newMessage);
                renderChatList();
            }
        }
    } catch (error) {
        console.error('获取主动消息失败:', error);
    } finally {
        isGenerating = false;
        if (currentChatId === character.id) {
            getReplyBtn.disabled = false;
            typingIndicator.style.display = 'none';
        }
    }
}
// ▲▲▲ 新增函数结束 ▲▲▲
    async function callAiApi(messages) {
        const { provider, url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            throw new Error('API设置不完整');
        }

        let apiUrl = url;
        if (provider === 'newapi' && !url.endsWith('/v1/chat/completions')) {
            apiUrl = `${url}/v1/chat/completions`;
        }

        const body = {
            model,
            messages,
            stream: false
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getRandomValue(key)}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    }

    // 然后修改 getAiReply 函数，让它调用新的 callAiApi 函数
    async function getAiReply() {
        if (isGenerating) {
            showToast('AI正在思考中，请稍等...');
            return;
        }

        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        isGenerating = true;
        typingIndicator.textContent = '对方正在输入...';
        typingIndicator.style.display = 'block';
        getReplyBtn.disabled = true;

        try {
            const messagesForApi = await buildApiMessages(chat);
            const aiResponseText = await callAiApi(messagesForApi);
            await processAndSaveAiResponse(aiResponseText, chat);
        } catch (error) {
            console.error('AI回复失败:', error);
            showToast(`请求失败: ${error.message}`);
        } finally {
            isGenerating = false;
            typingIndicator.style.display = 'none';
            getReplyBtn.disabled = false;
        }
    }
}
// --- NEW: Voice Call System Functions ---

function setupVoiceCallSystem() {
    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', endCall);
    declineCallBtn.addEventListener('click', () => {
         endCall('declined');
    });
    acceptCallBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
         // Add a system message for AI context that user accepted the call
        const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} 接听了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 接听了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', endCall);
    sendCallMessageBtn.addEventListener('click', sendCallMessage);
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    // 设置响铃状态并启动超时计时器
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); // 60秒超时

    // 添加系统消息以触发AI决策
    const callMessage = {
        id: `msg_call_${Date.now()}`,
        role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // 触发AI响应
}

function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // --- 核心修改：显示主头像，隐藏顶部面板 ---
    // 保持主界面的大型头像和名字可见，以匹配图片样式
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    // 隐藏那个固定的、现在不需要的顶部 header
    const activeHeader = document.getElementById('active-call-header');
    if (activeHeader) activeHeader.style.display = 'none';
    // --- 修改结束 ---

    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';

    // 更新顶部固定面板的信息（这些代码现在无效，但保留也无妨）
    document.getElementById('active-call-header-avatar').src = character.avatar;
    document.getElementById('active-call-header-name').textContent = character.remarkName;
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        
        // 修改：确保只更新主状态区的计时器
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;

    const character = db.characters.find(c => c.id === currentCallTargetId);

    if (isVoiceCallActive && reason === 'ended' && character) {
        const hangupContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user', 
            content: `[system: ${character.myName} 挂断了电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 挂断了电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(hangupContext);
    }

    // 如果通话从未被激活（即仍在响铃阶段），并且是因为 'ended', 'timeout', 'error', 或 'no_action_reply' 而结束，则直接关闭界面
    if (!isVoiceCallActive && (reason === 'ended' || reason === 'timeout' || reason === 'error' || reason === 'no_action_reply')) {
         voiceCallOverlay.classList.remove('visible');
         document.getElementById('call-avatar').style.display = 'block';
         document.getElementById('call-name').style.display = 'block';
         return;
    }

    if (!character) {
         voiceCallOverlay.classList.remove('visible');
         return;
    }

    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    if (reason === 'declined') {
         const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} 拒绝了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 拒绝了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
    } else if (isVoiceCallActive) { 
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`,
            role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [],
            timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    }
    
    await saveData();
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    voiceCallOverlay.classList.remove('visible');
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        // 修改后的 Prompt，明确指示 AI 可以用换行符来发送多条消息
        const prompt = `你正在与 ${character.myName} 进行语音通话。你的名字是 ${character.realName}，你的人设是：${character.persona}。你的回复可以直接是对话内容，也可以包含用括号()描述的动作、语气或环境。重要：如果想连续发送多条消息，请用换行符分隔，并且每条消息不得超过50字，每一行都会成为一个独立的气泡。请严格保持你的人设进行对话。`;

        const callHistory = voiceCallTranscript.map(line => {
            return {
                role: line.sender === 'user' ? 'user' : 'assistant',
                content: line.text
            }
        });

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // 使用最近5轮的通话记录作为上下文
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // 复用通用的AI调用函数

        // 处理AI回复，按换行符拆分成多条消息
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // 可以根据消息长度添加一个小的延迟，模拟打字效果
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        appendCallTranscript("system", `[错误: ${error.message}]`);
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    // sender: 'user', 'ai', or 'system'
    voiceCallTranscript.push({ sender, text });

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        // Simple regex to style actions in parenthesis
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}
// 在 init() 函数之前添加以下三个函数

function addNotificationToQueue(notification) {
    // 模拟一个随机延迟（1到5秒），让通知看起来更自然
    const delay = Math.random() * 4000 + 1000;
    setTimeout(() => {
        notificationQueue.push(notification);
    }, delay);
}

function showNotificationBanner() {
    if (isNotificationShowing || notificationQueue.length === 0) {
        return;
    }

    // 不在动态页显示通知
    const momentsScreen = document.getElementById('moments-screen');
    if (momentsScreen && momentsScreen.classList.contains('active')) {
        return;
    }

    isNotificationShowing = true;
    const notification = notificationQueue.shift();
    
    const banner = document.getElementById('global-notification-banner');
    const avatar = document.getElementById('notification-avatar');
    const textEl = document.getElementById('notification-text');

    avatar.src = notification.avatar;
    textEl.innerHTML = notification.text; // 使用innerHTML以支持简单的HTML标签

    banner.classList.add('show');
    
    // 点击横幅跳转到动态页面
    banner.onclick = () => {
        switchScreen('moments-screen');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500); // 检查队列中是否还有下一条
    };

    // 5秒后自动隐藏
    setTimeout(() => {
        banner.classList.remove('show');
        isNotificationShowing = false;
        // 检查队列中是否还有下一条
        setTimeout(showNotificationBanner, 500);
    }, 5000);
}

function setupNotificationSystem() {
    // 定时检查通知队列
    setInterval(showNotificationBanner, 2000); // 每2秒检查一次

    // 关闭按钮
    const closeBtn = document.getElementById('notification-close-btn');
    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 防止触发横幅的点击事件
        const banner = document.getElementById('global-notification-banner');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    });
}
// 在 init() 函数之前添加


        init();
    });
</script>




<!-- === ChatGPT 插入：气泡预设脚本 === -->
<script>
(function(){
  if (window._bubblePresetsScriptLoaded) return;
  window._bubblePresetsScriptLoaded = true;

  // localStorage key
  const PRES_KEY = 'bubblePresets';

  function _getBubblePresets() {
    try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
    catch(e){ return []; }
  }
  function _saveBubblePresets(arr) {
    localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
  }

  function populateBubblePresetSelect() {
    const sel = document.getElementById('bubble-preset-select');
    if (!sel) return;
    const presets = _getBubblePresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }
function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}
  async function applyPresetToCurrentChat(presetName) {
    const presets = _getBubblePresets();
    const preset = presets.find(p => p.name === presetName);
    if (!preset) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }
    // 更新界面 textarea
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (textarea) textarea.value = preset.css;

    // 尝试找到当前 chat 对象并写入。如果没有现成的 db 对象，仅更新 preview 和 textarea。
    try {
      if (typeof currentChatId !== 'undefined' && typeof currentChatType !== 'undefined' && window.db) {
        const chat = (currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null);
        if (chat) {
          chat.customBubbleCss = preset.css;
          chat.useCustomBubbleCss = true;
        }
      }
    } catch(e){
      console.warn('applyPresetToCurrentChat: cannot write to db object', e);
    }

    // 更新页面样式预览：优先使用已有的 updateBubbleCssPreview 或 updateCustomBubbleStyle
    try {
      if (typeof updateCustomBubbleStyle === 'function') {
        try { updateCustomBubbleStyle(window.currentChatId || null, preset.css, true); } catch(e){ /* ignore */ }
      }
      const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
      if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, preset.css, false);
      (window.showToast && showToast('预设已应用到当前聊天并保存')) || alert('预设已应用（若页面支持）');
      if (typeof saveData === 'function') {
        try { await saveData(); } catch(e){ /* ignore */ }
      }
    } catch(e){
      console.error('applyPresetToCurrentChat error', e);
    }
  }

  function saveCurrentTextareaAsPreset() {
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (!textarea) return (window.showToast && showToast('找不到自定义 CSS 文本框')) || alert('找不到自定义 CSS 文本框');
    const css = textarea.value.trim();
    if (!css) return (window.showToast && showToast('当前 CSS 为空，无法保存')) || alert('当前 CSS 为空，无法保存');
    let name = prompt('请输入预设名称（将覆盖同名预设）:');
    if (!name) return;
    const presets = _getBubblePresets();
    const idx = presets.findIndex(p => p.name === name);
    if (idx >= 0) presets[idx].css = css;
    else presets.push({name, css});
    _saveBubblePresets(presets);
    populateBubblePresetSelect();
    (window.showToast && showToast('预设已保存')) || alert('预设已保存');
  }

  function openManagePresetsModal() {
    const modal = document.getElementById('bubble-presets-modal');
    const list = document.getElementById('bubble-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getBubblePresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const presetsAll = _getBubblePresets();
        presetsAll[idx].name = newName;
        _saveBubblePresets(presetsAll);
        openManagePresetsModal(); // refresh
        populateBubblePresetSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-danger';
      delBtn.style.padding = '6px 8px;border-radius:8px';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){
        if (!confirm('确定删除预设 \"' + p.name + '\" ?')) return;
        const presetsAll = _getBubblePresets();
        presetsAll.splice(idx, 1);
        _saveBubblePresets(presetsAll);
        openManagePresetsModal();
        populateBubblePresetSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(delBtn);
      row.appendChild(btnWrap);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  function bindBubblePresetUI() {
    populateBubblePresetSelect();
    const sel = document.getElementById('bubble-preset-select');
    const applyBtn = document.getElementById('apply-preset-btn');
    const saveBtn = document.getElementById('save-preset-btn');
    const manageBtn = document.getElementById('manage-presets-btn');
    const modalClose = document.getElementById('close-presets-modal');

    if (sel) {
      sel.addEventListener('change', (e) => {
        const val = e.target.value;
        const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
        if (!val) {
          // restore preview from current chat theme or textarea
          try {
            const chat = (typeof currentChatType !== 'undefined' && typeof currentChatId !== 'undefined' && window.db) ? ((currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null)) : null;
            const baseCss = (chat && chat.customBubbleCss) ? chat.customBubbleCss : (document.getElementById('setting-custom-bubble-css') ? document.getElementById('setting-custom-bubble-css').value : '');
            if (previewBox && typeof updateBubbleCssPreview === 'function') {
              updateBubbleCssPreview(previewBox, baseCss, !chat || !chat.useCustomBubbleCss);
            }
          } catch(e){ /* ignore */ }
          return;
        }
        const presets = _getBubblePresets();
        const p = presets.find(x => x.name === val);
        if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, p ? p.css : '', false);
      });
    }
    if (applyBtn) applyBtn.addEventListener('click', () => {
      const selVal = document.getElementById('bubble-preset-select').value;
      if (!selVal) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设');
      applyPresetToCurrentChat(selVal);
    });
    if (saveBtn) saveBtn.addEventListener('click', saveCurrentTextareaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManagePresetsModal);
    if (modalClose) modalClose.addEventListener('click', () => {
      document.getElementById('bubble-presets-modal').style.display = 'none';
    });
  }

  // 初始化绑定
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } });
  } else {
    setTimeout(() => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } }, 50);
  }
})();
</script>
<!-- === /ChatGPT 插入：气泡预设脚本 === -->





<!-- === ChatGPT 插入：API 预设脚本 === -->
<script>
(function(){
  if (window._apiPresetsScriptLoaded) return;
  window._apiPresetsScriptLoaded = true;

  function _getApiPresets() {
    try { return JSON.parse(localStorage.getItem('apiPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveApiPresets(arr) {
    localStorage.setItem('apiPresets', JSON.stringify(arr || []));
  }

  function populateApiSelect() {
    const sel = document.getElementById('api-preset-select');
    if (!sel) return;
    const presets = _getApiPresets();
    sel.innerHTML = '<option value="">— 选择 API 预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  function saveCurrentApiAsPreset() {
    // Try to gather API settings fields: try to detect common fields like #setting-api-key, #setting-api-url, etc.
    const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
    const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
    const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

    const data = {
      apiKey: apiKeyEl ? apiKeyEl.value : '',
      apiUrl: apiUrlEl ? apiUrlEl.value : '',
      provider: providerEl ? providerEl.value : '',
      // capture whole form as fallback
      raw: {}
    };
    // gather inputs inside same settings container if possible
    const container = apiKeyEl ? apiKeyEl.closest('form,div') : null;
    if (container) {
      const inputs = container.querySelectorAll('input,select,textarea');
      inputs.forEach(i => { try { data.raw[i.name || i.id || i.getAttribute('data-key') || ('f_'+Math.random().toString(36).slice(2))] = i.value; } catch(e){} });
    }
    let name = prompt('为该 API 预设填写名称（会覆盖同名预设）：');
    if (!name) return;
    const presets = _getApiPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = {name: name, data: data};
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveApiPresets(presets);
    populateApiSelect();
    (window.showToast && showToast('API 预设已保存')) || console.log('API 预设已保存');
  }

  async function applyApiPreset(name) {
    const presets = _getApiPresets();
    const p = presets.find(x => x.name === name);
    if (!p) return (window.showToast && showToast('未找到该预设')) || alert('未找到该预设');
    // Try to populate detected fields
    try {
      const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
      const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
      const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

      if (apiKeyEl && p.data && typeof p.data.apiKey !== 'undefined') apiKeyEl.value = p.data.apiKey;
      if (apiUrlEl && p.data && typeof p.data.apiUrl !== 'undefined') apiUrlEl.value = p.data.apiUrl;
      if (providerEl && p.data && typeof p.data.provider !== 'undefined') providerEl.value = p.data.provider;

      // populate raw fields if present
      if (p.data && p.data.raw) {
        for (const k in p.data.raw) {
          try {
            const el = document.querySelector('#'+k+', [name="'+k+'"]');
            if (el) el.value = p.data.raw[k];
          } catch(e){}
        }
      }

      (window.showToast && showToast('已应用 API 预设')) || console.log('已应用 API 预设');
    } catch(e) {
      console.error('applyApiPreset error', e);
    }
  }

  function openApiManageModal() {
    const modal = document.getElementById('api-presets-modal');
    const list = document.getElementById('api-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getApiPresets();
    if (!presets.length) {
      list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    }
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 6px';
      row.style.borderBottom = '1px solid #f6f6f6';

      const left = document.createElement('div');
      left.style.flex = '1';
      left.style.minWidth = '0';
      left.innerHTML = '<div style="font-weight:600;">'+p.name+'</div><div style="font-size:12px;color:#666;margin-top:4px;">' + (p.data && p.data.provider ? ('提供者：'+p.data.provider) : '') + '</div>';

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyApiPreset(p.name); modal.style.display='none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getApiPresets();
        all[idx].name = newName;
        _saveApiPresets(all);
        openApiManageModal();
        populateApiSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){ if(!confirm('确定删除 "'+p.name+'" ?')) return; const all=_getApiPresets(); all.splice(idx,1); _saveApiPresets(all); openApiManageModal(); populateApiSelect(); };

      btns.appendChild(applyBtn); btns.appendChild(renameBtn); btns.appendChild(delBtn);

      row.appendChild(left); row.appendChild(btns);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  // export / import handlers
  function exportApiPresets() {
    const presets = _getApiPresets();
    const blob = new Blob([JSON.stringify(presets, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'api_presets.json'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  function importApiPresets() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'application/json';
    inp.onchange = function(e){
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = function(){ try { const data = JSON.parse(r.result); if (Array.isArray(data)) { _saveApiPresets(data); populateApiSelect(); openApiManageModal(); } else alert('文件格式不正确'); } catch(e){ alert('导入失败：'+e.message); } };
      r.readAsText(f);
    };
    inp.click();
  }

  // bind UI
  function bind() {
    populateApiSelect();
    const saveBtn = document.getElementById('api-save-preset');
    const manageBtn = document.getElementById('api-manage-presets');
    const applyBtn = document.getElementById('api-apply-preset');
    const select = document.getElementById('api-preset-select');
    const modalClose = document.getElementById('api-close-modal');
    const importBtn = document.getElementById('api-import-presets');
    const exportBtn = document.getElementById('api-export-presets');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentApiAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openApiManageModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v=select.value; if(!v) return (window.showToast&&showToast('请选择预设'))||alert('请选择预设'); applyApiPreset(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('api-presets-modal').style.display='none'; });
    if (importBtn) importBtn.addEventListener('click', importApiPresets);
    if (exportBtn) exportBtn.addEventListener('click', exportApiPresets);

    if (select) select.addEventListener('change', function(){ /* optional: preview selection */ });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();
</script>
<!-- === /ChatGPT 插入：API 预设脚本 === -->


<!-- === ChatGPT 插入脚本：我的人设预设逻辑（放到页面脚本块） === -->
<script>
(function(){
  if (window._myPersonaPresetScriptLoaded) return;
  window._myPersonaPresetScriptLoaded = true;

  // 存取 localStorage
  function _getMyPersonaPresets() {
    try { return JSON.parse(localStorage.getItem('myPersonaPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveMyPersonaPresets(arr) {
    localStorage.setItem('myPersonaPresets', JSON.stringify(arr || []));
  }

  // 填充下拉
  function populateMyPersonaSelect() {
    const sel = document.getElementById('mypersona-preset-select');
    if (!sel) return;
    const presets = _getMyPersonaPresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  // 保存当前侧栏（我的人设 + 我的头像）为预设
  function saveCurrentMyPersonaAsPreset() {
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (!personaEl || !avatarEl) return (window.showToast && showToast('找不到我的人设或头像控件')) || alert('找不到我的人设或头像控件');
    const persona = personaEl.value.trim();
    const avatar = avatarEl.src || '';
    if (!persona && !avatar) return (window.showToast && showToast('人设和头像都为空，无法保存')) || alert('人设和头像都为空，无法保存');
    const name = prompt('请输入预设名称（将覆盖同名预设）：');
    if (!name) return;
    const presets = _getMyPersonaPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = { name, persona, avatar };
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveMyPersonaPresets(presets);
    populateMyPersonaSelect();
    (window.showToast && showToast('我的人设预设已保存')) || console.log('我的人设预设已保存');
  }

  // 将预设应用到当前聊天（同时写 UI + db.characters，并保存）
  async function applyMyPersonaPresetToCurrentChat(presetName) {
    const presets = _getMyPersonaPresets();
    const p = presets.find(x => x.name === presetName);
    if (!p) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }

    // 更新界面
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (personaEl) personaEl.value = p.persona || '';
    if (avatarEl) avatarEl.src = p.avatar || '';

    // 尝试写入当前 chat 对象（与气泡预设做法一致）
    try {
      if (typeof currentChatId !== 'undefined' && window.db && Array.isArray(db.characters)) {
        const e = db.characters.find(c => c.id === currentChatId);
        if (e) {
          e.myPersona = p.persona || '';
          e.myAvatar = p.avatar || '';
          if (typeof saveData === 'function') await saveData();
          (window.showToast && showToast('预设已应用并保存到当前聊天')) || console.log('预设已应用');
          // 刷新侧栏与列表以显示更新
          if (typeof loadSettingsToSidebar === 'function') try{ loadSettingsToSidebar(); }catch(e){}
          if (typeof renderChatList === 'function') try{ renderChatList(); }catch(e){}
        }
      } else {
        (window.showToast && showToast('预设已应用到界面（未检测到当前聊天保存入口）')) || console.log('预设已应用到界面');
      }
    } catch(err) {
      console.error('applyMyPersonaPresetToCurrentChat error', err);
    }
  }

  // 管理 Modal
  function openManageMyPersonaModal() {
    const modal = document.getElementById('mypersona-presets-modal');
    const list = document.getElementById('mypersona-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getMyPersonaPresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';

      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyMyPersonaPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getMyPersonaPresets();
        all[idx].name = newName;
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.style.padding = '6px 8px;border-radius:8px;color:#e53935';
      deleteBtn.textContent = '删除';
      deleteBtn.onclick = function(){
        if (!confirm('确认删除该预设？')) return;
        const all = _getMyPersonaPresets();
        all.splice(idx,1);
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(deleteBtn);
      row.appendChild(btnWrap);

      list.appendChild(row);
    });

    modal.style.display = 'flex';
  }

  // 绑定 UI
  function bind() {
    populateMyPersonaSelect();
    const saveBtn = document.getElementById('mypersona-save-btn');
    const manageBtn = document.getElementById('mypersona-manage-btn');
    const applyBtn = document.getElementById('mypersona-apply-btn');
    const select = document.getElementById('mypersona-preset-select');
    const modalClose = document.getElementById('mypersona-close-modal');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentMyPersonaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManageMyPersonaModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v = select.value; if(!v) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设'); applyMyPersonaPresetToCurrentChat(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('mypersona-presets-modal').style.display='none'; });

    // 页面可能在加载后改变侧栏数据，尝试在 DOMContentLoaded 或已有绑定后初始化
    // 当有其他代码重置 sidebar 时，可手动调用 populateMyPersonaSelect()
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);
  

})();
</script>
<!-- === /我的人设预设脚本 === -->
<!-- ================= Moments 页面（动态） ================= -->
<div class="screen" id="moments-screen" style="display:none;">
  <header class="app-header">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container"><h1 class="title">动态</h1></div>
    <div class="action-btn-group">
      <button class="action-btn" id="moments-delete-btn">删除</button>
      <button class="action-btn" id="open-post-modal">发布</button>
    </div>
  </header>
  <main class="content" id="moments-list">

<!-- === BEGIN ICITY-STYLE USER HEADER SNIPPET (inserted by assistant) === -->
<style>
  /* 尽量隔离命名避免冲突 */
  .icity-moments-wrap { width:100%; margin-bottom: 14px; display:flex; justify-content:center; }
  .icity-moments-inner {
    width: calc(100% - 20px);
    max-width: 760px; /* 自适应手机与桌面 */
    position: relative;
  }

  /* 黑色背景 / 顶图 */
  .icity-hero {
    height: 150px;
    background: #000; /* 默认纯黑 */
    border-radius: 14px 14px 0 0;
    overflow: hidden;
    position: relative;
    background-size: cover; /* 恢复：让图片填满容器 */
    background-position: center; /* 保持：让图片居中显示 */
  }

  /* 白色头像圆（位于 hero 底部居中，部分覆盖下方白卡） */
  .icity-avatar-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -46px; /* 头像会覆盖到下方信息卡 */
    width: 110px;
    height: 110px;
    border-radius: 50%;
    background: #fff; /* 默认头像纯白 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    display:flex;
    align-items:center;
    justify-content:center;
    border: 6px solid rgba(255,255,255,0.9);
  }

  .icity-avatar-wrap img { width:80%; height:80%; border-radius:50%; object-fit:cover; display:block; }

  /* 白色信息卡 */
  .icity-info-card {
    background: #fff;
    border-radius: 14px;
    padding: 64px 18px 18px; /* top padding 留出头像区域 */
    box-shadow: 0 6px 18px rgba(0,0,0,0.04);
    margin-top: 10px;
    box-sizing: border-box;
    text-align: center;
  }

  .icity-name {
    font-size: 22px;
    font-weight: 700;
    color: #111;
    margin: 0;
    line-height: 1;
  }

  .icity-id-loc {
    margin-top: 8px;
    display:flex;
    justify-content:center;
    gap:10px;
    align-items:center;
    font-size:13px;
    color:#888;
  }

  .icity-signature {
    margin-top: 12px;
    color:#666;
    font-size:14px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* 小图标（定位标识） */
  .icity-id-loc .dot {
    width:6px; height:6px; border-radius:50%; background:#ddd; display:inline-block; margin-right:6px;
  }

  /* 响应：小屏时适配 */
  @media (max-width:420px) {
    .icity-avatar-wrap { width:90px; height:90px; bottom:-40px; }
    .icity-info-card { padding-top:56px; }
    .icity-name { font-size:20px; }
  }

/* ---- 多选删除样式（动态页面） ---- */
#moments-screen.is-delete-mode .moment-item { cursor: pointer; user-select: none; }
.moment-item.is-selected { outline: 2px solid var(--accent-color, #4c9ffe); position: relative; }
.moment-item.is-selected::after {
  content: '✓';
  position: absolute; right: 8px; top: 8px;
  width: 22px; height: 22px; line-height: 22px; text-align: center;
  border-radius: 50%;
  background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
}

/* 底部多选操作栏 */
.multi-select-bar {
  position: fixed; left: 0; right: 0; bottom: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px;
  background: #111; color: #fff;
  transform: translateY(100%); transition: transform .25s ease;
  z-index: 250;
}
.multi-select-bar.show { transform: translateY(0%); }
.multi-select-bar .danger { color: #fff; background: #e5484d; border-radius: 10px; padding: 8px 12px; }
.action-btn-group { display: inline-flex; gap: 8px; align-items: center; }
</style>

<div class="icity-moments-wrap" id="icity-moments-wrap">
  <div class="icity-moments-inner" role="region" aria-label="用户动态头部">
    <div class="icity-hero" id="icity-hero"></div>

    <!-- 头像 -->
    <div class="icity-avatar-wrap" id="icity-avatar-wrap" aria-hidden="false">
      <!-- 默认头像：纯白圆（可替换为 dataURL 或真实图片） -->
      <img id="icity-avatar" alt="头像" src="data:image/svg+xml;utf8,
        %3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E
        %3Crect width='100%25' height='100%25' fill='%23ffffff'/%3E
        %3C/svg%3E" />
    </div>

    <!-- 信息白卡 -->
    <div class="icity-info-card">
      <h2 class="icity-name" id="icity-name">Skeleton</h2>

      <div class="icity-id-loc">
        <span class="icity-id">ID：<strong id="icity-id">user</strong></span>
        <span style="opacity:0.4;">·</span>
        <span class="icity-loc"><span class="dot"></span><span id="icity-loc-text">自定义定位</span></span>
      </div>

      <div class="icity-signature" id="icity-signature">把心情写在这里吧♥</div>
    </div>
  </div>
</div>

<script>
  // 初始化默认值（可按需替换为动态数据）
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
      try {
        // 默认文本，遵循你的要求
        const defaults = {
          name: 'Skeleton',
          signature: '把心情写在这里吧♥',
          id: 'user',
          location: '自定义定位',
          avatarSrc: null, // null 使用白色默认图
          heroBg: '#000' // 纯黑背景
        };

        const nameEl = document.getElementById('icity-name');
        const sigEl = document.getElementById('icity-signature');
        const idEl = document.getElementById('icity-id');
        const locEl = document.getElementById('icity-loc-text');
        const avatarEl = document.getElementById('icity-avatar');
        const heroEl = document.getElementById('icity-hero');

        if (nameEl) nameEl.textContent = defaults.name;
        if (sigEl) sigEl.textContent = defaults.signature;
        if (idEl) idEl.textContent = defaults.id;
        if (locEl) locEl.textContent = defaults.location;
        if (heroEl) heroEl.style.background = defaults.heroBg;

        // ---- Profile helpers: load/save/render ----
        window.loadProfileFromStorage = function(){
            return {
                name: localStorage.getItem('myTopName') || defaults.name,
                id: localStorage.getItem('myTopId') || defaults.id,
                location: localStorage.getItem('myTopLoc') || defaults.location,
                signature: localStorage.getItem('myTopSignature') || defaults.signature,
                avatar: localStorage.getItem('myTopAvatar') || (defaults.avatarSrc || ''),
                heroBg: localStorage.getItem('myTopBg') || (defaults.heroBg || '')
            };
        }
        function saveProfileToStorage(profile){
            if(profile.name!=null) localStorage.setItem('myTopName', profile.name);
            if(profile.id!=null) localStorage.setItem('myTopId', profile.id);
            if(profile.location!=null) localStorage.setItem('myTopLoc', profile.location);
            if(profile.signature!=null) localStorage.setItem('myTopSignature', profile.signature);
            if(profile.avatar!=null) localStorage.setItem('myTopAvatar', profile.avatar);
            if(profile.heroBg!=null) localStorage.setItem('myTopBg', profile.heroBg);
        }
        function renderProfileAndSync(){
            const p = loadProfileFromStorage();
            if(nameEl) nameEl.textContent = p.name;
            if(sigEl) sigEl.textContent = p.signature;
            if(idEl) idEl.textContent = p.id;
            if(locEl) locEl.textContent = p.location;
            if(avatarEl){
                if(p.avatar) avatarEl.src = p.avatar;
                // also update global avatar displays
                document.querySelectorAll('.my-avatar, #moments-screen .top-avatar, .top-avatar').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || '';
                    else img.style.backgroundImage = p.avatar? `url('${p.avatar}')` : '';
                });
                // update moment avatars (sync instead of snapshot)
                document.querySelectorAll('.moment-avatar, .post .avatar-img').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || img.src;
                });
            }
            if(heroEl){
                if(p.heroBg){
                    if(p.heroBg.startsWith('http') || p.heroBg.startsWith('data:') || p.heroBg.startsWith('url(')){
                        heroEl.style.backgroundImage = `url('${p.heroBg}')`;
                        heroEl.style.backgroundSize = 'cover';
                        heroEl.style.backgroundPosition = 'center';
                    } else {
                        heroEl.style.background = p.heroBg;
                    }
                } else {
                    heroEl.style.background = defaults.heroBg;
                }
            }
            // If there is a moments renderer, call it to re-render posts with updated profile data
            if(typeof renderMoments === 'function') {
                try{ renderMoments(); }catch(e){}
            } else if(typeof window.renderMomentsSafe === 'function'){
                try{ window.renderMomentsSafe(); }catch(e){}
            }
        }

        // ---- Click handlers per your requirement (separate triggers) ----
        // Clicking hero edits background; clicking avatar edits avatar
        try {
            const bgBtn = document.getElementById('edit-bg-btn');
            const avatarBtn = document.getElementById('edit-avatar-btn');
            if(heroEl) heroEl.addEventListener('click', ()=> { if(bgBtn) bgBtn.click(); });
            if(avatarEl) avatarEl.addEventListener('click', ()=> { if(avatarBtn) avatarBtn.click(); });
        } catch(e){ console.warn('bind bg/avatar click failed', e); }

        // Inline edit helper for text fields (name, id, location, signature)
        function inlineEditText(el, key, placeholder){
            if(!el) return;
            el.style.cursor = 'text';
            el.addEventListener('click', function handler(e){
                e.stopPropagation();
                const old = el.textContent || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = old;
                input.placeholder = placeholder || '';
                input.style.fontSize = window.getComputedStyle(el).fontSize;
                input.style.width = '100%';
                input.style.boxSizing = 'border-box';
                el.replaceWith(input);
                input.focus();
                function commit(){
                    const v = input.value.trim();
                    const profile = loadProfileFromStorage();
                    profile[key] = v;
                    saveProfileToStorage(profile);
                    renderProfileAndSync();
                    input.removeEventListener('blur', onBlur);
                    input.removeEventListener('keydown', onKey);
                }
                function onBlur(){ commit(); input.replaceWith(el); }
                function onKey(ev){ if(ev.key === 'Enter'){ commit(); input.replaceWith(el); } else if(ev.key==='Escape'){ input.replaceWith(el); } }
                input.addEventListener('blur', onBlur);
                input.addEventListener('keydown', onKey);
            }, { once: false });
        }

        inlineEditText(nameEl, 'name', '请输入名称');
        inlineEditText(idEl, 'id', '请输入ID（将作为 authorId）');
        inlineEditText(locEl, 'location', '请输入定位文本');
        inlineEditText(sigEl, 'signature', '请输入个性签名');

        // Initial render from storage
        renderProfileAndSync();

        if (defaults.avatarSrc) {
          avatarEl.src = defaults.avatarSrc;
        }

        // 头像点击事件占位
        const wrap = document.getElementById('icity-avatar-wrap');
        if (wrap) {
          wrap.addEventListener('click', function(){
            console.log('icity avatar clicked');
          });
        }

      } catch (e) {
        console.warn('icity header init error', e);
      }
    });
  })();
</script>
<!-- === END ICITY-STYLE USER HEADER SNIPPET === -->

    <p class="placeholder-text" id="moments-empty">还没有动态，点击右上角发布吧~</p>
    <div id="moments-container"></div>
  </main>
</div>

<!-- 发布动态模态框 -->
<div class="modal-overlay" id="post-modal" style="display:none;">
  <div class="modal-window">
    <h3>发布动态</h3>
    <form id="post-form">
      <div class="form-group">
        <label>动态内容</label>
        <textarea id="post-text" placeholder="说点什么..." required rows="4"></textarea>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="add-image"> 添加图片</label>
      </div>
      <div class="form-group" id="image-input-group" style="display:none;">
  <label>图片描述</label>
  <input type="text" id="image-description" placeholder="描述图片内容（如：海边日落）">
</div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn btn-secondary" type="button" id="cancel-post-btn">取消</button>
        <button class="btn btn-primary" type="submit">发布</button>
      </div>
    </form>
  </div>
</div>

<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<style>
  /* 微调底部导航样式（不会影响你原有 .dock） */
  .bottom-nav {
    position: absolute;
    left: 0;
    right: 0;
    height: 68px;
    display: flex;
    gap: 6px;
    align-items: center;
    justify-content: center;
    padding: 10px 14px;
    box-sizing: border-box;
    background: rgba(255,255,255,0.85);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: 0 -6px 20px rgba(0,0,0,0.06);
    z-index: 50;
    bottom: 0;
  }
  .bottom-nav .nav-btn {
    flex: 1;
    height: 48px;
    border-radius: 12px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--text-color, #444);
  }
  .bottom-nav .nav-btn.active {
    background: var(--primary-color, #ff80ab);
    color: #fff;
    box-shadow: 0 6px 16px rgba(255,128,171,0.22);
  }

  /* moments 列表项 */
  .moment-item {
    background: #fff;
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.03);
  }
  .moment-head { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
  .moment-avatar { width:44px; height:44px; border-radius:50%; object-fit:cover; background:#eee; flex-shrink:0; }
  .moment-meta { font-size:13px; }
  .moment-text { margin:8px 0; white-space:pre-wrap; color:var(--text-color,#333); }
  .moment-image { width:100%; max-height:260px; object-fit:cover; border-radius:10px; margin-top:8px; }
  .moment-comments { margin-top:10px; padding-top:8px; border-top:1px solid #faf0f4; color:#666; font-size:13px; }
  .moment-comment { margin-bottom:6px; }

  /* --- 新增：动态操作栏 (点赞/评论) --- */
  .moment-actions {
    display: flex;
    gap: 12px;
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #f5f5f5;
  }
  .moment-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: #888;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
  }
  .moment-action-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }
  .moment-action-btn.liked {
    color: var(--primary-color);
  }

  /* --- 新增：点赞列表显示 --- */
  .moment-likes {
    background-color: #f9f9f9;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    margin-top: 8px;
    display: none; /* 默认隐藏 */
  }
  .moment-likes.visible {
    display: block;
  }
  .moment-likes .like-icon {
    color: var(--primary-color);
    margin-right: 4px;
  }

  /* --- 新增：用户评论输入区域 --- */
  .moment-comment-input-area {
    display: none; /* Default hidden */
    gap: 8px;
    margin-top: 10px;
  }
  .moment-comment-input-area.visible {
    display: flex;
  }
  .moment-comment-input {
    flex-grow: 1;
    border: 1px solid #eee;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
  }
  .moment-comment-input:focus {
    outline: none;
    border-color: var(--primary-color);
  }
  .post-comment-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    cursor: pointer;
    flex-shrink: 0;
  }
  /* --- 在 <style> 标签内添加 --- */
.message-bubble .quoted-content {
    /* --- 在这里调整引用块的大小和样式 --- */
    --quote-font-size: 0.6em;       /* 引用文字大小 (em是相对于气泡文字大小的单位) */
    --quote-padding: 4px 6px;      /* 引用块的内边距 (上下 左右) */
    --quote-bottom-margin: 5px;     /* 引用块与下方回复文字的间距 */
    --quote-border-thickness: 2px;  /* 左侧引用竖线的粗细 */
    /* --- 调整结束 --- */

    font-size: var(--quote-font-size);
    padding: var(--quote-padding);
    margin-bottom: var(--quote-bottom-margin);
    border-left: var(--quote-border-thickness) solid var(--accent-color);
    
    background-color: rgba(0,0,0,0.05);
    border-radius: 8px;
    color: #555;
    word-wrap: break-word;
    white-space: pre-wrap;
}

.message-bubble .quoted-content .quoted-text {
    opacity: 0.8;
}
.message-bubble .reply-text {
    margin-top: 5px;
}
  
/* --- 在 <style> 标签末尾添加 --- */
.notification-banner {
    position: absolute;
    top: 45px; /* 根据你的header高度微调 */
    left: 50%;
    transform: translateX(-50%) translateY(-200%);
    width: 90%;
    max-width: 380px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    padding: 10px;
    z-index: 999;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
}

.notification-banner.show {
    transform: translateX(-50%) translateY(0);
}

.notification-banner img {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    margin-right: 10px;
    object-fit: cover;
    flex-shrink: 0;
}

.notification-banner #notification-text {
    flex-grow: 1;
    font-size: 14px;
    color: #333;
    line-height: 1.4;
}

.notification-banner button {
    background: none;
    border: none;
    font-size: 24px;
    color: #aaa;
    cursor: pointer;
    padding: 0 5px;
}
/* --- 在 <style> 标签末尾添加 --- */
.mention-panel {
    position: absolute;
    background: white;
    border: 1px solid #eee;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    max-height: 150px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
}
.mention-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.mention-item:hover {
    background-color: #f5f5f5;
}
.mention-item img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
}
</style>

<div id="bottom-nav-host" data-managed-by="injection" style="display:none;">
  <div class="bottom-nav" id="bottom-nav">
    <button class="nav-btn active" data-target="chat-list-screen">聊天</button>
    <button class="nav-btn" data-target="moments-screen">动态</button>
  </div>
</div>

<script>
(function() {
  // 等 DOM 完全加载
  document.addEventListener('DOMContentLoaded', () => {
    // --- 全局辅助函数 ---
    window.getAuthorNameById = function(authorId) {
        if (!authorId) return '未知';
        // 优先从顶栏信息获取自己的名字
        if (typeof loadProfileFromStorage === 'function') {
            const myProfile = loadProfileFromStorage();
            if (myProfile && myProfile.id === authorId) {
                return myProfile.name || '我';
            }
        }
        // 从全局 db 对象查找
        if (window.db) { // This now refers to the main data object, not Dexie.
            if (window.db.characters) {
                const character = window.db.characters.find(c => c.id === authorId);
                if (character) return character.remarkName;
            }
            if (window.db.groups) {
                for (const group of window.db.groups) {
                    if (group.members) {
                        const member = group.members.find(m => m.id === authorId);
                        if (member) return member.groupNickname;
                    }
                }
            }
        }
        // Fallback
        return authorId.startsWith('char_') ? '某角色' : authorId;
    };

    // --- 简单工具函数 ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function escapeText(t) { return String(t == null ? '' : t); }

    // 1) 初始化 Dexie（使用页面已引入的 Dexie）
    let db;
    try {
      db = new Dexie('AppDB_Moments');
      db.version(1).stores({
        moments: 'id,timestamp,commentedBy' // comments 和 likes 存在于对象内
      });
      // expose to window so external scripts can access the Dexie instance
      try{ window.AppDB_Moments = db; }catch(e){}

    } catch (e) {
      console.error('Dexie init failed', e);
      showToast('本地数据库初始化失败，动态功能受限');
      return;
    }
    // 2) DOM 元素
    const openPostBtn = $('#open-post-modal');
    const postModal = $('#post-modal');
    const postForm = $('#post-form');
    const addImageCheckbox = $('#add-image');
    const imageInputGroup = $('#image-input-group');
    const postImageInput = $('#post-image');
    const imageDescInput = $('#image-description');
    const postImagePreview = $('#post-image-preview');
    const cancelPostBtn = $('#cancel-post-btn');
    const momentsContainer = $('#moments-container');
    const momentsEmpty = $('#moments-empty');
    const momentsScreen = $('#moments-screen');
    const bottomNavHost = document.getElementById('bottom-nav-host');
if (typeof setupMentions === 'function') {
        try {
            setupMentions();
        } catch (e) {
            console.error("在动态模块中初始化提及功能失败:", e);
        }
    }
    // 3) 绑定打开/关闭发布模态
    if (openPostBtn) openPostBtn.addEventListener('click', () => {
      postModal.style.display = 'flex';
      postModal.classList.add('visible');
    });
    if (cancelPostBtn) cancelPostBtn.addEventListener('click', closePostModal);
    function closePostModal() {
      postModal.style.display = 'none';
      postModal.classList.remove('visible');
      postForm.reset();
      // 清理图片预览与文件输入，避免残留 dataURL 或页面 URL 导致后续发布异常
      try { postImagePreview.src = ''; } catch(e){}
      try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){}
      postImagePreview.style.display = 'none';
      imageInputGroup.style.display = 'none';
    }

    addImageCheckbox.addEventListener('change', e => {
      // 如果取消添加图片，清理之前的预览和文件输入
      if (!addImageCheckbox.checked) { try { postImagePreview.src = ''; } catch(e){} try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){} }

      imageInputGroup.style.display = e.target.checked ? 'block' : 'none';
    });

    

    async function fileToDataURLAndCompress(file, maxWidth = 1200, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if (w > maxWidth) {
              nw = maxWidth;
              nh = Math.round(h * (maxWidth / w));
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw;
            canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            const out = canvas.toDataURL('image/jpeg', quality);
            resolve(out);
          };
          img.onerror = reject;
          img.src = ev.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 4) 发布动态（写入 Dexie）
    

// --- Safe addMoment helper (injected by assistant) ---
async function addMomentToDB(momentObj) {
  // 1) Prefer global Dexie instance AppDB_Moments if available
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.add === 'function') {
      return window.AppDB_Moments.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 2) If window.db.moments looks like Dexie, use it
  try {
    if (window.db && window.db.moments && typeof window.db.moments.add === 'function') {
      return window.db.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 3) Fallback to in-memory array and try to persist via saveData()
  if (!window.db) window.db = {};
  if (!Array.isArray(window.db.moments)) window.db.moments = [];
  window.db.moments.push(momentObj);

  if (typeof window.saveData === 'function') {
    try { await window.saveData(); } catch(e){ console.warn('saveData fallback failed', e); }
  }

  // 4) Try to mirror into AppDB_Moments (put to avoid duplicate key issues)
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.put === 'function') {
      await window.AppDB_Moments.moments.put(momentObj);
    }
  } catch(e){ console.warn('mirror to AppDB_Moments failed', e); }

  return Promise.resolve();
}

// --- Replaced postForm submit handler (injected by assistant) ---
postForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const submitBtn = postForm.querySelector('button[type=\"submit\"]');
  if (submitBtn) submitBtn.disabled = true;

  // adapt these IDs to match your form inputs if they differ
  const textEl = document.getElementById('post-text');
  const addImageEl = document.getElementById('add-image');
  const imageDescEl = document.getElementById('image-description');

  const text = textEl ? textEl.value.trim() : '';
  const addImage = addImageEl ? addImageEl.checked : false;
  const imageDesc = imageDescEl ? imageDescEl.value.trim() : '';

  if (!text && !addImage) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入动态内容');
    return;
  }

  if (addImage && !imageDesc) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入图片描述');
    return;
  }

  const id = 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
  const momentObj = {
    id,
    authorId: (localStorage.getItem('myTopId') || 'user'),
    authorAvatar: (localStorage.getItem('myTopAvatar') || null),
    text,
    imageDesc: addImage ? imageDesc : '',
    timestamp: Date.now(),
    commentedBy: [],
    comments: [],
    likes: []
  };

  try {
    await addMomentToDB(momentObj);

    if (typeof showToast === 'function') showToast('发布成功');
    try { if (typeof closePostModal === 'function') closePostModal(); } catch(e){}

    // Force immediate re-render of moments
    if (typeof renderMoments === 'function') {
      try { await renderMoments(); } catch(e){ console.warn('renderMoments failed', e); }
    } else if (typeof window.renderMomentsSafe === 'function') {
      try { await window.renderMomentsSafe(); } catch(e){ console.warn('renderMomentsSafe failed', e); }
    } else {
      // last resort: toggle screen class to force repaint
      const ms = document.getElementById('moments-screen');
      if (ms) {
        ms.classList.remove('active');
        setTimeout(()=>ms.classList.add('active'), 10);
      }
    }
  } catch (e) {
    console.error('add moment err', e);
    if (typeof showToast === 'function') showToast('保存失败: ' + (e && e.message ? e.message : String(e)));
  } finally {
    if (submitBtn) submitBtn.disabled = false;
  }
});



    // 5) 渲染动态列表
    async function renderMoments() {
  const list = await db.moments.orderBy('timestamp').reverse().toArray();
  const momentsContainer = document.getElementById('moments-container');
  const momentsEmpty = document.getElementById('moments-empty');

  if (!momentsContainer) {
      console.error("Fatal Error: #moments-container element not found.");
      return;
  }

  momentsContainer.innerHTML = '';

  if (!list.length) {
    if (momentsEmpty) momentsEmpty.style.display = 'block';
    return;
  } else {
    if (momentsEmpty) momentsEmpty.style.display = 'none';
  }

  const myProfile = loadProfileFromStorage();
  const myId = myProfile.id || 'user';

  list.forEach(m => {
    const div = document.createElement('div');
    div.className = 'moment-item';
    div.dataset.id = m.id || (m.id = ('m_' + Date.now() + Math.random()));

    const head = document.createElement('div');
    head.className = 'moment-head';
    const avatar = document.createElement('img');
    avatar.className = 'moment-avatar';
    avatar.src = m.authorAvatar || 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23e9f5ff%22/%3E%3Ccircle%20cx%3D%2232%22%20cy%3D%2224%22%20r%3D%2212%22%20fill%3D%22%237fb3ff%22/%3E%3Crect%20x%3D%228%22%20y%3D%2240%22%20width%3D%2248%22%20height%3D%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
    const meta = document.createElement('div');
    meta.className = 'moment-meta';
    const name = document.createElement('div');
    name.style.fontWeight = '700';
    name.textContent = window.getAuthorNameById(m.authorId) || m.author || '我';
    const time = document.createElement('div');
    time.style.fontSize = '12px';
    time.style.color = '#999';
    try {
      time.textContent = new Date(m.timestamp).toLocaleString();
    } catch (e) {
      time.textContent = '';
    }
    meta.appendChild(name);
    meta.appendChild(time);
    head.appendChild(avatar);
    head.appendChild(meta);
    div.appendChild(head);

    const txt = document.createElement('div');
    txt.className = 'moment-text';
    txt.textContent = m.text || '';
    div.appendChild(txt);

    if (m.imageData && m.imageData.length > 10) {
      const im = document.createElement('img');
      im.className = 'moment-image';
      im.src = m.imageData;
      im.alt = m.imageDesc || m.text || '动态图片';
      div.appendChild(im);
    } else if (m.imageDesc) {
      const descCard = document.createElement('div');
      descCard.className = 'moment-image-desc-card';
      const descContent = document.createElement('p');
      descContent.className = 'desc-content';
      descContent.textContent = m.imageDesc;
      descCard.appendChild(descContent);
      div.appendChild(descCard);
    }

    const actions = document.createElement('div');
    actions.className = 'moment-actions';
    const likeBtn = document.createElement('button');
    likeBtn.className = 'moment-action-btn';
    const likes = m.likes || [];
    if (likes.includes(myId)) {
      likeBtn.classList.add('liked');
    }
    likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
    likeBtn.addEventListener('click', async (event) => {
      const btn = event.currentTarget;
      const momentItem = btn.closest('.moment-item');
      const currentLikes = m.likes || [];
      const myIdx = currentLikes.indexOf(myId);
      if (myIdx > -1) {
        currentLikes.splice(myIdx, 1);
        btn.classList.remove('liked');
      } else {
        currentLikes.push(myId);
        btn.classList.add('liked');
      }
      m.likes = currentLikes;
      await db.moments.put(m);
      btn.querySelector('span').textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
      const likesWrap = momentItem.querySelector('.moment-likes');
      if (likesWrap) {
        if (currentLikes.length > 0) {
          const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
          likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
          likesWrap.classList.add('visible');
        } else {
          likesWrap.classList.remove('visible');
        }
      }
    });
    const commentBtn = document.createElement('button');
    commentBtn.className = 'moment-action-btn';
    commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
    // *** 修改：评论按钮点击逻辑 ***
    commentBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const momentItem = event.currentTarget.closest('.moment-item');
        if (momentItem) {
            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            if (inputArea) {
                inputArea.classList.toggle('visible');
                const input = inputArea.querySelector('input');
                const postBtn = inputArea.querySelector('button');
                // 重置为对动态的直接评论
                input.placeholder = '添加评论...';
                delete postBtn.dataset.replyToCommentId;
                delete postBtn.dataset.replyToAuthorName;
                if (inputArea.classList.contains('visible')) {
                    input.focus();
                }
            }
        }
    });

    actions.appendChild(likeBtn);
    actions.appendChild(commentBtn);
    div.appendChild(actions);

    const likesWrap = document.createElement('div');
    likesWrap.className = 'moment-likes';
    if (likes.length > 0) {
      const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
      likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
      likesWrap.classList.add('visible');
    }
    div.appendChild(likesWrap);

    const commentsWrap = document.createElement('div');
    commentsWrap.className = 'moment-comments';
    
    // *** 修改：渲染评论时添加 data- 属性 ***
    const renderCommentTree = (comments, level = 0) => {
        if (!comments || comments.length === 0) {
            return level === 0 ? '<div style="color:#bbb; font-style: italic; padding: 4px 0;">还没有评论，快来抢沙发吧！</div>' : '';
        }
        let html = '';
        comments.forEach(c => {
            const authorName = window.getAuthorNameById(c.roleId);
            // 添加 data-comment-id 和 data-author-id
            html += `<div class="moment-comment" data-comment-id="${c.id}" data-author-id="${c.roleId}" style="margin-left: ${level * 20}px;"><strong>${authorName}:</strong> <span>${c.text}</span></div>`;
            if (c.replies && c.replies.length > 0) {
                c.replies.forEach(reply => {
                   const replyAuthorName = window.getAuthorNameById(reply.roleId);
                   const replyToName = window.getAuthorNameById(c.roleId);
                   html += `<div class="moment-comment" data-comment-id="${reply.id}" data-author-id="${reply.roleId}" style="margin-left: ${(level + 1) * 20}px;"><strong>${replyAuthorName}</strong> <span style="color:#888;">回复</span> <strong>${replyToName}:</strong> <span>${reply.text}</span></div>`;
                });
            }
        });
        return html;
    };

    commentsWrap.innerHTML = renderCommentTree(m.comments);
    div.appendChild(commentsWrap);
    
    // *** 新增：为所有评论添加点击回复的事件委托 ***
    

    const commentInputArea = document.createElement('div');
    commentInputArea.className = 'moment-comment-input-area';
    commentInputArea.innerHTML = `
      <input type="text" class="moment-comment-input" placeholder="添加评论...">
      <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
    `;
    div.appendChild(commentInputArea);

    momentsContainer.appendChild(div);
  });
}
// --- 新增: 保存评论和点赞的辅助函数 ---
async function saveUserComment(momentId, commentText, replyToCommentId = null, replyToAuthorName = null) {
    try {
        if (!db || !momentId || !commentText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        const myName = myProfile.name || '我';

        const newComment = {
            id: `comment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
            roleId: myId,
            text: commentText,
            ts: Date.now(),
            replies: []
        };

        let notificationTargetCharacter = null;
        let notificationContent = '';
        
        if (replyToCommentId) {
            // 这是对一条评论的回复
            const findComment = (comments) => {
                for (const c of comments) {
                    if (c.id === replyToCommentId) return c;
                    // 注意：目前的设计AI回复和用户回复都存在replies数组，这里需要递归查找
                    if (c.replies && c.replies.length > 0) {
                        const found = findComment(c.replies);
                        if (found) return found;
                    }
                }
                return null;
            };
            const parentComment = findComment(moment.comments || []);
            
            if (parentComment) {
                parentComment.replies = parentComment.replies || [];
                parentComment.replies.push(newComment);
                
                // 如果回复的是AI，创建通知
                if (parentComment.roleId && parentComment.roleId.startsWith('char_')) {
                    notificationTargetCharacter = window.db.characters.find(c => c.id === parentComment.roleId);
                    const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                    notificationContent = `[system: ${myName} 回复了你对动态 "${momentSnippet}" 的评论: "${commentText}"]`;
                }
            } else {
                 // 如果找不到父评论（可能已被删除），则作为新评论添加
                 moment.comments = moment.comments || [];
                 moment.comments.push(newComment);
            }
        } else {
            // 这是对动态的新评论
            moment.comments = moment.comments || [];
            moment.comments.push(newComment);
            
            // 如果动态是AI发的，创建通知
            if (moment.authorId && moment.authorId.startsWith('char_')) {
                notificationTargetCharacter = window.db.characters.find(c => c.id === moment.authorId);
                const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                notificationContent = `[system: ${myName} 评论了你的动态 "${momentSnippet}": "${commentText}"]`;
            }
        }

        moment.commentedBy = moment.commentedBy || [];
        if (!moment.commentedBy.includes(myId)) {
            moment.commentedBy.push(myId);
        }

        await db.moments.put(moment);

        // 如果需要发送通知给AI，则注入上下文消息
        if (notificationTargetCharacter && notificationContent) {
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: notificationContent,
                parts: [{ type: 'text', text: notificationContent }],
                timestamp: Date.now()
            };
            notificationTargetCharacter.history.push(contextMessage);
            if (typeof window.saveData === 'function') {
                await window.saveData();
            }
        }
        
        renderMoments();
    } catch (e) {
        console.error(`Failed to save user comment for moment ${momentId}:`, e);
        showToast('评论失败');
    }
}

async function saveMomentComment(momentId, authorId, commentText) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.comments = moment.comments || [];
            moment.commentedBy = moment.commentedBy || [];
            moment.comments.push({
                roleId: authorId,
                text: commentText,
                ts: Date.now()
            });
            if (!moment.commentedBy.includes(authorId)) {
                moment.commentedBy.push(authorId);
            }
            await window.AppDB_Moments.moments.put(moment);
            if (typeof renderMoments === 'function') renderMoments();
        }
    } catch (e) {
        console.error(`Failed to save comment for moment ${momentId}:`, e);
    }
}

async function saveMomentLike(momentId, authorId) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.likes = moment.likes || [];
            if (!moment.likes.includes(authorId)) {
                moment.likes.push(authorId);
                await window.AppDB_Moments.moments.put(moment);
                if (typeof renderMoments === 'function') renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save like for moment ${momentId}:`, e);
    }
}
// --- end 新增 ---


    // 6) 获取尚未被某角色评论的动态（limit）
    async function getPendingMomentsForRole(roleId, limit = 5) {
      const all = await db.moments.orderBy('timestamp').reverse().toArray();
      const pending = all.filter(m => !(m.commentedBy || []).includes(roleId));
      return pending.slice(0, limit);
    }

    // 7) 将 AI 的评论写回数据库并标记 commentedBy
    async function markMomentsCommentedBy(commentsArray, roleId) {
      // commentsArray: [{momentId, commentText}, ...]
      try {
        await db.transaction('rw', db.moments, async () => {
          for (const c of commentsArray) {
            const m = await db.moments.get(c.momentId);
            if (!m) continue;
            const cbSet = new Set(m.commentedBy || []);
            cbSet.add(roleId);
            m.commentedBy = Array.from(cbSet);
            m.comments = m.comments || [];
            m.comments.push({ roleId, text: c.commentText, ts: Date.now() });
            await db.moments.put(m);
          }
        });
        renderMoments();
      } catch (e) {
        console.error('mark comments err', e);
      }
    }

    // 8) hook 底部导航显示逻辑（只在聊天列表 screen 可见时显示）
    // 把 bottom-nav-host 插入到 .phone-screen 内底部，使它在聊天页底部显示
    const phoneScreen = document.querySelector('.phone-screen');

    // === Step3 fix: ensure modal overlays are placed inside .phone-screen so absolute positioning works ===
    (function ensureModalsInPhoneScreen() {
      try {
        const phone = document.querySelector('.phone-screen');
        if (!phone) return;
        // move all modal overlays (only once)
        const modalSelectors = ['#post-modal', '.modal-overlay', '#sticker-modal', '#add-sticker-modal', '#time-skip-modal', '#group-recipient-selection-modal'];
        // Use querySelectorAll to move elements that exist and are not already inside phone
        document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar, #post-modal, #sticker-modal, #add-sticker-modal, #time-skip-modal, #group-recipient-selection-modal').forEach(el => {
          if (!el) return;
          if (phone.contains(el)) return;
          phone.appendChild(el);
        });
      } catch (e) {
        console.error('ensureModalsInPhoneScreen error', e);
      }
    })();

    
if (phoneScreen && bottomNavHost) {
      // 把导航放入 chat-list-screen 底部，使其仅在该 screen 内渲染与定位
      const chatListScreen = document.getElementById('chat-list-screen');
      if (phoneScreen && bottomNavHost.parentElement !== phoneScreen) {
        phoneScreen.appendChild(bottomNavHost);
      }
      bottomNavHost.style.display = 'none'; // 初始隐藏

      // --- 新增：为用户评论按钮添加事件委托 ---
      momentsContainer.addEventListener('click', async (e) => {
                // ... 在 momentsContainer 的 click 监听器内部 ...
      const postBtn = e.target.closest('.post-comment-btn');
      if (postBtn) {
          e.preventDefault();
          const momentId = postBtn.dataset.momentId;
          const input = postBtn.previousElementSibling;
          const commentText = input.value.trim();

          // 获取回复所需信息
          const replyToCommentId = postBtn.dataset.replyToCommentId || null;
          const replyToAuthorName = postBtn.dataset.replyToAuthorName || null;

          if (commentText) {
              await saveUserComment(momentId, commentText, replyToCommentId, replyToAuthorName);
              // 清理输入框和自定义属性
              input.value = '';
              input.placeholder = '添加评论...';
              delete postBtn.dataset.replyToCommentId;
              delete postBtn.dataset.replyToAuthorName;
              postBtn.closest('.moment-comment-input-area').classList.remove('visible');
          } else {
              showToast('评论内容不能为空');
          }
      }
});
      // 绑定按钮（若已有绑定则保持）
      const navButtons = bottomNavHost.querySelectorAll('.nav-btn');
      navButtons.forEach(btn => {
        if (btn._bound) return;
        btn.addEventListener('click', () => {
          navButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          const target = btn.getAttribute('data-target');
          if (typeof window.switchScreen === 'function') {
            window.switchScreen(target);
          } else {
            // 简单回退：切换 active 类并触发自定义事件
            document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === target));
            document.dispatchEvent(new CustomEvent('app:screenChanged', { detail: { targetId: target } }));
          }
        });
        btn._bound = true;
      });

      // 初始：如果当前 active 是 chat-list-screen，则显示并保持 chat 按钮 active
      const initActive = document.querySelector('.screen.active');
      if (initActive && initActive.id === 'chat-list-screen') {
        bottomNavHost.style.display = '';
        navButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
      
async function saveAiReplyToComment(momentId, commentId, replyText, aiAuthorId) {
    try {
        if (!db || !momentId || !commentId || !replyText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        // 递归查找要回复的评论
        const findCommentAndAddReply = (comments) => {
            for (const c of comments) {
                if (c.id === commentId) {
                    c.replies = c.replies || [];
                    c.replies.push({
                        id: `comment_${Date.now()}`,
                        roleId: aiAuthorId,
                        text: replyText,
                        ts: Date.now(),
                        replyTo: c.roleId // 记录这条回复是回复给谁的
                    });
                    return true;
                }
                if (c.replies && findCommentAndAddReply(c.replies)) {
                    return true;
                }
            }
            return false;
        };

        if (findCommentAndAddReply(moment.comments || [])) {
            await db.moments.put(moment);
            if (typeof renderMoments === 'function') {
                renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save AI reply for comment ${commentId}:`, e);
    }
}
      // 位置更新函数：根据 chat-list-screen 的 active 类显示/隐藏
      function updateBottomNavVisibilityByActive() {
        const chatCls = document.getElementById('chat-list-screen');
        const momentsCls = document.getElementById('moments-screen');
        if ((chatCls && chatCls.classList.contains('active')) || (momentsCls && momentsCls.classList.contains('active'))) {
          bottomNavHost.style.display = '';
        } else {
          bottomNavHost.style.display = 'none';
        }
      }
      // 立即执行一次
      updateBottomNavVisibilityByActive();

      // 监听 .phone-screen 下 class 变化（屏幕切换通常会触发 class 变化）
      const moTarget = phoneScreen;
      try {
        const mo = new MutationObserver(() => updateBottomNavVisibilityByActive());
        mo.observe(moTarget, { attributes: true, subtree: true, attributeFilter: ['class'] });
      } catch (e) {
        // ignore observer errors
      }
    }
    // 全局切换 screen 的小函数（与页面已有切换保持一致）
    function switchScreen(targetId) {
      // 仅切换 active 类，避免直接改写 style.display 导致布局（flex）异常
      document.querySelectorAll('.screen').forEach(s => {
        s.classList.toggle('active', s.id === targetId);
      });
      // 触发全局事件，通知其他模块屏幕已切换
      try {
        const ev = new CustomEvent('app:screenChanged', { detail: { targetId } });
        document.dispatchEvent(ev);
      } catch (e) {
        console.warn('dispatch app:screenChanged failed', e);
      }
      // 如果进入 moments-screen，渲染
      if (targetId === 'moments-screen' && typeof renderMoments === 'function') renderMoments();
    }

    // 9) 将动态内容与聊天一起发给 AI（挂到 #get-reply-btn）
    const getReplyBtn = $('#get-reply-btn');
    if (getReplyBtn) {
      getReplyBtn.addEventListener('click', async (ev) => {
        // Determine current roleId: try chat-room-title text
        const roleTitleEl = $('#chat-room-title');
        let roleId = roleTitleEl ? roleTitleEl.textContent.trim() : 'role_unknown';
        if (!roleId) roleId = 'role_unknown';

        // collect chat history from #message-area DOM
        const chatArea = $('#message-area');
        let chatText = '';
        if (chatArea) {
          const messages = chatArea.querySelectorAll('.message-bubble');
          const arr = [];
          messages.forEach(mb => {
            // get role name if exists, else fallback to bubble's class
            const wrapper = mb.closest('.message-wrapper');
            let who = wrapper && wrapper.classList.contains('sent') ? '我' : (wrapper && wrapper.classList.contains('received') ? roleId : '');
            arr.push(`${who}: ${mb.textContent.trim()}`);
          });
          chatText = arr.join('\n');
        }

        // pending moments
        const pending = await getPendingMomentsForRole(roleId, 5);

        // build a structured prompt (we'll ask AI to return JSON)
        let prompt = `系统：请按 JSON 格式输出：{"chat_reply":"...","moment_comments":[{"momentId":"...","comment":"..."}]}\n\n`;
        prompt += `聊天记录：\n${chatText}\n\n`;
        if (pending && pending.length) {
          prompt += `需要评论的动态（最多 ${pending.length} 条，按序对应 id）：\n`;
          pending.forEach((m, i) => {
            prompt += `${i+1}) id:${m.id}\ntext:${m.text}\nimageDesc:${m.imageDesc || ''}\n\n`;
          });
        } else {
          prompt += '（无待评论的动态）\n';
        }

        // Try to call existing global sendToAI-like function if exists
        let aiRaw = null;
        try {
          if (typeof window.sendToAI === 'function') {
            aiRaw = await window.sendToAI(prompt);
          } else if (typeof window.callAI === 'function') {
            aiRaw = await window.callAI(prompt);
          } else if (typeof window.sendMessageToModel === 'function') {
            aiRaw = await window.sendMessageToModel(prompt);
          }
        } catch (e) {
          console.error('AI call failed', e);
          showToast('AI 请求失败：' + (e.message || e));
          return;
        }

        // 解析 AI 返回（优先 JSON）
        let parsed = null;
        try {
          parsed = typeof aiRaw === 'string' ? JSON.parse(aiRaw) : aiRaw;
        } catch (e) {
          // fallback: 使用原始文本作为 chat 回复
          parsed = { chat_reply: String(aiRaw || ''), moment_comments: [] };
        }

        // 处理聊天回复：把 parsed.chat_reply 插入聊天区域（若页面已有 appendAIMessageToChat 函数优先使用）
        if (parsed && parsed.chat_reply) {
          if (typeof window.appendAIMessageToChat === 'function') {
            window.appendAIMessageToChat(parsed.chat_reply, roleId);
          } else {
            // 尝试在页面直接插入（如果 message-area 存在）
            const mArea = $('#message-area');
            if (mArea) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-wrapper received';
              const row = document.createElement('div');
              row.className = 'message-bubble received';
              row.textContent = parsed.chat_reply;
              wrapper.appendChild(row);
              mArea.appendChild(wrapper);
              mArea.scrollTop = mArea.scrollHeight;
            }
          }
        }

        // 处理 moment 评论
        if (parsed && Array.isArray(parsed.moment_comments) && parsed.moment_comments.length) {
          // Normalize to array of {momentId, commentText}
          const normalized = parsed.moment_comments.map(mc => {
            return { momentId: mc.momentId || mc.momentId || mc.id || mc.id, commentText: mc.comment || mc.commentText || mc.text || '' };
          }).filter(x => x.momentId);
          if (normalized.length) {
            await markMomentsCommentedBy(normalized, roleId);
          }
        }

      }); // end getReplyBtn click
    } // end if getReplyBtn

    // small toast helper (reuse existing #toast-notification if exists)
    function showToast(msg, timeout = 2400) {
      const t = $('#toast-notification');
      if (t) {
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), timeout);
      } else {
        // fallback
        alert(msg);
      }
    }

    /* simulateAIResponse removed: local simulated AI replies disabled by user request */

// 初始：如果页面当前在 chat-list-screen，显示 bottom nav
    const currentActive = document.querySelector('.screen.active');
    if (currentActive && currentActive.id === 'chat-list-screen') {
      // keep bottom nav visible and make chat button active
      const botNav = document.getElementById('bottom-nav');
      if (botNav) {
        botNav.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
    }

    // 如果初始存在 moments screen active，则 render
    if (currentActive && currentActive.id === 'moments-screen') renderMoments();

    // --- 将关键函数暴露到全局作用域，以便其他模块调用 ---
    window.getPendingMomentsForRole = getPendingMomentsForRole;
    window.saveMomentComment = saveMomentComment;
    window.saveMomentLike = saveMomentLike;
    window.markMomentsCommentedBy = markMomentsCommentedBy;
    window.renderMoments = renderMoments; // 暴露渲染函数，以便外部模块可以刷新动态列表

  }); // DOMContentLoaded end
})();
</script>


<!-- Begin: Render moments safe patch (injected for step4) -->
<script>
(function(){
  console.log('[injected patch] renderMomentsSafe initializing...');
  try {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
      console.warn('[injected patch] #moments-screen not found.');
    }
    // Ensure a container exists
    let momentsContainer = document.getElementById('moments-container');
    if (!momentsContainer && momentsScreen) {
      const content = momentsScreen.querySelector('.content') || momentsScreen;
      momentsContainer = document.createElement('div');
      momentsContainer.id = 'moments-container';
      content.appendChild(momentsContainer);
      console.log('[injected patch] created #moments-container');
    }
    // Safe Dexie wrapper
    let _db = null;
    if (typeof Dexie !== 'undefined') {
        // Use the existing global instance if available
        if (window.AppDB_Moments) {
            _db = window.AppDB_Moments;
        } else {
            try {
                _db = new Dexie('AppDB_Moments');
                _db.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                window.AppDB_Moments = _db; // Ensure it's globally available
            } catch (e) {
                console.warn('[injected patch] Dexie init failed:', e);
                _db = null;
            }
        }
    } else {
        console.warn('[injected patch] Dexie not available.');
    }

    window.renderMomentsSafe = async function renderMomentsSafe() {
      try {
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('#moments-container'));
        if (!container) {
          console.warn('[injected patch] No container found for moments.');
          return;
        }
        let list = [];
        if (_db && _db.moments) {
          try {
            list = await _db.moments.orderBy('timestamp').reverse().toArray();
          } catch (e) {
            console.error('[injected patch] Failed reading moments from IndexedDB:', e);
            list = [];
          }
        } else {
          // try fallback global db objects if present
          try {
            const maybeDb = window.AppDB_Moments || null;
            if (maybeDb && maybeDb.moments) {
              list = await maybeDb.moments.orderBy('timestamp').reverse().toArray();
            }
          } catch (e) {
            list = [];
          }
        }

        container.innerHTML = '';
        const momentsEmpty = document.getElementById('moments-empty');
        if (!list || !list.length) {
          if (momentsEmpty) momentsEmpty.style.display = 'block';
          else {
            const p = document.createElement('p');
            p.className = 'placeholder-text';
            p.textContent = '还没有动态，点击右上角发布吧~';
            container.appendChild(p);
          }
          return;
        } else {
          if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        list.forEach(m => {
          try {
            const div = document.createElement('div'); div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
            const head = document.createElement('div'); head.className = 'moment-head';
            const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            avatar.src = m.authorAvatar || 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23e9f5ff%22/%3E%3Ccircle%20cx%3D%2232%22%20cy%3D%2224%22%20r%3D%2212%22%20fill%3D%22%237fb3ff%22/%3E%3Crect%20x%3D%228%22%20y%3D%2240%22%20width%3D%2248%22%20height%3D%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.textContent = window.getAuthorNameById(m.authorId) || m.author || '我'; name.style.fontWeight='700';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            meta.appendChild(name); meta.appendChild(time);
            head.appendChild(avatar); head.appendChild(meta);
            div.appendChild(head);

            const txt = document.createElement('div'); txt.className='moment-text'; txt.textContent = m.text || '';
            div.appendChild(txt);

            if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
  const im = document.createElement('img'); im.className = 'moment-image';
  im.src = m.imageData;
  im.alt = m.imageDesc ? m.imageDesc : (m.text || '动态图片');
  div.appendChild(im);
  if (m.imageDesc) {
    const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
    desc.textContent = '图片：' + m.imageDesc;
    div.appendChild(desc);
  }
} else if (m.imageDesc) {
  const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
  if (m.id) descCard.dataset.momentId = m.id || '';
  const descContent = document.createElement('p'); descContent.className = 'desc-content';
  descContent.textContent = m.imageDesc;
  descCard.appendChild(descContent);
  descCard.setAttribute('role', 'img');
  descCard.setAttribute('aria-label', m.imageDesc);
  descCard.addEventListener('click', function () { /* show detail */ });
  div.appendChild(descCard);
}

        // --- 新增：点赞和评论的UI与逻辑 ---
        const actions = document.createElement('div');
        actions.className = 'moment-actions';
        
        const likeBtn = document.createElement('button');
        likeBtn.className = 'moment-action-btn';
        const likes = m.likes || [];
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        if (likes.includes(myId)) {
            likeBtn.classList.add('liked');
        }
        likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
        
        likeBtn.addEventListener('click', async (event) => {
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            const currentLikes = m.likes || [];
            const myIdx = currentLikes.indexOf(myId);

            if (myIdx > -1) {
                currentLikes.splice(myIdx, 1);
                btn.classList.remove('liked');
            } else {
                currentLikes.push(myId);
                btn.classList.add('liked');
            }
            m.likes = currentLikes;
            await db.moments.put(m);

            // 直接更新UI，避免重新渲染整个列表
            const span = btn.querySelector('span');
            if (span) {
                span.textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
            }

            const likesWrap = momentItem.querySelector('.moment-likes');
            if (likesWrap) {
                if (currentLikes.length > 0) {
                    const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                    likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                    likesWrap.classList.add('visible');
                } else {
                    likesWrap.classList.remove('visible');
                }
            }
        });

        const commentBtn = document.createElement('button');
        commentBtn.className = 'moment-action-btn';
        commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
        commentBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            if (momentItem) {
                const inputArea = momentItem.querySelector('.moment-comment-input-area');
                if (inputArea) {
                    inputArea.classList.toggle('visible');
                    if (inputArea.classList.contains('visible')) {
                        inputArea.querySelector('input').focus();
                    }
                }
            }
        });

        actions.appendChild(likeBtn);
        actions.appendChild(commentBtn);
        div.appendChild(actions);

        // 点赞列表
        if (likes.length > 0) {
            const likesWrap = document.createElement('div');
            likesWrap.className = 'moment-likes visible';
            const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
            likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
            div.appendChild(likesWrap);
        }

        // comments
        const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
        if (m.comments && m.comments.length) {
          m.comments.forEach(c => {
            const cm = document.createElement('div'); cm.className='moment-comment';
            const authorName = window.getAuthorNameById(c.roleId || c.role);
            cm.textContent = `${authorName}：${c.text}`;
            commentsWrap.appendChild(cm);
          });
        } else {
          const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = '暂时没有评论';
          commentsWrap.appendChild(none);
        }
        div.appendChild(commentsWrap);

        // --- 新增：用户评论输入框 ---
        const commentInputArea = document.createElement('div');
        commentInputArea.className = 'moment-comment-input-area';
        commentInputArea.innerHTML = `
          <input type="text" class="moment-comment-input" placeholder="添加评论...">
          <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
        `;
        div.appendChild(commentInputArea);
            container.appendChild(div);
          } catch (innerErr) {
            console.error('[injected patch] render single moment failed', innerErr, m);
          }
        });

      } catch (err) {
        console.error('[injected patch] renderMomentsSafe failed', err);
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('.content'));
        if (container) {
          container.innerHTML = '<div style="color:#b00;padding:12px;border-radius:10px;background:#fff8f8;">加载动态时出错（详情见 Console）</div>';
        }
      }
    };

    // Attach to app:screenChanged and mutation observer
    document.addEventListener('app:screenChanged', (ev) => {
      try {
        if (ev && ev.detail && ev.detail.targetId === 'moments-screen') {
          window.renderMomentsSafe();
        }
      } catch (e) { console.error('[injected patch] app:screenChanged handler failed', e); }
    });

    const phone = document.querySelector('.phone-screen') || document.body;
    const mo = new MutationObserver((mutations) => {
  try {
    // 只在 phone 节点本身的 class 发生变化时才触发（避免子元素的 class 变动导致重渲染）
    const phoneClassChanged = mutations.some(m =>
      m.type === 'attributes' && m.attributeName === 'class' && m.target === phone
    );
    if (!phoneClassChanged) return;

    const active = document.querySelector('.screen.active');
    if (active && active.id === 'moments-screen') {
      window.renderMomentsSafe();
    }
  } catch (e) { console.error('[injected patch] MutationObserver callback failed', e); }
});
// 仅观察 phone 自身的 attributes（不要 subtree=true）
mo.observe(phone, { attributes: true, subtree: false, attributeFilter: ['class'] });


    // try initial render
    setTimeout(() => {
      try { window.renderMomentsSafe(); } catch(e) { console.warn('[injected patch] initial render failed', e); }
    }, 300);

  } catch (e) {
    console.error('[injected patch] initialization failed', e);
  }
})();
</script>
<!-- End: Render moments safe patch -->


<script>
/* === 确保 #moments-screen 永远在 .phone-screen 内，并清除会把它推出视窗的内联样式 (自动插入补丁) === */

(function ensureMomentsStaysInPhone() {
  function fixPlacementAndStyles() {
    const phone = document.querySelector('.phone-screen');
    const moments = document.getElementById('moments-screen');
    if (!phone) return;

    // If moments exists, ensure it's inside phone but *do not force inline styles on it*
    if (moments && !phone.contains(moments)) {
      phone.appendChild(moments);
      console.log('[patch] moved #moments-screen into .phone-screen');
    }

    // Only normalize styles for screens *other than* moments-screen or elements managed by injection
    document.querySelectorAll('.screen').forEach(s => {
      if (s.id === 'moments-screen' || s.dataset.managedBy === 'injection') {
        // make sure its stacking context is reasonable but don't clobber its layout
        s.style.zIndex = s.style.zIndex || '0';
        return;
      }
      // Apply conservative safe defaults to other screens
      s.style.position = s.style.position || 'absolute';
      s.style.top = s.style.top || '0';
      s.style.left = s.style.left || '0';
      s.style.right = s.style.right || '0';
      s.style.bottom = s.style.bottom || '0';
      // Avoid removing transforms which some screens might rely on; only clear very specific problematic inline styles
      if ((s.style.transform || '').includes('translate') || (s.style.transform || '').includes('translateY')) {
        // leave transforms intact to avoid breaking animations
      } else {
        s.style.transform = s.style.transform || '';
      }
      s.style.margin = s.style.margin || '';
      // ensure screens stack below nav/modals
      s.style.zIndex = s.style.zIndex || '0';
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPlacementAndStyles);
  } else {
    fixPlacementAndStyles();
  }
  // only run on custom app events; do not poll aggressively to avoid fighting the injected UI
  document.addEventListener('app:screenChanged', fixPlacementAndStyles);
  // run a very infrequent check as a last resort
  setInterval(fixPlacementAndStyles, 5000);
})();
</script>

<!-- === /patch === -->

<!-- Avatar overlap CSS override (scaled to 70%) inserted by assistant -->
<style>
.icity-moments-inner {
  --icity-hero-h: 154px;      /* 70% of original 220px */
  --icity-avatar-size: 98px;  /* 70% of original 140px */
  position: relative;
  box-sizing: border-box;
}

.icity-hero {
  height: var(--icity-hero-h) !important;
  position: relative;
  overflow: hidden;
  border-radius: 14px 14px 0 0;
  box-sizing: border-box;
}

.icity-avatar-wrap {
  position: absolute !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  width: var(--icity-avatar-size) !important;
  height: var(--icity-avatar-size) !important;
  border-radius: 50% !important;
  top: calc(var(--icity-hero-h) - (var(--icity-avatar-size) * 0.7)) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  z-index: 50 !important;
  background: #fff !important;
  box-shadow: 0 8px 22px rgba(0,0,0,0.12) !important;
  border: 6px solid rgba(255,255,255,0.95) !important;
  box-sizing: border-box !important;
  overflow: visible !important;
}

.icity-avatar-wrap img,
.icity-avatar-wrap .avatar-img {
  width: 80% !important;
  height: 80% !important;
  border-radius: 50% !important;
  object-fit: cover !important;
  display: block !important;
}

.icity-info-card {
  position: relative !important;
  padding-top: calc(var(--icity-avatar-size) * 0.2 + 4px) !important; /* Reduced top padding */
  padding-right: 18px !important;
  padding-left: 18px !important;
  padding-bottom: 10px !important; /* Reduced bottom padding */
  margin-top: 10px !important;
  background: #fff !important;
  border-radius: 14px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,0.04) !important;
  box-sizing: border-box !important;
  text-align: center !important;
}

/* Reduce vertical spacing and font sizes for a more compact info card */
.icity-name {
    font-size: 18px !important;
    line-height: 1.1 !important;
}
.icity-id-loc {
    margin-top: 6px !important;
    font-size: 12px !important;
    line-height: 1.1 !important;
}
.icity-signature {
    margin-top: 8px !important;
    font-size: 13px !important;
    line-height: 1.2 !important;
}

@media (max-width: 420px) {
  .icity-moments-inner {
    --icity-hero-h: 112px;  /* 70% of previous 160px */
    --icity-avatar-size: 77px; /* 70% of previous 110px */
  }
}
</style>
<!-- End assistant-inserted CSS -->

<!-- === Avatar & Background Edit Feature === -->
<div class="action-sheet-overlay" id="edit-top-section-actionsheet">
  <div class="action-sheet">
    <button class="action-sheet-button" id="edit-bg-btn">更换背景图</button>
    <button class="action-sheet-button" id="edit-avatar-btn">更换头像</button>
    <button class="action-sheet-button danger" id="cancel-edit-top-btn">取消</button>
  </div>
</div>
<input type="file" accept="image/*" id="top-section-file-input" style="display:none;" />

<script>
(function(){
    const topSection = document.querySelector('#moments-screen .icity-moments-inner .icity-hero') || document.querySelector('#moments-screen .icity-hero') || document.querySelector('#moments-screen .top-section') || document.querySelector('#moments-screen header');
    const editSheet = document.getElementById('edit-top-section-actionsheet');
    const bgBtn = document.getElementById('edit-bg-btn');
    const avatarBtn = document.getElementById('edit-avatar-btn');
    const cancelBtn = document.getElementById('cancel-edit-top-btn');
    const fileInput = document.getElementById('top-section-file-input');

    let currentEditTarget = null;

    // Restore saved bg & avatar
    const savedBg = localStorage.getItem('myTopBg');
    const savedAvatar = localStorage.getItem('myTopAvatar');
    if(savedBg && topSection) {
        topSection.style.backgroundImage = `url('${savedBg}')`;
        topSection.style.backgroundSize = 'cover';
        topSection.style.backgroundPosition = 'center';
    }
    if(savedAvatar) {
        document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
            if(img.tagName === 'IMG') img.src = savedAvatar;
            else img.style.backgroundImage = `url('${savedAvatar}')`;
        });
    }

    // Previously opened the whole topSection on click — removed to avoid accidental edits during publish.
    // Now only explicit edit controls (avatar/background buttons and per-field clicks) will trigger edits.

    cancelBtn.addEventListener('click', ()=>{
        editSheet.classList.remove('visible');
    });

    function chooseSource(targetType) {
        const url = prompt('输入图片URL，或留空选择本地文件：');
        if(url) {
            applyImage(targetType, url);
        } else {
            currentEditTarget = targetType;
            fileInput.click();
        }
    }

    function applyImage(targetType, dataUrl) {
        if(targetType === 'bg') {
            if(topSection) {
                topSection.style.backgroundImage = `url('${dataUrl}')`;
                topSection.style.backgroundSize = 'cover';
                topSection.style.backgroundPosition = 'center';
            }
            localStorage.setItem('myTopBg', dataUrl);
        } else if(targetType === 'avatar') {
            localStorage.setItem('myTopAvatar', dataUrl);
            document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 同步动态列表头像（moment-avatar 为动态列表头像类）
            document.querySelectorAll('.post .avatar-img, .moment-avatar').forEach(img => {
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 尝试更新数据库中属于当前用户(authorId匹配)或无 authorId 但 author 名称匹配的 moments 的 authorAvatar 字段（若存在 db）
            try{
                if(window.AppDB_Moments && typeof AppDB_Moments !== 'undefined' && AppDB_Moments.moments){
                    (async ()=>{
                        try{
                            const all = await AppDB_Moments.moments.toArray();
                            const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                                name: localStorage.getItem('myTopName') || '我',
                                id: localStorage.getItem('myTopId') || 'user',
                                avatar: localStorage.getItem('myTopAvatar') || null
                            };
                            for(const m of all){
                                // Update moments that explicitly reference this author's id
                                if((m.authorId && m.authorId === profile.id) || (!m.authorId && m.author === profile.name)){
                                    m.authorAvatar = dataUrl;
                                    // If the moment had no authorId, bind it to current profile.id so future syncs work
                                    if(!m.authorId) m.authorId = profile.id;
                                    try{ await AppDB_Moments.moments.put(m); }catch(e){ /* ignore put errors for individual items */ }
                                }
                            }
                            // After DB updates, re-render moments so DOM reflects DB changes
                            if(typeof renderMoments === 'function') try{ renderMoments(); }catch(e){}
                            else if(typeof window.renderMomentsSafe === 'function') try{ window.renderMomentsSafe(); }catch(e){}
                        }catch(e){}
                    })();
                }
            }catch(e){}
            // Ensure profile render + sync runs to update in-memory DOM and trigger any re-renders
            try{ if(typeof renderProfileAndSync === 'function') renderProfileAndSync(); }catch(e){}
        }
    }
fileInput.addEventListener('change', async (e)=>{
        const file = e.target.files[0];
        if(file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                applyImage(currentEditTarget, compressedUrl);
            } catch (error) {
                if(typeof showToast === 'function') showToast('图片处理失败，请重试');
                console.error('Background image compression failed:', error);
            }
        }
    });

    bgBtn.addEventListener('click', ()=> chooseSource('bg'));
    avatarBtn.addEventListener('click', ()=> chooseSource('avatar'));
})();
</script>
<!-- === /Avatar & Background Edit Feature === -->


<!-- Avatar sync patch: non-invasive, appended to avoid modifying original logic.
     Purpose: ensure top avatar updates immediately and moments list does not revert
     by synchronizing DOM and (if possible) the DB after avatar changes. -->
<script>
(function(){
  'use strict';

  // Utility: load profile from existing function if available, otherwise from localStorage
  function loadProfileFallback(){
    try {
      if(typeof loadProfileFromStorage === 'function'){
        var p = loadProfileFromStorage();
        if(p && (p.avatar || p.id || p.name)) return p;
      }
    } catch(e){}
    // fallback to localStorage keys used by the app
    try {
      return {
        id: localStorage.getItem('myTopId') || localStorage.getItem('icity-id') || localStorage.getItem('userId') || null,
        name: localStorage.getItem('myTopName') || localStorage.getItem('icity-name') || localStorage.getItem('userName') || null,
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('icity-avatar-src') || localStorage.getItem('userAvatar') || null,
        signature: localStorage.getItem('myTopSignature') || null,
        location: localStorage.getItem('myTopLocation') || null
      };
    } catch(e){
      return {};
    }
  }

  // Robustly update top-profile DOM elements and common avatar selectors
  function updateTopProfileAndAvatars(){
    try {
      var p = loadProfileFallback() || {};
      var avatar = p.avatar || null;
      // find common top avatar elements
      var avatarSelectors = [
        '#icity-avatar', // explicit id
        '.icity-avatar-wrap img',
        '.top-avatar',
        '.my-avatar',
        '.header-avatar img',
        '.profile-avatar img'
      ];
      avatarSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            if(!el) return;
            if(el.tagName === 'IMG'){
              if(avatar) el.src = avatar;
            } else {
              if(avatar) el.style.backgroundImage = "url('"+avatar+"')";
            }
          } catch(e){}
        });
      });

      // update textual profile elements defensively
      var nameEls = [document.getElementById('icity-name'), document.querySelector('.icity-name'), document.querySelector('.profile-name')];
      nameEls.forEach(function(el){
        if(el && p.name) try{ el.textContent = p.name; }catch(e){}
      });
      var sigEls = [document.getElementById('icity-signature'), document.querySelector('.icity-signature')];
      sigEls.forEach(function(el){
        if(el && p.signature) try{ el.textContent = p.signature; }catch(e){}
      });

      // update moments list avatars for moments authored by current profile (best-effort)
      try {
        var id = p.id || null;
        var name = p.name || null;
        var avatars = document.querySelectorAll('.moment-avatar, .post .avatar-img, .post .author-avatar, .item .avatar, .comment .avatar, img[data-role="avatar"]');
        avatars.forEach(function(img){
          try {
            if(!img) return;
            // try dataset or attributes
            var authorId = img.getAttribute('data-author-id') || img.dataset && img.dataset.authorId || null;
            var authorName = img.getAttribute('data-author') || img.getAttribute('data-author-name') || img.dataset && img.dataset.author || null;

            // also try to find author id/name from closest ancestor
            if(!authorId || !authorName){
              var ancestor = img.closest('[data-author-id], [data-author], .moment, .post');
              if(ancestor){
                if(!authorId) authorId = ancestor.getAttribute('data-author-id') || ancestor.getAttribute('data-author') || null;
                if(!authorName) authorName = ancestor.getAttribute('data-author-name') || ancestor.getAttribute('data-author') || null;
                // check for .author-name text
                if(!authorName){
                  var an = ancestor.querySelector('.author-name, .name, .post-author');
                  if(an) authorName = (an.textContent || '').trim();
                }
              }
            }

            // Decision: if authorId matches, or authorName matches (best-effort), update the img.src
            var shouldUpdate = false;
            if(id && authorId && String(authorId) === String(id)) shouldUpdate = true;
            if(!shouldUpdate && name && authorName && String((authorName||'').trim()) === String((name||'').trim())) shouldUpdate = true;

            if(shouldUpdate && avatar){
              if(img.tagName === 'IMG'){
                img.src = avatar;
              } else {
                img.style.backgroundImage = "url('"+avatar+"')";
              }
            }
          } catch(e){}
        });
      } catch(e){}
    } catch(e){}
  }

  // Try to update a Dexie/DB moments table authorAvatar entries for current user (best-effort, non-blocking)
  function tryUpdateDBMomentsAvatar(newAvatar){
    try {
      var p = loadProfileFallback();
      if(!p || !p.id || !newAvatar) return;
      // if window.AppDB_Moments and Dexie-like table exists, try to update entries where authorId matches
      if(window.AppDB_Moments && window.AppDB_Moments.moments){
        try {
          // If it's Dexie or has where API
          if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.toArray === 'function'){
            // best-effort: update authorAvatar for matching authorId
            // .where('authorId').equals(p.id).modify({ authorAvatar: newAvatar }) might exist
            if(typeof window.AppDB_Moments.moments.where === 'function'){
              try {
                var q = window.AppDB_Moments.moments.where('authorId').equals(p.id);
                if(q && typeof q.modify === 'function'){
                  q.modify(function(obj){ obj.authorAvatar = newAvatar; });
                } else {
                  // fallback: scan and put
                  window.AppDB_Moments.moments.toArray().then(function(arr){
                    arr.forEach(function(item){
                      try {
                        if(item.authorId && String(item.authorId) === String(p.id)){
                          item.authorAvatar = newAvatar;
                          if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item);
                        }
                      } catch(e){}
                    });
                  }).catch(function(){});
                }
              } catch(e){}
            }
          } else if(typeof window.AppDB_Moments.moments.update === 'function'){
            // unknown API: attempt to update each by scanning
            try {
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = newAvatar;
                    try { window.AppDB_Moments.moments.update(item.id, item); } catch(e){}
                  }
                });
              }).catch(function(){});
            } catch(e){}
          }
        } catch(e){}
      }
    } catch(e){}
  }

  // Wrap existing applyImage (if present) so after changing avatar we sync
  if(typeof window.applyImage === 'function'){
    try {
      var origApplyImage = window.applyImage;
      window.applyImage = function(){
        try {
          var res = origApplyImage.apply(this, arguments);
          // schedule sync shortly after (some apps update DOM async)
          setTimeout(function(){
            try {
              updateTopProfileAndAvatars();
              var p = loadProfileFallback();
              if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
            } catch(e){}
          }, 100);
          return res;
        } catch(e){
          try { return origApplyImage.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  } else {
    // If applyImage not found, expose a safe function for callers to use
    window.__syncAvatarsAfterChange = function(){
      try {
        updateTopProfileAndAvatars();
        var p = loadProfileFallback();
        if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
      } catch(e){}
    };
  }

  // If renderMomentsSafe exists, wrap it to call our sync after running original
  if(typeof window.renderMomentsSafe === 'function'){
    try {
      var _origRenderMomentsSafe = window.renderMomentsSafe;
      window.renderMomentsSafe = function(){
        try {
          var res = _origRenderMomentsSafe.apply(this, arguments);
          // after render, ensure our avatars are applied
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMomentsSafe.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Also wrap any generic renderMoments function if present
  if(typeof window.renderMoments === 'function'){
    try {
      var _origRenderMoments = window.renderMoments;
      window.renderMoments = function(){
        try {
          var res = _origRenderMoments.apply(this, arguments);
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMoments.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Run once at load to align UI with stored avatar (without waiting for user action)
  try { setTimeout(updateTopProfileAndAvatars, 50); } catch(e){}

  // Expose for debugging (non-enumerable)
  try { Object.defineProperty(window, '__updateProfileAndAvatars', { value: updateTopProfileAndAvatars, writable: false }); } catch(e){}

  // Do not interfere with bottom navigation: avoid touching elements with ids/classes typically used by navbars.
  // The script only touches avatar/name related selectors and moment avatars; it is intentionally conservative.

})();
</script>

<!-- Stronger enforcement: bind moment avatars to top avatar persistently -->
<script>
(function(){
  'use strict';
  // Helper to read top avatar from DOM or storage
  function getTopAvatar(){
    try {
      // Try common selectors for top avatar
      var selectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img', '.my-avatar'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(el){
          if(el.tagName === 'IMG' && el.src) return el.src;
          var bg = window.getComputedStyle(el).backgroundImage;
          if(bg && bg !== 'none'){
            // extract url("...") content
            var m = bg.match(/url\(["']?(.*?)["']?\)/);
            if(m && m[1]) return m[1];
          }
        }
      }
      // fallback to storage
      var p = null;
      try { if(typeof loadProfileFromStorage === 'function') p = loadProfileFromStorage(); } catch(e){}
      if(!p) p = {
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('userAvatar') || localStorage.getItem('icity-avatar-src')
      };
      if(p && p.avatar) return p.avatar;
    } catch(e){}
    return null;
  }

  // Helper to determine if an avatar img belongs to current user (best-effort)
  function isAvatarForCurrentUser(imgEl){
    try {
      if(!imgEl) return false;
      var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : null;
      if(!p) p = { id: localStorage.getItem('myTopId'), name: localStorage.getItem('myTopName') };
      var authorId = imgEl.getAttribute('data-author-id') || (imgEl.dataset && imgEl.dataset.authorId) || null;
      var authorName = imgEl.getAttribute('data-author') || imgEl.getAttribute('data-author-name') || (imgEl.dataset && imgEl.dataset.author) || null;
      if(!authorId && !authorName){
        var anc = imgEl.closest('[data-author-id], [data-author], .moment, .post, .item');
        if(anc){
          authorId = authorId || anc.getAttribute('data-author-id') || anc.getAttribute('data-author');
          authorName = authorName || anc.getAttribute('data-author-name') || anc.getAttribute('data-author');
          if(!authorName){
            var authorNameNode = anc.querySelector('.author-name, .name, .post-author, .author');
            if(authorNameNode) authorName = (authorNameNode.textContent || '').trim();
          }
        }
      }
      if(p && p.id && authorId && String(p.id) === String(authorId)) return true;
      if(p && p.name && authorName && String((p.name||'').trim()) === String((authorName||'').trim())) return true;
      // Also check if img has attribute data-me or class 'me' etc
      if(imgEl.hasAttribute('data-me') || imgEl.classList.contains('me') || imgEl.classList.contains('self')) return true;
    } catch(e){}
    return false;
  }

  // Enforce top avatar on matching nodes
  function enforceTopAvatarOnNode(imgEl, topAvatar){
    try {
      if(!imgEl || !topAvatar) return;
      // Avoid touching nav icons: check ancestor tags that might be navbars
      var navAncestor = imgEl.closest('nav, .navbar, .bottom-nav, .footer');
      if(navAncestor) return; // don't modify nav images
      // Only enforce if this img seems like a moment/post avatar
      var selMatch = /(^|\s)(moment-avatar|avatar-img|author-avatar|post-avatar|item-avatar|my-avatar|top-avatar|author-avatar-img)(\s|$)/i;
      var classStr = imgEl.className || '';
      // If it looks like an avatar or is IMG inside .moment/.post, proceed
      var likelyAvatar = classStr && selMatch.test(classStr) || imgEl.closest('.moment, .post, .item, .comment') || imgEl.getAttribute('data-role') === 'avatar';
      if(!likelyAvatar) return;
      if(!isAvatarForCurrentUser(imgEl)) return;
      // If current src differs, set it
      if(imgEl.tagName === 'IMG'){
        if(imgEl.src !== topAvatar){
          try { imgEl.src = topAvatar; } catch(e){}
        }
      } else {
        try { imgEl.style.backgroundImage = "url('"+topAvatar+"')"; } catch(e){}
      }
      // mark as forced to avoid loops
      try { imgEl.setAttribute('data-avatar-forced','1'); } catch(e){}
    } catch(e){}
  }

  // Enforce across the document
  function enforceTopAvatarAll(topAvatar){
    if(!topAvatar) return;
    var selectors = ['.moment-avatar', '.post .avatar-img', '.post .author-avatar', '.item .avatar', '.comment .avatar', 'img[data-role="avatar"]', '.avatar-img'];
    selectors.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(img){
        enforceTopAvatarOnNode(img, topAvatar);
      });
    });
  }

  // Mutation observer to catch src changes and new nodes
  var observer = new MutationObserver(function(muts){
    try {
      var top = getTopAvatar();
      muts.forEach(function(m){
        try {
          if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'style' || m.attributeName === 'data-author-id' || m.attributeName === 'data-author')){
            var target = m.target;
            if(target && (target.tagName === 'IMG' || target.nodeType === 1)){
              enforceTopAvatarOnNode(target, top);
            }
          } else if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            m.addedNodes.forEach(function(node){
              try {
                if(node.nodeType !== 1) return;
                // find descendant avatar images
                var imgs = node.querySelectorAll && node.querySelectorAll('.moment-avatar, .avatar-img, img[data-role="avatar"], .author-avatar');
                if(imgs && imgs.length){
                  imgs.forEach(function(img){ enforceTopAvatarOnNode(img, top); });
                }
                // also if the node itself is an IMG
                if(node.tagName === 'IMG') enforceTopAvatarOnNode(node, top);
              } catch(e){}
            });
          }
        } catch(e){}
      });
    } catch(e){}
  });

  try {
    observer.observe(document.body, { attributes: true, childList: true, subtree: true, attributeFilter: ['src','style','data-author-id','data-author','data-author-name'] });
  } catch(e){}

  // Also run periodic enforcement for initial seconds to handle race conditions
  var enforcementRuns = 0;
  var enforcementTimer = setInterval(function(){
    try {
      enforcementRuns++;
      var top = getTopAvatar();
      if(top) enforceTopAvatarAll(top);
      // Try to update DB as well to persist
      try {
        if(top && typeof window.__updateProfileAndAvatars === 'function'){
          window.__updateProfileAndAvatars();
        }
      } catch(e){}
      if(enforcementRuns > 40) { // run ~40 times at 200ms => 8 seconds then stop
        clearInterval(enforcementTimer);
      }
    } catch(e){}
  }, 200);

  // Expose a function to explicitly bind list avatars to top avatar and optionally persist to DB
  window.bindMomentsAvatarsToTop = function(persistToDB){
    try {
      var top = getTopAvatar();
      if(!top) return;
      enforceTopAvatarAll(top);
      if(persistToDB){
        // try to update DB entries authorAvatar for current user
        try {
          var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : { id: localStorage.getItem('myTopId') };
          if(p && p.id && window.AppDB_Moments && window.AppDB_Moments.moments){
            if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.modify === 'function'){
              try { window.AppDB_Moments.moments.where('authorId').equals(p.id).modify(function(o){ o.authorAvatar = top; }); } catch(e){}
            } else if(typeof window.AppDB_Moments.moments.toArray === 'function'){
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item && item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = top;
                    try { if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item); } catch(e){}
                  }
                });
              }).catch(function(){});
            }
          }
        } catch(e){}
      }
    } catch(e){}
  };

  // Attempt immediate bind once loaded
  try { setTimeout(function(){ window.bindMomentsAvatarsToTop(true); }, 100); } catch(e){}

  // defensive cleanup if script re-inserted: no-op

})();
</script>

<!-- Remove/hide avatars in moments list while preserving top avatar -->
<script>
(function(){
  'use strict';

  function isTopAvatarElement(el){
    if(!el) return false;
    try {
      var topSelectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img'];
      for(var i=0;i<topSelectors.length;i++){
        var sel = topSelectors[i];
        if(el.matches && el.matches(sel)) return true;
        // Also check if el is inside an element that matches a top selector (e.g., wrapper)
        var wrapper = document.querySelector(sel);
        if(wrapper && (wrapper === el || wrapper.contains(el))) return true;
      }
      // common 'my-avatar' class on top - check if element has that class and is in header
      if(el.classList && el.classList.contains('my-avatar')){
        // check if inside header
        if(el.closest('header, .header, .profile-top, .topbar')) return true;
      }
    } catch(e){}
    return false;
  }

  function isInNavOrFooter(el){
    try {
      if(!el) return false;
      if(el.closest('nav, .navbar, .bottom-nav, .footer, footer, .tabbar')) return true;
    } catch(e){}
    return false;
  }

  function looksLikeListAvatar(el){
    try {
      if(!el) return false;
      // require it to be an IMG element or have data-role attribute
      if(el.tagName !== 'IMG' && !el.hasAttribute('data-role')) return false;
      // class-based heuristics
      var cls = (el.className || '').toLowerCase();
      if(cls.indexOf('moment-avatar') !== -1 || cls.indexOf('avatar-img') !== -1 || cls.indexOf('author-avatar') !== -1 || cls.indexOf('post-avatar') !== -1 || cls.indexOf('item-avatar') !== -1) return true;
      if(el.getAttribute('data-role') === 'avatar') return true;
      // check if inside a moment/post/list container
      if(el.closest('.moment, .post, .item, .comment, .feed, .timeline, .moments, #moments-screen')) return true;
    } catch(e){}
    return false;
  }

  function hideListAvatar(el){
    try {
      if(!el || el.dataset && el.dataset.avatarRemoved) return;
      // Safety: do not remove images inside nav/footer or top avatar
      if(isTopAvatarElement(el)) return;
      if(isInNavOrFooter(el)) return;
      if(!looksLikeListAvatar(el)) return;
      // hide visually but keep DOM to avoid breaking layouts
      el.style.setProperty('display','none','important');
      el.setAttribute('data-avatar-removed','1');
    } catch(e){}
  }

  function processAllPotentialAvatars(){
    try {
      // inspect all img elements once and hide those that look like list avatars
      Array.prototype.slice.call(document.querySelectorAll('img')).forEach(function(img){
        hideListAvatar(img);
      });
      // also elements with data-role='avatar' that are not IMG
      Array.prototype.slice.call(document.querySelectorAll('[data-role="avatar"]')).forEach(function(el){
        hideListAvatar(el);
      });
    } catch(e){}
  }

  // Observe DOM changes to hide newly created avatars
  var obs = new MutationObserver(function(muts){
    try {
      muts.forEach(function(m){
        if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
          m.addedNodes.forEach(function(node){
            try {
              if(node.nodeType !== 1) return;
              if(node.tagName === 'IMG') hideListAvatar(node);
              // find descendant imgs
              var imgs = node.querySelectorAll && node.querySelectorAll('img, [data-role="avatar"]');
              if(imgs && imgs.length){
                imgs.forEach(function(i){ hideListAvatar(i); });
              }
            } catch(e){}
          });
        } else if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'class' || m.attributeName === 'data-author-id')){
          var tgt = m.target;
          if(tgt && tgt.tagName === 'IMG') hideListAvatar(tgt);
        }
      });
    } catch(e){}
  });

  try {
    obs.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['src','class','data-author-id','data-author'] });
  } catch(e){}

  // Also intercept clicks on publish buttons to run processAllPotentialAvatars afterwards
  function attachPublishListener(){
    try {
      // heuristic selectors for publish buttons
      var selectors = ['button.publish','button[type="submit"]','.btn-publish','.publish-btn','#publish','.post-btn','.send','button[data-action="publish"]'];
      var found = false;
      selectors.forEach(function(sel){
        Array.prototype.slice.call(document.querySelectorAll(sel)).forEach(function(btn){
          try {
            if(btn._avatarHideAttached) return;
            btn.addEventListener('click', function(){
              setTimeout(processAllPotentialAvatars, 50);
            }, false);
            btn._avatarHideAttached = true;
            found = true;
          } catch(e){}
        });
      });
      // also attach a global delegation for any element with innerText '发布'
      if(!found){
        document.body.addEventListener('click', function(ev){
          try {
            var tgt = ev.target;
            if(!tgt) return;
            var text = (tgt.textContent || '').trim();
            if(text === '发布' || text === '发表' || text === '发送'){
              setTimeout(processAllPotentialAvatars, 50);
            }
          } catch(e){}
        }, true);
      }
    } catch(e){}
  }

  // Run initial pass
  try { setTimeout(processAllPotentialAvatars, 60); } catch(e){}
  try { setTimeout(attachPublishListener, 120); } catch(e){}

  // Expose control
  window.__removeListAvatars = function(){
    processAllPotentialAvatars();
  };

})();
</script>

<!-- Avatar fill patch: make avatar image fully fill its circular container (remove inner white gap) -->
<style>
/* Conservative selectors for avatar containers and images */
.icity-avatar-wrap, .avatar-wrap, .profile-avatar, .header-avatar, .my-avatar, .top-avatar, .avatar-circle, .avatar-holder {
  background: transparent !important;
  padding: 0 !important;
  border: 0 !important;
  overflow: hidden !important;
  border-radius: 50% !important;
  display: inline-block !important;
}

/* Ensure the img fills the container */
.icity-avatar-wrap img, .avatar-wrap img, .profile-avatar img, .header-avatar img, .my-avatar img, .top-avatar img, img.avatar-img, img[data-role="avatar"] {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
  border-radius: 50% !important;
  background: transparent !important;
  padding: 0 !important;
  margin: 0 auto !important;
}

/* If the container uses an inner padding element, hide it */
.icity-avatar-wrap .inner-avatar, .avatar-wrap .inner, .avatar-inner {
  display: none !important;
}
</style>

<script>
(function(){
  'use strict';
  // Target selectors to clean up inline styles or extra wrapper padding
  var containerSelectors = [
    '#icity-avatar', '.icity-avatar-wrap', '.avatar-wrap', '.profile-avatar', '.header-avatar', '.my-avatar', '.top-avatar', '.avatar-circle', '.avatar-holder'
  ];
  var imgSelectors = [
    '.icity-avatar-wrap img', '.avatar-wrap img', '.profile-avatar img', '.header-avatar img', '.my-avatar img', '.top-avatar img', 'img.avatar-img', 'img[data-role="avatar"]'
  ];

  function applyAvatarFillOnce(){
    try {
      containerSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            // Do not touch elements that are inside nav/footer to avoid breaking bottom nav
            if(el.closest && (el.closest('nav, .navbar, .bottom-nav, footer, .tabbar, .tab-bar'))) return;
            el.style.background = 'transparent';
            el.style.padding = '0';
            el.style.border = '0';
            el.style.overflow = 'hidden';
            el.style.borderRadius = '50%';
            // ensure width/height exist: if wrapper uses fixed px size, keep it
            // nothing else forced to avoid layout shifts
          } catch(e){}
        });
      });
      imgSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(img){
          try {
            if(img.closest && (img.closest('nav, .navbar, .bottom-nav, footer, .tabbar, .tab-bar'))) return;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.display = 'block';
            img.style.borderRadius = '50%';
            img.style.background = 'transparent';
            img.style.padding = '0';
            img.style.margin = '0 auto';
          } catch(e){}
        });
      });
    } catch(e){}
  }

  // Run on load and after small delay
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(applyAvatarFillOnce,50); });
  } else {
    setTimeout(applyAvatarFillOnce,50);
  }

  // Observe for dynamic changes to re-apply if new avatars are added
  try {
    var mo = new MutationObserver(function(muts){
      var applied = false;
      muts.forEach(function(m){
        try {
          if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            applied = true;
          } else if(m.type === 'attributes' && (m.attributeName === 'class' || m.attributeName === 'style' || m.attributeName === 'src')){
            applied = true;
          }
        } catch(e){}
      });
      if(applied) {
        // throttle a bit
        clearTimeout(window.__avatarFillTimer);
        window.__avatarFillTimer = setTimeout(applyAvatarFillOnce, 40);
      }
    });
    mo.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class','style','src'] });
  } catch(e){}

  // Expose for manual invocation
  try { window.__applyAvatarFill = applyAvatarFillOnce; } catch(e){}

})();
</script>

<!-- Moments 多选删除底部操作栏 -->
<div id="moments-multi-select-bar" class="multi-select-bar" aria-hidden="true">
  <div class="msb-left">
    <span id="moments-selected-count">已选择 0 项</span>
  </div>
  <div class="msb-right">
    <button id="moments-confirm-delete" class="danger">确认删除</button>
    <button id="moments-cancel-delete">取消</button>
  </div>
</div>

<script>
(function(){
  // State
  let isInMomentsDeleteMode = false;
  const selectedMomentIds = new Set();

  // Helpers to find DB
  const maybeDb = window.db || window.AppDB_Moments || (window.AppDB && window.AppDB.moments? window.AppDB : null);

  const momentsScreen = document.getElementById('moments-screen');
  const momentsContainer = document.getElementById('moments-list') || document.getElementById('moments-container') || document.getElementById('moments-list');
  const deleteBtn = document.getElementById('moments-delete-btn');
  const actionGroup = document.querySelector('#moments-screen .action-btn-group');
  const msBar = document.getElementById('moments-multi-select-bar');
  const msCount = document.getElementById('moments-selected-count');
  const msConfirm = document.getElementById('moments-confirm-delete');
  const msCancel = document.getElementById('moments-cancel-delete');
  const backBtn = document.querySelector('#moments-screen .back-btn');

  function updateCount(){
    msCount.textContent = '已选择 ' + selectedMomentIds.size + ' 项';
  }
  function enterDeleteMode(){
    if(isInMomentsDeleteMode) return;
    isInMomentsDeleteMode = true;
    if(momentsScreen) momentsScreen.classList.add('is-delete-mode');
    if(actionGroup) actionGroup.style.display = 'none';
    if(msBar) msBar.classList.add('show');
    selectedMomentIds.clear();
    document.querySelectorAll('.moment-item.is-selected').forEach(el=>el.classList.remove('is-selected'));
    updateCount();
  }
  function exitDeleteMode(){
    if(!isInMomentsDeleteMode) return;
    isInMomentsDeleteMode = false;
    if(momentsScreen) momentsScreen.classList.remove('is-delete-mode');
    if(actionGroup) actionGroup.style.display = '';
    if(msBar) msBar.classList.remove('show');
    selectedMomentIds.clear();
    document.querySelectorAll('.moment-item.is-selected').forEach(el=>el.classList.remove('is-selected'));
    updateCount();
  }

  // Click delete button to enter mode
  if(deleteBtn) deleteBtn.addEventListener('click', function(e){
    e.preventDefault();
    enterDeleteMode();
  });

  // Cancel
  if(msCancel) msCancel.addEventListener('click', function(e){
    e.preventDefault();
    exitDeleteMode();
  });

  // Container delegation for selecting items
  if(momentsContainer){
    momentsContainer.addEventListener('click', function(e){
      if(!isInMomentsDeleteMode) return;
      // find closest .moment-item
      let el = e.target;
      while(el && !el.classList.contains('moment-item')) el = el.parentElement;
      if(!el) return;
      e.preventDefault(); e.stopPropagation();
      const id = el.dataset && el.dataset.id;
      if(!id) return;
      if(selectedMomentIds.has(id)){
        selectedMomentIds.delete(id);
        el.classList.remove('is-selected');
      } else {
        selectedMomentIds.add(id);
        el.classList.add('is-selected');
      }
      updateCount();
    }, true);
  }

  // Confirm delete
  if(msConfirm){
    msConfirm.addEventListener('click', async function(e){
      e.preventDefault();
      if(selectedMomentIds.size === 0){
        alert('未选择项目');
        return;
      }
      if(!confirm('确定删除选中的 ' + selectedMomentIds.size + ' 条动态？此操作不可撤销')) return;
      const ids = Array.from(selectedMomentIds);
      try {
        if(maybeDb && maybeDb.moments && typeof maybeDb.moments.bulkDelete === 'function'){
          await maybeDb.moments.bulkDelete(ids);
        } else if(maybeDb && maybeDb.moments){
          // fallback: delete one by one
          for(const id of ids){
            try{ await maybeDb.moments.delete(id); }catch(e){}
          }
        } else if(window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.bulkDelete === 'function'){
          await window.AppDB_Moments.moments.bulkDelete(ids);
        } else {
          console.warn('No Dexie moments DB found for deletion');
        }
        // refresh render if available
        if(typeof renderMoments === 'function') try{ await renderMoments(); }catch(e){}
        if(typeof window.renderMomentsSafe === 'function') try{ await window.renderMomentsSafe(); }catch(e){}
        exitDeleteMode();
        alert('删除成功');
      } catch (err){
        console.error('批量删除失败', err);
        alert('删除失败，请查看控制台。');
      }
    });
  }

  // Back button behavior
  if(backBtn){
    backBtn.addEventListener('click', function(e){
      if(isInMomentsDeleteMode){
        e.preventDefault();
        exitDeleteMode();
      }
    });
  }

})();
</script>

<!-- 覆盖：确保 moment 图片描述卡的底色与文字颜色生效（放在文件末尾以覆盖所有样式） -->
<style>
.moment-image-desc-card {
  background: #eef0f3 !important; /* 浅灰底色 - 覆盖原有渐变 */
  border: 6px solid #ffffff !important;
  box-shadow: 0 6px 20px rgba(10,10,20,0.06) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;

  padding: 12px 14px !important;
  margin-top: 6px !important;
  min-height: 86px !important;
}
.moment-image-desc-card .desc-content { font-size: 13px !important; }

.moment-image-desc-card .desc-content,
.moment-image-desc-card p.desc-content {
  color: #66676b !important;
  background: transparent !important;
}
/* 如果存在内层容器，确保去掉其背景并使用浅灰色 */
.moment-image-desc-card > .inner,
.moment-image-desc-card > .card-inner,
.moment-image-desc-card > .content {
  background: transparent !important;
}
</style>



<!-- 覆盖：移除卡片内所有文字阴影，确保描述文字不带阴影 -->
<style>
.moment-image-desc-card, 
.moment-image-desc-card *,
.moment-image-desc-card .desc-content,
.moment-image-desc-card .description,
.moment-image-desc-card .image-desc,
.moment-image-desc-card .desc {
  text-shadow: none !important;
  -webkit-text-shadow: none !important;
  filter: none !important;
}
</style>


<!-- Modal layout fixes: align action buttons and tighten image checkbox spacing -->
<style>
/* Try to scope to likely modal/dialog containers without touching other buttons */
/* If your modal has a specific id or class, replace .publish-modal below with it. */
.publish-modal, .publish-dialog, .moment-publish-modal, .dialog-publish, .publishBox {
  /* ensure modal content uses flex column so footer aligns correctly */
  display: block;
}

/* Make the actions row use flex so buttons are equal size and aligned */
.publish-modal .actions,
.publish-dialog .actions,
.moment-publish-modal .actions,
.dialog-publish .actions,
.publishBox .actions,
.publish-actions {
  display: flex !important;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 0 !important;
}

/* Ensure buttons inside actions share equal width and similar height */
.publish-modal .actions button,
.publish-dialog .actions button,
.moment-publish-modal .actions button,
.dialog-publish .actions button,
.publishBox .actions button,
.publish-actions button {
  flex: 1 1 0;
  max-width: none;
  min-width: 0;
  height: 52px;
  border-radius: 12px;
  font-weight: 600;
  padding: 0 16px;
  box-sizing: border-box;
}

/* Make the cancel button visually secondary if needed */
.publish-modal .actions .cancel,
.publish-dialog .actions .cancel,
.publishBox .actions .cancel,
.publish-actions .cancel {
  background: #bfe6ff; /* light blue like your screenshot */
  color: #fff;
}

/* Publish button primary color */
.publish-modal .actions .primary,
.publish-dialog .actions .primary,
.publishBox .actions .primary,
.publish-actions .primary {
  background: #ff95bf; /* pink from screenshot */
  color: #fff;
}

/* Tighten spacing for the "add image" checkbox area */
.add-image-row, .add-image, .image-checkbox, .add-photo, .add-picture {
  margin-top: 6px !important;
  margin-bottom: 6px !important;
  display: flex !important;
  gap: 8px;
  align-items: center;
}

/* If checkbox itself has large margin, reduce it */
.add-image-row input[type="checkbox"],
.image-checkbox input[type="checkbox"],
.add-photo input[type="checkbox"] {
  margin: 0 !important;
  transform: scale(1.05);
}

/* Small screens: keep buttons stacked but full-width with proper gap */
@media (max-width: 420px) {
  .publish-modal .actions,
  .publish-dialog .actions,
  .moment-publish-modal .actions,
  .dialog-publish .actions,
  .publishBox .actions,
  .publish-actions {
    flex-direction: column;
  }
  .publish-modal .actions button,
  .publish-dialog .actions button,
  .moment-publish-modal .actions button,
  .dialog-publish .actions button,
  .publishBox .actions button,
  .publish-actions button {
    width: 100%;
  }
}
</style>


<!-- Precise fixes for the 发布动态 form: equalize buttons and tighten checkbox spacing -->
<style>
/* Scope strictly to the post form to avoid affecting other UIs */
#post-form { font-family: inherit; }

/* Find the action container which uses inline flex; ensure children buttons take equal space */
#post-form > div[style*="display:flex"] {
  display: flex !important;
  gap: 10px !important;
  margin-top: 12px !important;
  align-items: stretch !important;
}

/* Make buttons equal width, same height, and matching radius */
#post-form > div[style*="display:flex"] .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  height: 52px !important;
  padding: 0 16px !important;
  border-radius: 12px !important;
  box-sizing: border-box !important;
  font-weight: 600 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* If there are specific modifier classes, ensure colors remain similar to your theme */
#post-form > div[style*="display:flex"] .btn-sec { background: #bfe6ff !important; color: #fff !important; border: none !important; }
#post-form > div[style*="display:flex"] .btn-primary { background: #ff95bf !important; color: #fff !important; border: none !important; }

/* Tighten the "添加图片" checkbox row */
#post-form .form-group label {
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  margin-top: 6px !important;
  cursor: pointer;
}

#post-form #add-image {
  margin: 0 !important;
  transform: scale(1.05) !important;
  vertical-align: middle !important;
}

/* Ensure image input group sits closer */
#image-input-group { margin-top: 8px !important; margin-bottom: 6px !important; }

/* Small screens: stack buttons but keep spacing */
@media (max-width: 420px) {
  #post-form > div[style*="display:flex"] { flex-direction: column !important; }
  #post-form > div[style*="display:flex"] .btn { width: 100% !important; }
}
</style>


<!-- Fix: keep '添加图片' label on one line and allow it to lay out horizontally -->
<style>
/* Prevent the label text from wrapping and ensure layout is inline */
#post-form .form-group label {
  white-space: nowrap !important;
  flex-wrap: nowrap !important;
  width: auto !important;
}

/* If any spans inside the label are forced to block, make them inline */
#post-form .form-group label span,
#post-form .form-group label b,
#post-form .form-group label i {
  display: inline !important;
}

/* Allow the label to take available horizontal space so text doesn't collapse */
#post-form .form-group {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}
</style>
<!-- 在 </body> 之前添加 -->
<div id="mention-panel" class="mention-panel"></div>
<!-- ... (El resto de los scripts y styles finales) ... -->
</body>

</html>