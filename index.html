<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>章鱼喷墨机</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>

    <style>
        /* --- 全局与主题样式 --- */
        :root {
            --bg-color: #fce4ec;
            --primary-color: #ff80ab;
            --secondary-color: #f48fb1;
            --accent-color: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #fce4ec, #f8bbd0);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .phone-screen {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            max-height: 850px;
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .app-header .back-btn,
        .app-header .action-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .app-header .action-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .action-btn-group .action-btn {
            font-size: 16px;
            font-weight: 600;
            width: auto;
            padding: 6px 12px;
            border-radius: 10px;
        }

        .app-header .action-btn-group #create-group-btn {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .app-header .action-btn-group #add-chat-btn {
            font-size: 28px;
            padding: 0;
            width: 40px;
            height: 40px;
            background-color: transparent;
            color: var(--primary-color);
            border-radius: 50%;
        }

        .app-header .action-btn img {
            width: 28px;
            height: 28px;
        }

        .app-header .title-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-header .title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .app-header .subtitle {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            margin-top: 2px;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        .app-header .placeholder {
            width: 40px;
        }

        #home-screen {
            justify-content: space-between;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            padding: 50px 0;
        }

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 30px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .dock {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            margin: 0 20px;
            min-height: 10px;
            gap: 15px;
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.4s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #chat-list-screen .content,
        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: #fdf6f8;
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 14px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-bottom: 10px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
            align-items: flex-start;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }

        .message-bubble {
            max-width: 260px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.4;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            font-size: 15px;
        }

        .message-bubble.sent {
            border-bottom-right-radius: 5px;
        }

        .message-bubble.received {
            border-bottom-left-radius: 5px;
        }

        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .image-bubble {
            max-width: 120px;
            border-radius: var(--border-radius);
            margin: 0 8px;
            padding: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .image-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: calc(var(--border-radius) - 4px);
        }

        .message-wrapper.sent .image-bubble {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .image-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-bottom-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .voice-bubble .duration {
            font-size: 13px;
            margin: 0 8px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .pv-card {
            width: 230px;
            aspect-ratio: 1 / 1;
            background-color: #f0f0f0;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            margin: 0 8px;
        }

        .message-wrapper.sent .pv-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .pv-card {
            border-bottom-left-radius: 5px;
        }

        .pv-card-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 0.5s ease-in-out;
            z-index: 2;
        }

        .pv-card-image-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pv-card-content {
            padding: 15px;
            height: 100%;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            background-color: white;
            position: relative;
            z-index: 1;
        }

        .pv-card-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
            color: white;
            padding: 20px 10px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        .pv-card-footer.hidden {
            opacity: 0;
        }

        .pv-card-footer svg {
            width: 14px;
            height: 14px;
            fill: white;
            flex-shrink: 0;
        }

        .transfer-card {
            width: 240px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-bottom-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 20px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }
        /* --- 在 <style> 标签内添加 --- */

/* --- 动态删除模式下的按钮样式调整 --- */
#moments-screen.is-delete-mode .app-header #moments-delete-btn {
    color: var(--primary-color);
    font-weight: 600;
}
#moments-screen.is-delete-mode .app-header #moments-delete-btn::before {
    content: "取消"; /* 将“删除”文字替换为“取消” */
}
#moments-screen.is-delete-mode .app-header #moments-delete-btn {
    font-size: 0; /* 隐藏原始的“删除”文字 */
}

/* 底部多选操作栏的样式 */
#moments-multi-select-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    padding: 10px 20px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    border-top: 1px solid #eee;
    z-index: 200;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transform: translateY(100%);
    transition: transform 0.3s ease-out;
}
#moments-multi-select-bar.show {
    transform: translateY(0);
}
#moments-multi-select-bar button {
    padding: 8px 16px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-size: 14px;
}
#moments-multi-select-bar #moments-confirm-delete {
    background-color: #ef5350;
    color: white;
}
#moments-multi-select-bar #moments-cancel-delete {
    background-color: #e0e0e0;
    color: #333;
}
      
#diary-screen .content {
    padding: 10px;
}
.diary-entry {
    background-color: #fff8fa;
    border-radius: var(--border-radius);
    padding: 15px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: 4px solid var(--primary-color);
}
.diary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.diary-date {
    font-size: 14px;
    font-weight: 600;
    color: var(--secondary-color);
}
.diary-actions button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    margin-left: 8px;
}
.diary-actions button svg {
    width: 20px;
    height: 20px;
    fill: #aaa;
    transition: fill 0.2s ease, transform 0.2s ease;
}
.diary-actions button:hover svg {
    fill: var(--primary-color);
    transform: scale(1.1);
}
.diary-actions button.favorited svg {
    fill: #fbc02d; /* 收藏后的金色 */
}
.diary-content {
    font-size: 15px;
    line-height: 1.7;
    color: var(--text-color);
    white-space: pre-wrap; /* 保留日记中的换行 */
    word-wrap: break-word;
}

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 0 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-bottom-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card-description {
            font-size: 14px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }
        .file-card {
            width: 240px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            margin: 0 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .file-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .file-card {
            border-bottom-left-radius: 5px;
        }
        .file-card-icon {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }
        .file-card-info {
            overflow: hidden;
            flex-grow: 1;
        }
        .file-card-name {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 0 4px 0;
        }
        .file-card-size {
            font-size: 12px;
            color: #888;
            margin: 0;
        }
                .location-card {
            width: 250px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .location-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .location-card {
            border-bottom-left-radius: 5px;
        }
        .location-card-info {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .location-main {
            font-size: 16px;
            color: #222;
            margin: 0 0 4px 0;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-detail {
            font-size: 12px;
            color: #888;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-map {
            width: 100%;
            height: 140px;
            background-size: cover;
            background-position: center;
            background-image: url('https://i.postimg.cc/L8gYhF4Q/share-image-1755433372879-edit-155975507275678.jpg'); /* Placeholder map image */
        }
        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
    flex-shrink: 0;
    padding: 0 10px 5px;
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    overflow-x: auto; /* 新增：允许横向滚动 */
    /* 以下为可选代码，用于在某些浏览器上隐藏滚动条，但保留滚动功能 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}




/* --- 恢复图标栏的左右滑动功能 --- */
#sticker-bar {
    flex-shrink: 0;
    padding: 5px 10px; /* 左右留出一些边距 */
    display: flex;
    align-items: center;
    gap: 0px; /* 设置图标之间的固定间距 */
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);

    /* 核心改动：允许X轴（横向）滚动 */
    overflow-x: auto; 
    overflow-y: hidden; /* 禁止垂直方向滚动 */

    /* 以下代码是为了在视觉上隐藏滚动条，但保留滚动功能，让界面更美观 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}

#sticker-bar::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

#sticker-bar .sticker-bar-btn {
    padding: 5px; /* 减小按钮的内边距，让它本身更小 */
    margin: 0; /* 移除所有按钮可能存在的外边距 */
    background: none;
    border: none;
    cursor: pointer;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
}

#sticker-bar .sticker-bar-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

#sticker-bar .sticker-bar-btn svg {
    width: 24px;  /* 关键：适当缩小图标本身的大小以适应空间 */
    height: 24px;
    fill: #888; /* 确保所有图标都有一个统一的默认颜色 */
}

/* 如果特定按钮有额外样式，比如背景色，可以单独设置 */
#rollback-btn {
    /* 保持默认的背景，或者可以设置一个更亮的颜色 */
    background: rgba(0, 0, 0, 0.03); /* 稍微有点背景色，但保持间距 */
    border-radius: 50%; /* 保持圆形 */
}
#rollback-btn:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 28px;
            height: 28px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35%;
            max-height: 250px;
            background: #f7f7f7;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 15px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 10px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .message-input-area input {
            flex-grow: 1;
            border: none;
            padding: 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 18px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #fce4ec;
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .form-group.radio-group label {
            margin-bottom: 0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(255, 128, 171, 0.5);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            margin-bottom: 15px;
        }

        .btn-secondary:hover {
            background-color: #64b5f6;
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.5);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 25px;
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* --- Group Chat Specific Styles --- */
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        #customize-screen .icon-details input {
            width: calc(100% - 70px);
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* --- Tutorial Screen Styles --- */
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            /* A large value to ensure it expands to fit the content */
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
     /* --- Voice Call Styles --- */
.sticker-bar-btn#voice-call-btn {
    display: none; /* Initially hidden, shown only in private chats */
}

#voice-call-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 300;
    display: none;
    flex-direction: column;
    /* 修改: 不再垂直居中，改为从顶部开始排列元素 */
    justify-content: flex-start; 
    align-items: center;
    color: white;
    text-align: center;
    padding: 20px;
    animation: fadeIn 0.3s ease;
}

#voice-call-overlay.visible {
    display: flex;
}

.call-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 20px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    /* 修改: 增加顶部外边距，让头像不会紧贴屏幕顶部 */
    margin-top: 40px; 
    flex-shrink: 0; /* 防止在flex布局中被压缩 */
}

.call-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.call-status {
    font-size: 16px;
    color: #ccc;
    min-height: 24px;
    flex-shrink: 0;
}

/* 来电/去电时的按钮组样式保持不变 */
.call-button-group {
    position: absolute;
    bottom: 80px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    background: none;
    border: none;
    color: white;
}
.call-button .icon-wrapper {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}
.call-button svg {
    width: 36px;
    height: 36px;
    fill: white;
}
.call-button.decline .icon-wrapper {
    background-color: #ef5350;
}
.call-button.accept .icon-wrapper {
    background-color: #4CAF50;
}

/* --- 通话中界面的核心修改 --- */
#active-call-view {
    display: none;
    flex-direction: column;
    width: 100%;
    /* 修改: 让此视图填满父容器（#voice-call-overlay）的剩余空间 */
    flex-grow: 1; 
    min-height: 0; /* flex布局技巧，防止内部元素溢出 */
}

/* 隐藏之前版本添加的、现在不需要的顶部固定header */
#active-call-header {
    display: none !important;
}

/* 文字聊天面板（图片中橙色框区域） */
#call-transcript-area {
    flex-grow: 1; /* 占据 #active-call-view 内的所有可用垂直空间 */
    overflow-y: auto; /* 当内容超出时，允许滚动 */
    padding: 10px;
    margin-top: 15px; /* 与顶部的状态计时器保持一定间距 */
    margin-bottom: 15px; /* 与下方的挂断按钮保持一定间距 */
    font-size: 15px;
    line-height: 1.7;
    -webkit-overflow-scrolling: touch; /* 优化在移动设备上的滚动体验 */
    text-align: left; /* 聊天内容左对齐，更易于阅读 */
}
.call-transcript-line {
    margin-bottom: 12px;
}
.call-transcript-line .action {
    color: #aaa;
    font-style: italic;
}
.call-transcript-line .dialog {
    color: #fff;
}

/* 底部操作区（挂断按钮和输入框） */
#hangup-button-container {
    position: static; /* 移除绝对定位，使其成为flex布局的一部分 */
    padding: 10px 0;
    flex-shrink: 0; /* 防止被压缩 */
}
#call-input-area {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    width: 100%;
    flex-shrink: 0;
}
#call-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
#call-input::placeholder {
    color: #ccc;
}
#send-call-message-btn {
    background: var(--primary-color);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    color: white;
    font-size: 18px;
    flex-shrink: 0;
}

/* --- 音乐播放器弹窗样式 --- */
#music-player-modal .modal-window {
    width: 90%;
    max-width: 360px;
    padding: 0; /* 移除内边距，方便自定义布局 */
    overflow: hidden;
    background: #fafafa;
}
.music-player-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #eee;
}
.music-player-header .song-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
}
.music-player-header .share-btn {
    width: 24px; height: 24px; fill: #888;
}
.music-player-body {
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.music-album-art {
    width: 180px;
    height: 180px;
    border-radius: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    margin-bottom: 25px;
}
.music-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin-top: 20px;
}
.music-controls button {
    background: none;
    border: none;
    cursor: pointer;
}
.music-controls .play-btn svg {
    width: 60px; height: 60px;
}
.music-controls .side-btn svg {
    width: 32px; height: 32px;
}
.music-extra-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 15px 25px;
}
.music-extra-controls button {
     background: none; border: none; cursor: pointer;
}
.music-extra-controls svg {
    width: 26px; height: 26px; fill: #555;
}
.lyrics-panel-placeholder {
    height: 60px; /* 歌词面板占位 */
    width: 100%;
    background: #f0f0f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #aaa;
    margin-top: 15px;
}
/* --- 歌词面板样式 (新添加) --- */
.lyrics-panel {
    width: 100%;
    height: 60px; /* 固定高度 */
    margin-top: 15px;
    overflow: hidden; /* 隐藏容器外部的内容 */
    text-align: center;
    position: relative;
    -webkit-mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
    mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
}
.lyrics-panel-inner {
    transition: transform 0.5s ease-out; /* 平滑滚动效果 */
}
.lyric-line {
    margin: 0;
    padding: 4px 0;
    font-size: 15px;
    color: #888;
    line-height: 1.5;
    transition: all 0.3s ease;
}
.lyric-line.active {
    color: var(--primary-color);
    font-weight: 600;
    font-size: 16px;
    transform: scale(1.05);
}
/* --- 音乐分享卡片样式 --- */
.music-card {
    width: 240px;
    background-color: #fff;
    border-radius: var(--border-radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    margin: 0 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    border: 1px solid #eee;
}
.message-wrapper.sent .music-card {
    border-bottom-right-radius: 5px;
}
.message-wrapper.received .music-card {
    border-bottom-left-radius: 5px;
}
.music-card-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    object-fit: cover;
}
.music-card-info {
    overflow: hidden;
    flex-grow: 1;
}
.music-card-title {
    font-size: 15px;
    font-weight: 500;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0 0 4px 0;
}
.music-card-artist {
    font-size: 12px;
    color: #888;
    margin: 0;
}
/* === 可缩放变量（作用域：仅聊天室屏幕） === */
#chat-room-screen {
  --bubble-scale: 1;
  --bubble-font-base: 15px;
}
#chat-room-screen .message-area {
  font-size: calc(var(--bubble-font-base) * var(--bubble-scale));
}
#chat-room-screen .message-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  max-width: calc(260px * var(--bubble-scale)) !important;
}
#chat-room-screen .system-notification-bubble {
  font-size: 0.8em !important;
  padding: 0.4em 0.67em !important;
}
#chat-room-screen .voice-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  min-width: calc(90px * var(--bubble-scale)) !important;
  max-width: calc(200px * var(--bubble-scale)) !important;
}
#chat-room-screen .voice-bubble .duration { font-size: 0.87em !important; }
#chat-room-screen .image-bubble { max-width: calc(120px * var(--bubble-scale)) !important; }
#chat-room-screen .pv-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .transfer-card { width: calc(240px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card-description,
#chat-room-screen .voice-transcript {
  font-size: 0.93em !important;
  line-height: 1.6;
}
#chat-room-screen .message-bubble,
#chat-room-screen .voice-bubble,
#chat-room-screen .pv-card,
#chat-room-screen .transfer-card,
#chat-room-screen .gift-card {
  border-radius: calc(var(--border-radius) * var(--bubble-scale)) !important;
}

/* DEBUG FIXES: ensure active screen uses flex and phone-screen is positioned */
.phone-screen { position: relative !important; }
.screen { display: none !important; }
.screen.active { display: flex !important; }
.modal-overlay { position: absolute !important; }


/* --- moment image description card (injected) --- */
.moment-image-desc-card {
  background: linear-gradient(135deg, rgba(238, 156, 167, 0.3), rgba(255, 221, 225, 0.3)); /* 半透明粉色渐变背景 */
  border-radius: 10px;
  padding: 12px 14px;
  margin-top: 6px;
  color: #fff;
  position: relative;
  overflow: hidden;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  /* min-height: 86px; */
  display: flex;
  align-items: center;
  cursor: pointer;
  backdrop-filter: blur(10px); /* 关键：毛玻璃模糊效果 */
  -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
  border: 1px solid rgba(255, 255, 255, 0.3); /* 增加玻璃质感边框 */
}


/* === 覆盖：仅改变卡片外框与配色（保留原文件卡片形状/布局/标题） === */
.moment-image-desc-card {
  /* 不改 width/height/border-radius/padding 等布局属性，保障原样式形状不变 */
  border: 6px solid #ffffff;
  box-shadow: 0 6px 20px rgba(10, 10, 20, 0.06);
  background: transparent !important;
}

/* 内层浅灰面板（只在存在内层类时覆盖背景色） */
.moment-image-desc-card .inner {
  background: #eef0f3 !important;
}

/* 将参考图中“标题色”应用到图片描述文字上：#66676b */
.moment-image-desc-card .desc-content,
  .moment-image-desc-card .description,
  .moment-image-desc-card .image-desc {
  color: #66676b !important;
}

/* 小屏微调（不改变布局） */
@media (max-width: 420px) {
  .moment-image-desc-card { box-shadow: 0 4px 14px rgba(10,10,20,0.05); }
}

/*
.moment-image-desc-card::before {
  content: '';
  position: absolute;
  inset: -12px;
  background: inherit;
  filter: blur(10px);
  transform: scale(1.08);
  z-index: 1;
  opacity: 0.95;
}
*/
.moment-image-desc-card .desc-content {
  position: relative;
  z-index: 2;
  font-style: italic;
  text-shadow: 0 1px 3px rgba(0,0,0,0.45);
  line-height: 1.4;
  font-size: 13px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  /* -webkit-line-clamp: 4; */
  overflow: hidden;
  word-break: break-word;
  /* max-height: calc(1.4em * 4); */
}
@media (max-width: 420px) {
  .moment-image-desc-card { padding: 9px; /* min-height: 72px; */ }
  .moment-image-desc-card .desc-content { /* -webkit-line-clamp: 3; */ }
}/* --- 钱包功能新增样式 --- */
.wallet-balance-card {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
    padding: 25px;
    border-radius: var(--border-radius);
    text-align: center;
    margin-bottom: 30px;
    box-shadow: 0 8px 25px rgba(255, 128, 171, 0.3);
}
.wallet-balance-label {
    margin: 0 0 10px 0;
    font-size: 16px;
    opacity: 0.9;
}
.wallet-balance-amount {
    margin: 0;
    font-size: 42px;
    font-weight: 600;
}
.wallet-actions-list {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    overflow: hidden;
}
.wallet-action-item {
    padding: 18px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 16px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
}
.wallet-action-item:last-child {
    border-bottom: none;
}
.wallet-action-item:hover {
    background-color: #fdf6f8;
}

/* 交易明细样式 */
.transaction-item {
    display: flex;
    justify-content: space-between;
    padding: 12px 5px;
    border-bottom: 1px solid #f0f0f0;
}
.transaction-details {
    display: flex;
    flex-direction: column;
}
.transaction-description {
    font-weight: 500;
    color: #333;
}
.transaction-timestamp {
    font-size: 12px;
    color: #999;
    margin-top: 4px;
}
.transaction-amount {
    font-weight: bold;
    font-size: 16px;
}
.transaction-amount.expense {
    color: #333;
}
.transaction-amount.income {
    color: #4CAF50; /* 收入用绿色表示 */
}
/* --- HTML小剧场样式修复与美化 --- */
.ai-generated-theater {
    max-width: 90%; /* 限制最大宽度，防止内容溢出屏幕 */
    margin: 0 8px;   /* 与头像保持合适的间距 */
    padding: 5px;    /* 添加一点内边距，让内容不要紧贴边缘 */
    border-radius: var(--border-radius);
    overflow: hidden; /* 确保内部元素的圆角效果正确 */
    box-sizing: border-box;
}

/* 确保小剧场在发送方和接收方位置正确 */
.message-wrapper.sent .ai-generated-theater {
    align-self: flex-end;
}
.message-wrapper.received .ai-generated-theater {
    align-self: flex-start;
}
/* --- AI空间对话气泡样式修复与美化 (AI Space Bubble Fix & Styling) --- */

/* 核心：为“对方”的消息（received）定义样式 */
#ai-message-area .message-wrapper.received .message-bubble {
    /* 1. 强制为对方消息添加一个默认的灰色气泡背景，解决“没有气泡”的问题 */
    background-color: #f0f0f0;
    color: #333;

    /* 2. 将气泡设置为椭圆形，并移除尖角 */
    border-radius: 20px; /* 您可以调整这个值来改变椭圆的圆润程度 */
}

/* 确保主视角AI自己发送的消息（sent）也有默认的粉色气泡（以防万一） */
#ai-message-area .message-wrapper.sent .message-bubble {
    background-color: var(--primary-color);
    color: white;
    border-radius: 20px;
    border-bottom-right-radius: 5px; /* 依然可以保留自己消息的尖角，如果想去掉也改成20px即可 */
}

/* 对于HTML小剧场等特殊内容，确保它们在AI空间也能正常显示 */
#ai-message-area .ai-generated-theater {
    max-width: 90%;
    margin: 0 8px;
}

    </style>
    <!-- === moments 固定在 phone-screen 内的修复样式 (自动插入补丁) === -->
<style>
/* 确保 phone-screen 做为裁切容器 */
.phone-screen {
  position: relative !important;
  overflow: hidden !important; /* 防止子元素跑出可视区 */
}

/* 把所有 screen 统一做绝对铺满，这样切换只影响可见性，不会改变布局流 */
.screen {
  position: absolute !important;
  inset: 0; /* top:0; right:0; bottom:0; left:0; */
  display: none !important;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* 激活的 screen 可见 */
.screen.active {
  display: flex !important;
}

/* 确保 screen 中的主内容区单独可滚动（不会把整个 screen 推出） */
.screen .content {
  overflow-y: auto !important;
  height: 100%;
  box-sizing: border-box;
}

/* 为动态页面的底部导航栏预留空间 */
#moments-screen .content {
    padding-bottom: 88px !important;
}

/* 防止 moments 页面被某些 transform/translate 推出视窗（保底） */
#moments-screen {
  transform: none !important;
  will-change: auto !important;
}

/* --- 调整右上角按钮组的间距 --- */
.app-header .action-btn-group {
    gap: 2px; /* 将按钮间的默认间距从 10px 减小到 4px */
}
/* --- 将回忆图标移动到标题栏最右侧 --- */
.app-header .action-btn-group #ai-memories-btn {
    order: 99;
}
/* --- 新的音乐播放器小部件样式（唱片机） --- */
.record-player-widget {
    /*
     * ===============================================
     * == 在这里自定义您的图片 URL ==
     * ===============================================
     * --record-sleeve-image: 替换为您想要的方形“唱片封套”图片。
     * --record-label-image:  替换为您想要的圆形“唱片标签”图片。
    */
    --record-sleeve-image: url('https://i.postimg.cc/KzC3q4w3/image.png'); /* 示例：带猫爪的半透明封面 */
    --record-label-image: url('https://i.postimg.cc/nzP9sgxr/chan-125.png');  /* 示例：动漫头像 */

    /* 使用变量控制整体大小 */
    --music-widget-scale: 1.3;
    
    position: relative;
    width: calc(130px * var(--music-widget-scale));
    height: calc(130px * var(--music-widget-scale));
    margin: 20px auto 15px auto;
    cursor: pointer;
}

.record-player-widget .record-sleeve {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 100%;
    height: 100%;
    background-image: var(--record-sleeve-image);
    background-size: cover;
    background-position: center;
    background-color: rgba(255, 255, 255, 0.7); /* 图片加载失败时的底色 */
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.record-player-widget .vinyl-record {
    position: absolute;
    top: 50%;
    right: -20%; /* 让唱片从右侧伸出 */
    transform: translateY(-50%);
    width: 100%;
    height: 100%;
    background-color: #1a1a1a; /* 黑胶唱片的颜色 */
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    transition: transform 0.4s ease;
}

.record-player-widget:hover .vinyl-record {
    transform: translateY(-50%) translateX(8px); /* 鼠标悬浮时唱片向右移动 */
}

.record-player-widget .record-label {
    width: 70%;
    height: 70%;
    background-image: var(--record-label-image);
    background-size: cover;
    background-position: center;
    background-color: #fff; /* 图片加载失败时的底色 */
    border-radius: 50%;
    border: 2px solid #333; /* 标签周围的深色环 */
}
</style>


<!-- === /patch === -->

<style>
/* z-index and stacking safety to ensure bottom nav and modals stay on top */
.screen { z-index: 0 !important; }
.screen.active { z-index: 1 !important; }
.bottom-nav { z-index: 200 !important; } /* ensure bottom nav overlays feed */
.modal-overlay, .action-sheet-overlay, .context-menu { z-index: 300 !important; }
#moments-screen { z-index: 0 !important; } /* keep moments below nav/modals by default */
/* --- 修复：论坛页面顶部导航栏遮挡内容 --- */
#forum-screen .content,
#forum-thread-screen .content {
    padding-top: 60px; /* 为固定的导航栏留出空间，您可以根据实际高度微调这个数值 */
}
/* === 新版：主页一体化个人信息卡片样式 === */
#home-screen {
    justify-content: flex-start;
    padding-top: 30px;
}

.home-profile-header {
    width: calc(100% - 40px); /* 左右留20px边距 */
    margin: 0 auto; /* 居中 */
    position: relative;
    background-color: var(--white-color);
    border-radius: 18px; /* 统一的圆角 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.07); /* 统一的阴影 */
    overflow: visible; /* 允许头像溢出 */
}

.home-hero {
    height: 160px;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    border-radius: 18px 18px 0 0; /* 只给顶部设置圆角 */
}

.home-avatar-wrap {
    position: absolute;
    top: 160px; /* 定位在背景图的下边缘 */
    left: 50%;
    transform: translate(-50%, -50%); /* 精确居中 */
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid var(--white-color);
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
    z-index: 5;
}

#home-profile-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

.home-info-card {
    padding: 50px 20px 20px; /* 顶部留出头像空间，底部缩小间距 */
    text-align: center;
}

.home-profile-name {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}

.home-profile-signature {
    font-size: 14px;
    color: #888;
    margin: 0;
}

#home-screen .main-content-area {
    margin-top: -5px; /* 确保与卡片底部有10px间距 */
}
/* === 样式结束 === */
</style>
<!-- === /zindex-patch === -->
</head>

<body>
<div class="phone-screen">
	<!-- 在 <div class="phone-screen"> 之后添加 -->
<div id="global-notification-banner" class="notification-banner">
    <img id="notification-avatar" src="" alt="avatar">
    <div id="notification-text"></div>
    <button id="notification-close-btn">&times;</button>
</div>
    <div id="home-screen" class="screen active"></div>
    <div id="chat-list-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">聊天</h1>
            </div>
            <div class="action-btn-group">
                <button class="action-btn" id="create-group-btn">群聊</button>
                <button class="action-btn" id="add-chat-btn">+</button>
            </div>
        </header>
        <main class="content">
            <ul class="list-container" id="chat-list-container"></ul>
            <div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
                <p>还没有聊天对象哦~</p>
                <p>点击右上角的“+”创建一个吧！</p>
            </div>
        </main>
    </div>
    <div id="chat-room-screen" class="screen">
   <header class="app-header" id="chat-room-header-default">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="chat-room-title">...</h1>
        <div class="subtitle" id="chat-room-subtitle">
            <div class="online-indicator"></div>
            <span id="chat-room-status-text">在线</span>
        </div>
    </div>
    <div class="action-btn-group">
        <button class="action-btn" id="ai-trajectory-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px; color:var(--primary-color);">
                <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path>
            </svg>
        </button>
        <button class="action-btn" id="chat-settings-btn"><img src="https://i.postimg.cc/nhwP4pQy/chan-73.png" alt="设置"></button>
    </div>
</header>
        <header class="app-header" id="chat-room-header-select" style="display: none;">
            <button class="action-btn" id="cancel-multi-select-btn">取消</button>
            <div class="title-container">
                <h1 class="title" id="multi-select-title">选择消息</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="message-area" id="message-area"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
        </main>
        
        <div class="chat-input-wrapper">
        	<!-- 找到 <div class="chat-input-wrapper"> 在其内部最前面添加 -->
<div id="quote-reply-bar" style="padding: 8px 12px; background-color: rgba(240, 240, 240, 0.9); border-top: 1px solid #eee; display: none; align-items: center; gap: 8px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);">
    <div id="quoted-message-preview" style="flex-grow: 1; font-size: 13px; color: #666; border-left: 3px solid var(--primary-color); padding-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
    <button id="cancel-quote-reply-btn" style="background: none; border: none; font-size: 20px; color: #888; cursor: pointer; padding: 0 5px;">&times;</button>
</div>
          
<div id="sticker-bar">
    <button class="sticker-bar-btn" id="rollback-btn" title="撤回并重写">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z"></path>
        </svg>
    </button>
    <button class="sticker-bar-btn" id="sticker-toggle-btn">
        <svg viewBox="0 0 24 24">
            <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path>
        </svg>
    </button>
    <button class="sticker-bar-btn" id="photo-video-btn">
        <svg viewBox="0 0 24 24"><path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="image-recognition-btn">
        <svg viewBox="0 0 24 24"><path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="voice-message-btn">
        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="voice-call-btn">
        <svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="wallet-btn">
        <svg viewBox="0 0 24 24"><path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="gift-btn">
        <svg viewBox="0 0 24 24"><path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="diary-btn" style="display: none;">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M14 17H7V15H14V17M17 13H7V11H17V13M17 9H7V7H17V9Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="time-skip-btn">
        <svg viewBox="0 0 24 24"><path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="file-btn">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="location-btn">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12C20,15.08 18.05,17.78 15.42,19.23L12,14.5L8.58,19.23C5.95,17.78 4,15.08 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="ai-memories-btn">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20,2H8A2,2 0 0,0 6,4V16A2,2 0 0,0 8,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M20,16H8V4H20M4,6H2V20A2,2 0 0,0 4,22H18V20H4M12,6L11.2,6.8L9,9L10.2,10.2L11,9.4V14H13V9.4L13.8,10.2L15,9L12.8,6.8L12,6Z"></path>
        </svg>
    </button>
</div>
      
            <div class="message-input-area" id="message-input-default">
                <input type="text" id="message-input" placeholder="输入消息...">
                <button id="send-message-btn" class="icon-btn send-btn">➤</button>
                <button id="get-reply-btn" class="icon-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z"/>
                    </svg>
                </button>
            </div>
            <div class="message-input-area" id="message-edit-bar" style="display: none;">
                <input type="text" id="message-edit-input">
                <button id="save-edit-btn" class="icon-btn send-btn">✓</button>
                <button id="cancel-edit-btn" class="icon-btn" style="background-color: #aaa;">✗</button>
            </div>
        </div>
        <div id="multi-select-bar"><span id="select-count">已选择 0 项</span>
            <button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">删除已选
            </button>
        </div>
        <div id="sticker-modal">
            <div class="header"><span>我的表情</span>
                <button class="btn btn-primary btn-small" id="add-new-sticker-btn">添加新表情</button>       
           </div>
            <div class="sticker-grid" id="sticker-grid-container"></div>
        </div>
    </div>
    <div id="world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">世界书</h1>
            </div>
            <button class="action-btn" id="add-world-book-btn">+</button>
        </header>
        <main class="content">
            <ul class="list-container" id="world-book-list-container"></ul>
            <div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
                <p>你的世界一片混沌...</p>
                <p>点击右上角的“+”创造第一个设定吧！</p>
            </div>
        </main>
    </div>
    <div id="edit-world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="world-book-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="edit-world-book-title">创建/编辑条目</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <form id="edit-world-book-form">
                <input type="hidden" id="world-book-id">
                <div class="form-group">
                    <label for="world-book-name">条目名称</label>
                    <input type="text" id="world-book-name" placeholder="例如：世界观背景、魔法体系" required>
                </div>
                <div class="form-group">
                    <label for="world-book-content">条目内容</label>
                    <textarea id="world-book-content" rows="8" placeholder="详细描述此项设定..." required></textarea>
                </div>
                <div class="form-group">
                    <label>注入位置</label>
                    <div class="form-group radio-group">
                        <label><input type="radio" name="world-book-position" value="before" checked> 前</label>
                        <label><input type="radio" name="world-book-position" value="after"> 后</label>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">保存条目</button>
            </form>
        </main>
    </div>
    <div id="api-settings-screen" class="screen"></div>
<!-- 在 id="api-settings-screen" 的 </div> 之后添加以下代码 -->
<div id="diary-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">日记</h1>
        </div>
        <button class="action-btn" id="generate-diary-manually-btn">
             <svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;">
                <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
            </svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="diary-list-container"></ul>
        <div class="placeholder-text" id="no-diaries-placeholder" style="display: none;">
            <p>还没有日记哦~</p>
            <p>多聊聊天，让Ta记录下你们的故事吧！</p>
        </div>
    </main>
</div>
<div id="memories-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">回忆</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="memories-list-container"></ul>
        <div class="placeholder-text" id="no-memories-placeholder" style="display: none;">
            <p>还没有专属回忆哦~</p>
            <p>和Ta多聊聊天，创造一些难忘的瞬间吧！</p>
        </div>
    </main>
</div>

<div id="memory-detail-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="memories-screen">‹</button>
        <div class="title-container">
            <h1 class="title">回忆详情</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content" id="memory-detail-content">
        </main>
</div>


    <div id="wallpaper-screen" class="screen"></div>
    <div id="font-settings-screen" class="screen"></div>
    <div id="customize-screen" class="screen"></div>
    <div id="tutorial-screen" class="screen"></div>
  <div id="forum-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-list-screen">‹</button>
        <div class="title-container">
            <div class="forum-header" id="forum-header">
                <h1 id="forum-board-title-header">生活闲聊</h1>
                <svg class="dropdown-arrow" viewBox="0 0 24 24"><path d="M7,10L12,15L17,10H7Z"></path></svg>
            </div>
        </div>
        <button class="action-btn" id="refresh-board-btn">
             <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <div class="forum-dropdown-menu" id="forum-dropdown-menu"></div>
        <div class="thread-list-container" id="thread-list-container">
            </div>
     
    </main>
</div>

<div id="forum-thread-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="forum-screen">‹</button>
        <div class="title-container"><h1 class="title" id="thread-detail-title">帖子详情</h1></div>
        <button class="action-btn" id="share-thread-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M18,16.08C17.24,16.08, 16.56,16.38, 16.04,16.85L8.91,12.7C8.96,12.47, 9,12.24, 9,12C9,11.76, 8.96,11.53, 8.91,11.3L16.04,7.15C16.56,7.62, 17.24,7.92, 18,7.92A3,3, 0, 0,0, 18,2A3,3, 0, 0,0, 15,5C15,5.24, 15.04,5.47, 15.09,5.7L7.96,9.85C7.44,9.38, 6.76,9.08, 6,9.08A3,3, 0, 0,0, 6,15C6.76,15, 7.44,14.72, 7.96,14.25L15.09,18.3C15.04,18.53, 15,18.76, 15,19A3,3, 0, 0,0, 18,22A3,3, 0, 0,0, 21,19C21,17.42, 19.66,16.08, 18,16.08Z"></path></svg>
        </button>
    </header>
    <main class="content" id="thread-content-container">
        </main>
</div>
<!-- 自定义组件编辑器弹窗 -->
<div id="customize-widget-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>自定义组件</h3>
        <form id="customize-widget-form">
            <input type="hidden" id="editing-widget-id">
            <div class="form-group">
                <label for="widget-text-input">显示文字</label>
                <input type="text" id="widget-text-input" placeholder="输入要显示的文字" required>
            </div>
            <div class="form-group">
                <label for="widget-image-url-input">图片 URL</label>
                <input type="url" id="widget-image-url-input" placeholder="粘贴图片URL">
            </div>
            <p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p>
            <input type="file" id="widget-image-upload" accept="image/*" style="display:none;">
            <label for="widget-image-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">从本地上传</label>
            <button type="submit" class="btn btn-primary">保存</button>
        </form>
    </div>
</div>
<div id="new-post-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发布新帖</h3>
        <form id="new-post-form">
            <div class="form-group">
                <label for="post-title-input">帖子标题</label>
                <input type="text" id="post-title-input" required>
            </div>
            <div class="form-group">
                <label for="post-content-input">帖子内容</label>
                <textarea id="post-content-input" rows="6" required></textarea>
            </div>
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px;">
                <label for="post-anonymous-checkbox" style="margin-bottom: 0;">匿名发布</label>
                <input type="checkbox" id="post-anonymous-checkbox" style="width: auto; height: 20px;">
            </div>
            <button type="submit" class="btn btn-primary" style="margin-top: 20px;">发布</button>
        </form>
    </div>
</div>
    <div id="toast-notification" class="toast"></div>
    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
    <div id="add-char-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色</h3>
            <form id="add-char-form">
                <div class="form-group">
                    <label for="char-real-name">角色姓名</label><input type="text" id="char-real-name"
                                                                       placeholder="角色的真实姓名" required>
                </div>
                <div class="form-group">
                    <label for="char-remark-name">角色备注 (昵称)</label><input type="text" id="char-remark-name"
                                                                                placeholder="你对Ta的称呼" required>
                </div>
                <div class="form-group">
                    <label for="my-name-for-char">我的姓名</label><input type="text" id="my-name-for-char"
                                                                         placeholder="你希望Ta如何称呼你" required>
                </div>
                <button type="submit" class="btn btn-primary">创建</button>
            </form>
        </div>
    </div>
    <div id="add-sticker-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="add-sticker-modal-title">添加新表情</h3>
            <form id="add-sticker-form"><input type="hidden" id="sticker-edit-id">
                <div id="sticker-preview"><span>预览</span></div>
                <div class="form-group"><label for="sticker-name">表情名称</label><input type="text" id="sticker-name"
                                                                                         placeholder="如：开心" required>
                </div>
                <div class="form-group"><label for="sticker-url-input">表情URL</label><input type="url"
                                                                                             id="sticker-url-input"
                                                                                             placeholder="粘贴图片URL">
                </div>
                <p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p><input type="file"
                                                                                             id="sticker-file-upload"
                                                                                             accept="image/*"
                                                                                             style="display:none;"><label
                        for="sticker-file-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">从本地上传</label>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <div id="sticker-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="edit-sticker-btn">编辑</button>
            <button class="action-sheet-button danger" id="delete-sticker-btn">删除</button>
        </div>
    </div>
    <div id="send-voice-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>发送语音消息</h3>
            <form id="send-voice-form">
                <div class="form-group">
                    <label for="voice-text-input">输入语音文字</label>
                    <textarea id="voice-text-input" placeholder="在这里输入你想说的话..." required rows="4"></textarea>
                </div>
                <div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    预计时长: <span id="voice-duration-preview">0"</span>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-pv-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>分享照片/视频</h3>
            <form id="send-pv-form">
                <div class="form-group">
                    <label for="pv-text-input">输入描述</label>
                    <textarea id="pv-text-input" placeholder="在这里描述你的照片或视频内容..." required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-transfer-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>转账</h3>
            <form id="send-transfer-form">
                <div class="form-group">
                    <label for="transfer-amount-input">金额 (元)</label>
                    <input type="number" id="transfer-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="transfer-remark-input">备注</label>
                    <input type="text" id="transfer-remark-input" placeholder="（选填）">
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
        <div id="send-gift-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>送出礼物</h3>
            <form id="send-gift-form">
                <!-- ▼▼▼ 新增的价格输入框 ▼▼▼ -->
                <div class="form-group">
                    <label for="gift-amount-input">礼物价格 (元)</label>
                    <input type="number" id="gift-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <!-- ▲▲▲ 新增结束 ▲▲▲ -->
                <div class="form-group">
                    <label for="gift-description-input">礼物描述</label>
                    <textarea id="gift-description-input" placeholder="告诉Ta你送了什么特别的东西..." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Time Skip Modal -->
    <div id="time-skip-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>记录今天发生的事</h3>
            <form id="time-skip-form">
                <div class="form-group">
                    <label for="time-skip-input">事件描述 (该消息AI可见，会作为上下文)</label>
                    <textarea id="time-skip-input" placeholder="例如：我们一起去山顶看了日落，然后吃了烧烤。" required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Send File Modal -->
<div id="send-file-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送文件</h3>
        <form id="send-file-form">
            <div class="form-group">
                <label for="file-name-input">文件名</label>
                <input type="text" id="file-name-input" placeholder="例如：会议纪要.txt" required>
            </div>
            <div class="form-group">
                <label for="file-content-input">文件内容</label>
                <textarea id="file-content-input" placeholder="在此输入或粘贴文件内容..." required rows="6"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Display File Modal -->
<div id="display-file-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="display-file-name" style="word-wrap: break-word;">文件名</h3>
        <div class="form-group" style="max-height: 60vh; overflow-y: auto; background-color: #f5f5f5; padding: 10px; border-radius: 8px;">
            <pre id="display-file-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; color: #333;"></pre>
        </div>
        <button id="close-file-display-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- NEW: Send Location Modal -->
<div id="send-location-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送位置</h3>
        <form id="send-location-form">
            <div class="form-group">
                <label for="location-main-input">主要位置</label>
                <input type="text" id="location-main-input" placeholder="例如：市中心购物广场" required>
            </div>
            <div class="form-group">
                <label for="location-detail-input">详细位置</label>
                <textarea id="location-detail-input" placeholder="例如：xx省xx市xx区人民路123号" required rows="3"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Display Location Modal -->
<div id="display-location-modal" class="modal-overlay">
    <div class="modal-window" style="padding: 0; overflow: hidden;">
        <div id="display-location-map" style="width: 100%; height: 200px; background-size: cover; background-position: center;"></div>
        <div style="padding: 20px;">
            <h3 id="display-location-main" style="margin-top: 0; color: #333;"></h3>
            <p id="display-location-detail" style="color: #666; margin-bottom: 20px;"></p>
            <button id="close-location-display-btn" class="btn btn-primary">关闭</button>
        </div>
    </div>
</div>
<!-- NEW: Voice Call Modal -->
<div id="voice-call-overlay">
    <!-- Common Info -->
    <img src="" alt="Avatar" class="call-avatar-large" id="call-avatar">
    <h2 class="call-name" id="call-name">...</h2>
    <p class="call-status" id="call-status">正在呼叫...</p>

    <!-- Ringing/Incoming View -->
    <div id="ringing-view">
        <div class="call-button-group" id="incoming-buttons" style="display: none;">
            <button class="call-button decline" id="decline-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>拒接</span>
            </button>
            <button class="call-button accept" id="accept-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" /></svg></div>
                <span>接听</span>
            </button>
        </div>
        <div class="call-button-group" id="outgoing-buttons" style="display: none;">
            <button class="call-button decline" id="cancel-call-btn">
                 <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>取消</span>
            </button>
        </div>
    </div>

    <!-- Active Call View -->
    <!-- 在 id="voice-call-overlay" 内部 -->
<div id="active-call-view">
    <!-- 新增：固定的顶部信息面板 -->
    <div id="active-call-header">
        <img src="" alt="Avatar" class="call-avatar-large" id="active-call-header-avatar">
        <h2 class="call-name" id="active-call-header-name">...</h2>
        <p class="call-status" id="active-call-header-status">通话中</p>
    </div>
    
    <div id="call-transcript-area"></div>
    
        <div class="call-button-group" id="hangup-button-container">
         <button class="call-button decline" id="hangup-call-btn">
            <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
            <span>挂断</span>
        </button>
    </div>
    <div id="call-input-area">
        <input type="text" id="call-input" placeholder="输入文字...">
        <button id="send-call-message-btn">➤</button>
    </div>
  </div>
</div>
    <!-- NEW: Group Recipient Selection Modal -->
    <div id="group-recipient-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="group-recipient-selection-title">选择收件人</h3>
            <ul id="group-recipient-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <div id="receive-transfer-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="accept-transfer-btn">接收</button>
            <button class="action-sheet-button danger" id="return-transfer-btn">退回</button>
        </div>
    </div>
    <!-- Private Chat Settings -->
    <div id="chat-settings-sidebar" class="settings-sidebar">
        <div class="header">聊天设置</div>
        <div class="content">
            <form id="chat-settings-form">
                <div class="avatar-setting"><img src="" alt="角色头像" id="setting-char-avatar-preview"
                                                 class="avatar-preview"><input type="file"
                                                                               id="setting-char-avatar-upload"
                                                                               accept="image/*"
                                                                               style="display:none;"><label
                        for="setting-char-avatar-upload" class="btn btn-primary"
                        style="flex-grow:1;">更换角色头像</label></div>
                <div class="form-group"><label for="setting-char-remark">角色备注 (昵称)</label><input type="text"
                                                                                                       id="setting-char-remark">
                </div>
                <div class="form-group"><label for="setting-char-persona">角色人设</label><textarea
                        id="setting-char-persona" placeholder="详细描述角色的性格、背景、说话风格等。"></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting"><img src="" alt="我的头像" id="setting-my-avatar-preview"
                                                 class="avatar-preview"><input type="file" id="setting-my-avatar-upload"
                                                                               accept="image/*"
                                                                               style="display:none;"><label
                        for="setting-my-avatar-upload" class="btn btn-secondary"
                        style="flex-grow:1;">更换我的头像</label></div>
                <div class="form-group"><label for="setting-my-name">我的姓名</label><input type="text"
                                                                                            id="setting-my-name"></div>
                <div class="form-group"><label for="setting-my-persona">我的人设</label><textarea
                        id="setting-my-persona" placeholder="描述你希望在对话中扮演的形象。"></textarea>


<!-- 管理 Modal（样式与气泡预设管理一致） -->
<div id="mypersona-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理我的人设预设</h3>
    <div id="mypersona-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="mypersona-close-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /我的人设预设控制 === -->
</div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <button type="button" class="btn btn-secondary" id="link-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-use-custom-css" style="width: auto;">
                    </div>
                    <div id="private-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>


<!-- === 气泡预设控制（由 ChatGPT 插入） === -->
<!-- 插入位置：自定义气泡样式 textarea 之后（已美化外观） -->
<div class="panel panel-sm" style="padding:12px;border-radius:10px;border:1px solid var(--border-color,#e8e8ef);background:var(--panel-bg,#fff);box-shadow:var(--panel-shadow,0 4px 12px rgba(20,20,30,0.04));margin:10px 0;">
  <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
    <label for="bubble-preset-select" style="width:88px;color:var(--muted,#667);font-size:13px;">气泡预设</label>
    <select id="bubble-preset-select" style="flex:1;padding:8px 10px;border-radius:8px;border:1px solid var(--input-border,#e6e6ea);background:var(--input-bg,#fff);font-size:14px;">
      <option value="">— 选择预设 —</option>
    </select>
    <button type="button" id="apply-preset-btn" class="btn btn-primary" style="margin-left:8px;padding:7px 10px;border-radius:8px;">应用</button>
  </div>

  <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
    <label style="width:88px;color:var(--muted,#667);font-size:13px;">外观操作</label>
    <button type="button" id="save-preset-btn" class="btn" style="padding:7px 10px;border-radius:8px;">另存为预设</button>
    <button type="button" id="manage-presets-btn" class="btn" style="padding:7px 10px;border-radius:8px;">管理</button>
  </div>

  
</div>

<!-- 管理预设 modal（样式微调） -->
<div id="bubble-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理气泡预设</h3>
    <div id="bubble-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="close-presets-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /气泡预设控制（由 ChatGPT 插入） === -->


                    <button type="button" class="btn btn-neutral" id="reset-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>

                <div class="form-group"><label for="setting-max-memory">最大记忆轮数</label><input type="number"
                                                                                                   id="setting-max-memory"
                                                                                                   value="10" min="1">
                </div>
               <!-- === 修改为回忆记录按钮 开始 === -->
<div class="form-group">
    <button type="button" class="btn btn-secondary" id="show-memory-summary-btn">查看回忆记录</button>
</div>
<!-- === 修改为回忆记录按钮 结束 === --> 
                <div class="form-group"><label for="setting-chat-bg-upload" class="btn btn-primary">更换聊天背景</label><input
                        type="file" id="setting-chat-bg-upload" accept="image/*" style="display:none;"></div>
                <button type="submit" class="btn btn-primary">保存设置</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <div id="world-book-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>选择要关联的世界书</h3>
            <ul id="world-book-selection-list"></ul>
            <button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <!-- Group Chat Creation Modal -->
    <div id="create-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建群聊</h3>
            <form id="create-group-form">
                <div class="form-group">
                    <label>选择群成员</label>
                    <ul id="member-selection-list" class="member-selection-list"></ul>
                </div>
                <div class="form-group">
                    <label for="group-name-input">群聊名称</label>
                    <input type="text" id="group-name-input" placeholder="给你的群聊起个名字吧" required>
                </div>
                <button type="submit" class="btn btn-primary">创建群聊</button>
            </form>
        </div>
    </div>
    <!-- Group Chat Settings -->
    <div id="group-settings-sidebar" class="settings-sidebar">
        <div class="header">群聊设置</div>
        <div class="content">
            <form id="group-settings-form">
                <div class="group-avatar-setting">
                    <img src="" alt="群头像" id="setting-group-avatar-preview" class="group-avatar-preview">
                    <input type="file" id="setting-group-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-avatar-upload" class="btn btn-primary"
                           style="flex-grow:1;">更换群头像</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-name">群名 (AI也可见)</label>
                    <input type="text" id="setting-group-name">
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting">
                    <img src="" alt="我的头像" id="setting-group-my-avatar-preview" class="avatar-preview">
                    <input type="file" id="setting-group-my-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-my-avatar-upload" class="btn btn-secondary"
                           style="flex-grow:1;">更换我的头像</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-my-nickname">我的群昵称</label>
                    <input type="text" id="setting-group-my-nickname">
                </div>
                <div class="form-group">
                    <label for="setting-group-my-persona">我的人设</label>
                    <textarea id="setting-group-my-persona" placeholder="描述你希望在此群聊中扮演的形象。"></textarea>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <label>群成员</label>
                    <div class="group-members-list" id="group-members-list-container"></div>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <button type="button" class="btn btn-secondary" id="link-group-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-group-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-group-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-group-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-group-use-custom-css" style="width: auto;">
                    </div>
                    <div id="group-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-group-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-group-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>

                <div class="form-group"><label for="setting-group-max-memory">最大记忆轮数</label><input type="number"
                                                                                                         id="setting-group-max-memory"
                                                                                                         value="10"
                                                                                                         min="1"></div>
               
<!-- === 修改为回忆记录按钮 开始 === -->
<div class="form-group">
    <button type="button" class="btn btn-secondary" id="show-group-memory-summary-btn">查看回忆记录</button>
</div>
<!-- === 修改为回忆记录按钮 结束 === -->
 <div class="form-group"><label for="setting-group-chat-bg-upload"
                                               class="btn btn-primary">更换聊天背景</label><input type="file"
                                                                                                  id="setting-group-chat-bg-upload"
                                                                                                  accept="image/*"
                                                                                                  style="display:none;">
                </div>
                <div class="form-group">
<label for="bubble-scale-range">气泡 + 字体大小</label>
<div style="display:flex;align-items:center;gap:10px;">
<input id="bubble-scale-range" max="1.6" min="0.8" step="0.05" style="flex:1;" type="range" value="1"/>
<span id="bubble-scale-value" style="width:56px;text-align:right;">100%</span>
</div>
<div style="margin-top:8px; color:#888; font-size:12px;">
    提示：该滑块仅影响聊天区气泡及其文字，不改变输入栏/标题栏大小。
  </div>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
                <button type="submit" class="btn btn-primary">保存设置</button>
                 </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-group-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <!-- Group Member Edit Modal -->
    <div id="edit-group-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="edit-group-member-title">编辑群成员</h3>
            <form id="edit-group-member-form">
                <input type="hidden" id="editing-member-id">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="" alt="成员头像" id="edit-member-avatar-preview" class="avatar-preview"
                         style="cursor: pointer;">
                    <input type="file" id="edit-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="edit-member-group-nickname">群昵称</label>
                    <input type="text" id="edit-member-group-nickname" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-real-name">真名</label>
                    <input type="text" id="edit-member-real-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-persona">人设</label>
                    <textarea id="edit-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <!-- Add Member to Group Action Sheet -->
    <div id="add-member-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="invite-existing-member-btn">邀请现有角色</button>
            <button class="action-sheet-button" id="create-new-member-btn">创建新角色入群</button>
        </div>
    </div>
    <!-- Invite Existing Member Modal -->
    <div id="invite-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>邀请成员加入群聊</h3>
            <ul id="invite-member-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">确认邀请</button>
        </div>
    </div>
    <!-- 在这里插入音乐播放器弹窗 -->
<div id="music-player-modal" class="modal-overlay">
    <div class="modal-window">
        <div class="music-player-header">
            <h3 class="song-title">歌曲名</h3>
            <svg class="share-btn" viewBox="0 0 24 24"><path d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L16.04,7.15C16.56,7.62 17.24,7.92 18,7.92C19.66,7.92 21,6.58 21,5C21,3.42 19.66,2 18,2C16.34,2 15,3.42 15,5C15,5.24 15.04,5.47 15.09,5.7L7.96,9.85C7.44,9.38 6.76,9.08 6,9.08C4.34,9.08 3,10.42 3,12C3,13.58 4.34,14.92 6,14.92C6.76,14.92 7.44,14.62 7.96,14.15L15.09,18.3C15.04,18.53 15,18.76 15,19C15,20.58 16.34,22 18,22C19.66,22 21,20.58 21,19C21,17.42 19.66,16.08 18,16.08Z"/></svg>
        </div>
        <!-- 在 id="music-player-modal" 内找到 .music-player-body -->
<div class="music-player-body">
    <img src="https://i.postimg.cc/nzP9sgxr/chan-125.png" alt="专辑封面" class="music-album-art">
    <!-- ▼▼▼ 修改下面这一行 ▼▼▼ -->
    <div id="lyrics-panel" class="lyrics-panel">
        <p class="lyric-line">暂无歌词</p>
    </div>
    <!-- ▲▲▲ 修改结束 ▲▲▲ -->
    <div class="music-controls">
        <button class="side-btn" title="上一首"><svg viewBox="0 0 24 24"><path d="M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z"/></svg></button>
        <button class="play-btn" title="播放/暂停"><svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg></button>
        <button class="side-btn" title="下一首"><svg viewBox="0 0 24 24"><path d="M16,18H18V6H16V18M4,18V6L13,12L4,18Z"/></svg></button>
    </div>
</div>
        <div class="music-extra-controls">
            <button title="循环模式"><svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg></button>
            <button title="歌曲列表"><svg viewBox="0 0 24 24"><path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z"/></svg></button>
        </div>
    </div>
</div>
<!-- =============================================================== -->
<!-- START: 新增音乐功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 音乐播放列表面板 -->
<div id="music-playlist-panel" class="action-sheet-overlay">
    <div class="action-sheet" style="height: 60%; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid #eee; flex-shrink: 0;">
            <h3 style="margin: 0; font-size: 16px;">播放列表</h3>
            <button id="open-add-song-modal-btn" class="btn btn-primary btn-small" style="font-size: 24px; padding: 0; width: 32px; height: 32px; border-radius: 50%;">+</button>
        </div>
        <ul id="playlist-container" class="list-container" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
            <!-- 歌曲列表将由JS动态生成 -->
        </ul>
    </div>
</div>

<!-- 添加歌曲弹窗 -->
<div id="add-song-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>添加新歌曲</h3>
        <form id="add-song-form">
            <div class="form-group">
                <label for="song-url-input">歌曲URL (Catbox MP3)</label>
                <input type="url" id="song-url-input" placeholder="https://files.catbox.moe/..." required>
            </div>
            <div class="form-group">
                <label for="song-name-input">歌曲名称</label>
                <input type="text" id="song-name-input" placeholder="歌曲的名称" required>
            </div>
             <div class="form-group">
                <label for="song-artist-input">艺术家</label>
                <input type="text" id="song-artist-input" placeholder="演唱者/艺术家" required>
            </div>
            <div class="form-group">
                <label for="song-album-art-input">专辑封面URL (选填)</label>
                <input type="url" id="song-album-art-input" placeholder="https://...">
            </div>
            <div class="form-group">
                <label for="song-lyrics-input">歌词内容 (选填)</label>
                <textarea id="song-lyrics-input" rows="5" placeholder="在此处粘贴 .lrc 文件内容..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">添加</button>
        </form>
    </div>
</div>

<!-- 分享音乐弹窗 -->
<div id="share-music-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>分享音乐给...</h3>
        <ul id="share-music-selection-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
            <!-- 聊天对象列表将由JS动态生成 -->
        </ul>
        <button id="confirm-music-share-btn" class="btn btn-primary" style="margin-top: 20px;">确认分享</button>
    </div>
</div>

<!-- 全局音频播放器 -->
<audio id="global-audio-player"></audio>

<!-- 用于上传LRC文件的隐藏输入框 -->
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
<!-- 音乐播放器弹窗结束 -->
    <!-- Create New Member for Group Modal -->
    <div id="create-member-for-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色并加入群聊</h3>
            <form id="create-member-for-group-form">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="新成员头像"
                         id="create-group-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="create-group-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="create-group-member-nickname">群昵称</label>
                    <input type="text" id="create-group-member-nickname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-realname">真名</label>
                    <input type="text" id="create-group-member-realname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-persona">人设</label>
                    <textarea id="create-group-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">创建并加入</button>
            </form>
        </div>
    </div>
<!-- =============================================================== -->
<!-- START: 新增钱包功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 1. 钱包主界面 Screen -->
<div id="wallet-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-screen">‹</button>
        <div class="title-container">
            <h1 class="title">我的钱包</h1>
        </div>
       <div class="action-btn-group">
    <button class="action-btn" id="wallet-settings-btn">设置</button>
</div>
    </header>
    <main class="content" style="padding: 20px; background-color: #f9f9f9;">
        <div class="wallet-balance-card">
            <p class="wallet-balance-label">零花钱余额 (元)</p>
            <p class="wallet-balance-amount" id="wallet-balance-display">0.00</p>
        </div>
        <div class="wallet-actions-list">
            <div class="wallet-action-item" id="show-transactions-btn">
                <span>零花钱明细</span>
                <span>›</span>
            </div>
        </div>
    </main>
</div>

<!-- 2. 钱包设置界面 Screen -->
<div id="wallet-settings-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="wallet-screen">‹</button>
        <div class="title-container">
            <h1 class="title">支付设置</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <form id="wallet-settings-form">
    <div class="form-group">
    <label for="wallet-balance-input">设置零花钱余额</label>
    <input type="number" id="wallet-balance-input" placeholder="0.00" step="0.01" min="0">
</div>

<div class="form-group toggle-group">
    <label for="wallet-password-enabled-toggle" style="margin-bottom:0;">启用支付密码</label>
    <label class="toggle-switch">
        <input type="checkbox" id="wallet-password-enabled-toggle">
        <span class="slider"></span>
    </label>
</div>
<div class="form-group">
    <label for="wallet-password-input">设置/修改支付密码 (6位数字)</label>
    <input type="password" id="wallet-password-input" pattern="\d{6}" maxlength="6" inputmode="numeric">
</div>
            <button type="submit" class="btn btn-primary">保存设置</button>
        </form>
    </main>
</div>

<!-- 3. 零花钱明细弹窗 Modal -->
<div id="transaction-details-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>零花钱明细</h3>
        <ul id="transaction-list-container" class="list-container" style="max-height: 60vh; overflow-y: auto;">
            <!-- 明细将由JS动态生成 -->
        </ul>
        <button class="btn btn-primary" id="close-transactions-btn" style="margin-top: 20px;">关闭</button>
    </div>
</div>

<!-- 4. 支付密码输入弹窗 Modal -->
<div id="payment-password-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="payment-prompt-title">请输入支付密码</h3>
        <p id="payment-prompt-description" style="text-align:center; color:#666;"></p>
        <div class="form-group">
            <input type="password" id="payment-password-input" pattern="\d{6}" maxlength="6" inputmode="numeric" style="text-align:center; font-size: 20px; letter-spacing: 1em;">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn btn-neutral" id="cancel-payment-btn" style="flex: 1;">取消</button>
            <button class="btn btn-primary" id="confirm-payment-btn" style="flex: 1;">确认</button>
        </div>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 新增钱包功能HTML -->
<!-- =============================================================== -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<!-- AI POV: Character Selection Screen -->
<div id="ai-character-select-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-screen">‹</button>
        <div class="title-container">
            <h1 class="title">选择AI视角</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-character-select-list"></ul>
        <div class="placeholder-text" id="no-ai-chars-placeholder" style="display: none;">
            <p>还没有创建任何AI角色哦~</p>
        </div>
    </main>
</div>

<!-- AI POV: AI's Chat List Screen -->
<div id="ai-chat-list-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-chat-list-title">的聊天列表</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-chat-list-container"></ul>
         <div class="placeholder-text" id="no-ai-chats-placeholder" style="display: none;">
            <p>Ta还没有和别人聊过天哦~</p>
        </div>
    </main>
</div>

<!-- AI POV: AI's Conversation View Screen -->
<div id="ai-chat-view-screen" class="screen">
   <header class="app-header">
    <button class="back-btn" data-target="ai-chat-list-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="ai-chat-view-title">与...的对话</h1>
    </div>
    <div class="placeholder"></div>
   </header>
    <main class="content">
        <div class="message-area" id="ai-message-area"></div>
    </main>
    <!-- 这个屏幕是只读的，所以没有输入框 -->
</div>
<!-- ▲▲▲ 新代码粘贴到这里结束 ▲▲▲ -->
<!-- === Modal 结束 === -->
<div id="voice-call-overlay">
    <img src="" alt="Avatar" class="call-avatar-large" id="call-avatar">
    <h2 class="call-name" id="call-name">...</h2>
    <p class="call-status" id="call-status">正在呼叫...</p>

    <div id="ringing-view">
        <div class="call-button-group" id="incoming-buttons" style="display: none;">
            <button class="call-button decline" id="decline-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>拒接</span>
            </button>
            <button class="call-button accept" id="accept-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" /></svg></div>
                <span>接听</span>
            </button>
        </div>
        <div class="call-button-group" id="outgoing-buttons" style="display: none;">
            <button class="call-button decline" id="cancel-call-btn">
                 <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>取消</span>
            </button>
        </div>
    </div>

 <div id="call-transcript-area"></div>
    <div class="call-button-group" id="hangup-button-container">
        <button class="call-button decline" id="hangup-call-btn">
            </button>
    </div>
    <div id="call-input-area">
        <input type="text" id="call-input" placeholder="输入文字...">
        <button id="send-call-message-btn">➤</button>
    </div>
</div>
</div>
  
</div>
<input type="file" id="import-data-input" accept=".ee" style="display: none;">	
<script>
    const URLBlacklist = []

    async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            // --- 新增：处理GIF动图 ---
            // 如果文件是GIF，则不经过canvas压缩，直接返回原始文件数据以保留动画
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // --- 对其他静态图片（如PNG, JPG）进行压缩 ---
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // 对于有透明背景的PNG图片，先填充一个白色背景
                        // 这样可以防止透明区域在转换成JPEG时变黑
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; // 白色背景
                            ctx.fillRect(0, 0, width, height);
                        }

                        ctx.drawImage(img, 0, 0, width, height);

                        // --- 关键修正：将输出格式改为 'image/jpeg' ---
                        // JPEG格式可以显著减小文件大小，避免浏览器处理超大Base64字符串时崩溃
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    };
                };
            });
        }
    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }

    document.addEventListener('DOMContentLoaded', () => {
    

        // --- Initial HTML Injection ---
        // (请找到文件中的旧 'api-settings-screen'.innerHTML 代码，并用下面的代码完整替换它)

document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">API 设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 服务商</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select>
<div class="api-presets-embedded" style="margin-top:12px;">
<div id="api-presets-control" style="margin:12px 0;padding:12px;border-radius:8px;border:1px solid var(--border-color, #eee);background:var(--panel-bg, #fff);box-shadow:var(--panel-shadow, none);">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
    <label style="min-width:86px;color:var(--muted,#666);">API 预设：</label>
    <select id="api-preset-select" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd;">
      <option value="">— 选择 API 预设 —</option>
    </select>
    <button id="api-apply-preset" class="btn btn-primary" style="margin-left:8px;padding:6px 10px;">应用</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="api-save-preset" class="btn" style="padding:6px 10px;">另存为预设</button>
    <button id="api-manage-presets" class="btn" style="padding:6px 10px;">管理预设</button>
    <div style="flex:1"></div>
    <button id="api-import-presets" class="btn" style="padding:6px 10px;">导入</button>
    <button id="api-export-presets" class="btn" style="padding:6px 10px;">导出</button>
  </div>
</div>

<div id="api-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:9999;align-items:center;justify-content:center;">
  <div style="width:640px;max-width:94%;background:var(--panel-bg,#fff);padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="margin:0 0 12px 0;">API 预设管理</h3>
    <div id="api-presets-list" style="max-height:360px;overflow:auto;border:1px solid #f0f0f0;padding:8px;border-radius:6px;"></div>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="api-close-modal" class="btn btn-primary">关闭</button>
    </div>
  </div>
</div>
</div>
</div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div><div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="offline-mode-toggle" style="margin-bottom: 0;">开启线下模式 (全局)</label>
    <input type="checkbox" id="offline-mode-toggle" style="width: auto; height: 20px;">
</div>

<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; border-top: 1px solid #eee; padding-top: 20px;">
    <label for="force-html-theater" style="margin-bottom: 0;">生成HTML小剧场</label>
    <input type="checkbox" id="force-html-theater" style="width: auto; height: 20px;">
</div>
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="ai-auto-post-moment" style="margin-bottom: 0;">AI自动发布动态</label>
    <input type="checkbox" id="ai-auto-post-moment" style="width: auto; height: 20px;">
</div>
<button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">保 存</span><div class="spinner"></div></button>
</form></main>`;

        document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">更换壁纸</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>当前壁纸预览</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">从相册选择新壁纸</label></main>`;
        document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">字体设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="font-settings-form"><div class="form-group"><label for="font-url">字体链接 (ttf, woff, woff2)</label><input type="url" id="font-url" placeholder="https://.../font.ttf" required></div><p style="font-size:12px; color:#888; text-align:center;">示例: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p><button type="submit" class="btn btn-primary">应用字体</button><button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">恢复默认字体</button></form></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">主屏幕自定义</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">教程</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: '白/粉',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: '白/蓝',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: '白/黄',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: '白/绿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: '白/紫',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: '黑/红',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: '黑/绿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: '黑/白',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: '白/黑',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: '黄/紫',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: '粉/蓝',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
        const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: '壁纸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: '世界书', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: '自定义', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: '字体', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: '教程', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
          'ai-character-select-screen': {name: 'AI手机', url: 'https://i.postimg.cc/9Q8B2X3D/chan-101.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'},
            'record-label': { name: '唱片标签 (圆形)', url: 'https://i.postimg.cc/nzP9sgxr/chan-125.png' },
    'record-sleeve': { name: '唱片封套 (方形)', url: 'https://i.postimg.cc/KzC3q4w3/image.png' },
    'decorative-component': { name: '装饰组件 (方形)', url: '' }
        };

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            myStickers: [],
            homeScreenMode: 'night',
            worldBooks: [],
            fontUrl: '',
            customIcons: {},
            customWidgets: [], // <-- 添加这一行
            playlist: [], // <-- 新增
            musicPlayerSettings: { // <-- 新增
                volume: 0.8,
                playbackMode: 'sequential', 
                }
        };
        let currentQuotedMessageId = null, currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null;
let notificationQueue = [];
let isNotificationShowing = false;
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []};
            let audioPlayer = null;
        let currentSongIndex = -1;
        let isPlaying = false;
        let sharedWithChatIds = new Set();
        let shuffleOrder = [];
        let parsedLyrics = [];
        let currentLyricIndex = -1;
            let isVoiceCallActive = false, voiceCallTranscript = [], voiceCallStartTime = null, callTimerInterval = null, currentCallTargetId = null;
let isCallRinging = false; // <-- 新增变量，标记是否处于正在响铃状态
let callInitiationTimeout = null; // <-- 新增变量，用于存放呼叫超时计时器
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            messageEditBar = document.getElementById('message-edit-bar'),
            messageEditInput = document.getElementById('message-edit-input'),
            saveEditBtn = document.getElementById('save-edit-btn'),
            cancelEditBtn = document.getElementById('cancel-edit-btn'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload');
            const voiceCallBtn = document.getElementById('voice-call-btn');
const voiceCallOverlay = document.getElementById('voice-call-overlay');
const callAvatar = document.getElementById('call-avatar');
const callName = document.getElementById('call-name');
const callStatus = document.getElementById('call-status');
const ringingView = document.getElementById('ringing-view');
const incomingButtons = document.getElementById('incoming-buttons');
const outgoingButtons = document.getElementById('outgoing-buttons');
const activeCallView = document.getElementById('active-call-view');
const callTranscriptArea = document.getElementById('call-transcript-area');
const hangupCallBtn = document.getElementById('hangup-call-btn');
const callInput = document.getElementById('call-input');
const sendCallMessageBtn = document.getElementById('send-call-message-btn');
const declineCallBtn = document.getElementById('decline-call-btn');
const acceptCallBtn = document.getElementById('accept-call-btn');
const cancelCallBtn = document.getElementById('cancel-call-btn');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
// --- NEW: File System Elements ---
const fileBtn = document.getElementById('file-btn'),
      sendFileModal = document.getElementById('send-file-modal'),
      sendFileForm = document.getElementById('send-file-form'),
      fileNameInput = document.getElementById('file-name-input'),
      fileContentInput = document.getElementById('file-content-input');
 // --- NEW: Location System Elements ---
const locationBtn = document.getElementById('location-btn'),
      sendLocationModal = document.getElementById('send-location-modal'),
      sendLocationForm = document.getElementById('send-location-form'),
      locationMainInput = document.getElementById('location-main-input'),
      locationDetailInput = document.getElementById('location-detail-input'),
      displayLocationModal = document.getElementById('display-location-modal'),
      displayLocationMap = document.getElementById('display-location-map'),
      displayLocationMain = document.getElementById('display-location-main'),
      displayLocationDetail = document.getElementById('display-location-detail'),
      closeLocationDisplayBtn = document.getElementById('close-location-display-btn');
        // --- Utility and Core Functions ---
        class DataStorage {
            constructor() {
                // 创建数据库
                this.db = new Dexie('章鱼喷墨机DB');

                // 定义数据库结构
                this.db.version(1).stores({
                    storage: 'key, value, timestamp' // key作为主键，value存储数据，timestamp记录时间
                });
            }

            // 保存数据 - 类似 localStorage.setItem
            async saveData(key, data) {
                try {
                    const item = {
                        key: key,
                        value: JSON.stringify(data), // 将数据序列化
                        timestamp: Date.now()
                    };

                    await this.db.storage.put(item);
                    console.log(`数据已保存: ${key}`);
                    return true;
                } catch (error) {
                    console.error('保存数据失败:', error);
                    return false;
                }
            }

            // 获取数据 - 类似 localStorage.getItem
            async getData(key) {
                try {
                    const item = await this.db.storage.get(key);

                    if (item) {
                        return JSON.parse(item.value); // 反序列化数据
                    } else {
                        console.log(`未找到数据: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('获取数据失败:', error);
                    return null;
                }
            }

            // 删除数据
            async removeData(key) {
                try {
                    await this.db.storage.delete(key);
                    console.log(`数据已删除: ${key}`);
                    return true;
                } catch (error) {
                    console.error('删除数据失败:', error);
                    return false;
                }
            }

            // 清空所有数据
            async clearAll() {
                try {
                    await this.db.storage.clear();
                    console.log('所有数据已清空');
                    return true;
                } catch (error) {
                    console.error('清空数据失败:', error);
                    return false;
                }
            }

            // 获取所有键名
            async getAllKeys() {
                try {
                    const items = await this.db.storage.toArray();
                    return items.map(item => item.key);
                } catch (error) {
                    console.error('获取键名失败:', error);
                    return [];
                }
            }

            // 获取数据库大小信息
            async getStorageInfo() {
                try {
                    const items = await this.db.storage.toArray();
                    const totalSize = items.reduce((sum, item) => sum + item.value.length, 0);

                    return {
                        itemCount: items.length,
                        totalSize: totalSize,
                        items: items.map(item => ({
                            key: item.key,
                            size: item.value.length,
                            timestamp: new Date(item.timestamp).toLocaleString()
                        }))
                    };
                } catch (error) {
                    console.error('获取存储信息失败:', error);
                    return null;
                }
            }
        }

        const dataStorage = new DataStorage();


        const saveData = async (data) => {
            await dataStorage.saveData('章鱼喷墨机', data ? data : db);
            return Promise.resolve();
        };
           // ▼▼▼ 请用下面这【一整块】代码，完整替换掉你文件中旧的 loadData 函数 ▼▼▼
        const loadData = async () => {
            const oldData = localStorage.getItem('gemini-chat-app-db');
            let data = await dataStorage.getData('章鱼喷墨机')
            if (oldData) {
                await saveData(JSON.parse(oldData))
                data = await dataStorage.getData('章鱼喷墨机')
                localStorage.removeItem('gemini-chat-app-db');
            }
            if (data) db = data;
if (!db.homeProfile) {
    db.homeProfile = {
        name: '点击设置昵称',
        signature: '点击设置个性签名',
        avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
        heroBg: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg'
    };
}
            if (!db.globalCustomCss) db.globalCustomCss = '';
            
            // --- 核心修复：在这里添加对新属性的检查和初始化 ---
            if (!db.playlist) {
                db.playlist = []; // 如果 playlist 不存在，就创建一个空数组
            }
            if (!db.musicPlayerSettings) {
                db.musicPlayerSettings = { // 如果音乐设置不存在，就创建默认设置
                    volume: 0.8,
                    playbackMode: 'sequential',
                };
            }
            // --- 修复结束 ---

            if (!db.apiSettings) db.apiSettings = {};
            if (db.apiSettings.forceHtmlTheater === undefined) db.apiSettings.forceHtmlTheater = false;
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.characters) db.characters = [];
            if (!db.groups) db.groups = [];
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};

if (!db.forumData) db.forumData = {}; 
            db.characters.forEach(c => {
                if (c.isPinned === undefined) c.isPinned = false;
                if (c.status === undefined) c.status = '在线';
                if (!c.worldBookIds) c.worldBookIds = [];
                if (!c.memories) c.memories = []; // <-- 添加这行
                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
                c.memorySummary = c.memorySummary || ''; 
                if (!c.povCache) c.povCache = null; 
            });
            db.groups.forEach(g => {
                if (g.isPinned === undefined) g.isPinned = false;
                if (!g.worldBookIds) g.worldBookIds = [];
                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
                g.memorySummary = g.memorySummary || ''; 
            });
// 初始化或验证自定义小组件的数据
if (!db.customWidgets || !Array.isArray(db.customWidgets) || db.customWidgets.length !== 2) {
    db.customWidgets = [
        { id: 'widget1', text: '自定义', imageUrl: 'https://i.ibb.co/6r11fGg/avatar1.png' },
        { id: 'widget2', text: '自定义', imageUrl: 'https://i.ibb.co/d28n82t/avatar2.png' }
    ];
}          
     // --- 新增：初始化钱包数据 ---
if (!db.wallet) {
    db.wallet = {
        balance: 0,
        password: null,
        transactions: [],
        passwordEnabled: true // 默认启用密码
    };
}
// 兼容旧数据，如果旧数据没有这个属性，也默认为启用
if (db.wallet.passwordEnabled === undefined) {
    db.wallet.passwordEnabled = true;
}
            // --- 初始化结束 ---
            return Promise.resolve()
        };
        // ▲▲▲ 替换结束 ▲▲▲     
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        const pad = (num) => num.toString().padStart(2, '0');
// --- NEW: File size formatting utility ---
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, {once: true});
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }
        function applyGlobalCss(css) {
            const styleId = 'global-custom-css-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            styleElement.textContent = css || '';
        }
        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '这是我方气泡。';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '这是对方气泡。';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }
        // ===============================================================
// START: 钱包功能核心代码
// ===============================================================

// --- 交易记录 ---
function addTransaction(type, amount, description) {
    if (!db.wallet) return;
    
    // 1. 更新余额
    const numericAmount = parseFloat(amount);
    if (type === 'income') {
        db.wallet.balance += numericAmount;
    } else if (type === 'expense') {
        db.wallet.balance -= numericAmount;
    }
    db.wallet.balance = parseFloat(db.wallet.balance.toFixed(2)); // 避免精度问题

    // 2. 添加交易记录
    const transaction = {
        id: `tx_${Date.now()}`,
        type, // 'income' or 'expense'
        amount: numericAmount,
        description,
        timestamp: Date.now()
    };
    db.wallet.transactions.unshift(transaction); // unshift使最新记录在最前

    // 3. 限制交易记录数量，防止无限增长
    if (db.wallet.transactions.length > 200) {
        db.wallet.transactions.pop();
    }
    
    // 4. 更新UI显示
    const balanceDisplay = document.getElementById('wallet-balance-display');
    if (balanceDisplay) {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    }
}

// --- 支付流程处理 ---
function handlePayment(amount, description) {
    return new Promise((resolve, reject) => {
        // ▼▼▼ 新增的逻辑：检查密码是否启用 ▼▼▼
        if (db.wallet.passwordEnabled === false) {
            if (db.wallet.balance < amount) {
                reject(new Error('零花钱余额不足'));
                return;
            }
            // 直接扣款并成功返回，跳过密码环节
            addTransaction('expense', amount, description);
            resolve(); 
            return;
        }
        // ▲▲▲ 新增逻辑结束 ▲▲▲

        // 当密码启用时，执行原有的逻辑
        if (!db.wallet.password) {
            reject(new Error('请先前往“我”-“支付设置”设置支付密码！'));
            return;
        }
        if (db.wallet.balance < amount) {
            reject(new Error('零花钱余额不足'));
            return;
        }

        const modal = document.getElementById('payment-password-modal');
        const title = document.getElementById('payment-prompt-title');
        const desc = document.getElementById('payment-prompt-description');
        const passwordInput = document.getElementById('payment-password-input');
        const confirmBtn = document.getElementById('confirm-payment-btn');
        const cancelBtn = document.getElementById('cancel-payment-btn');

        title.textContent = description;
        desc.innerHTML = `<p style="font-size: 24px; font-weight: bold; margin: 10px 0;">¥ ${amount.toFixed(2)}</p>`;
        passwordInput.value = '';
        
        const confirmHandler = () => {
            if (passwordInput.value === db.wallet.password) {
                addTransaction('expense', amount, description);
                cleanup();
                resolve(); // 支付成功
            } else {
                showToast('支付密码错误');
                passwordInput.value = '';
            }
        };

        const cancelHandler = () => {
            cleanup();
            reject(new Error('支付已取消'));
        };
        
        const cleanup = () => {
            modal.classList.remove('visible');
            confirmBtn.removeEventListener('click', confirmHandler);
            cancelBtn.removeEventListener('click', cancelHandler);
            passwordInput.removeEventListener('keypress', keypressHandler);
        };
        
        const keypressHandler = (e) => {
            if(e.key === 'Enter') {
                confirmHandler();
            }
        };

        confirmBtn.addEventListener('click', confirmHandler);
        cancelBtn.addEventListener('click', cancelHandler);
        passwordInput.addEventListener('keypress', keypressHandler);

        modal.classList.add('visible');
        setTimeout(() => passwordInput.focus(), 100);
    });
}

// --- 渲染交易明细 ---
function renderTransactionDetails() {
    const container = document.getElementById('transaction-list-container');
    container.innerHTML = '';

    if (!db.wallet.transactions || db.wallet.transactions.length === 0) {
        container.innerHTML = '<li class="placeholder-text" style="padding: 20px 0;">暂无明细</li>';
        return;
    }

    db.wallet.transactions.forEach(tx => {
        const li = document.createElement('li');
        li.className = 'transaction-item';

        const date = new Date(tx.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        const amountSign = tx.type === 'income' ? '+' : '-';
        
        li.innerHTML = `
            <div class="transaction-details">
                <span class="transaction-description">${tx.description}</span>
                <span class="transaction-timestamp">${dateString}</span>
            </div>
            <span class="transaction-amount ${tx.type}">
                ${amountSign}${tx.amount.toFixed(2)}
            </span>
        `;
        container.appendChild(li);
    });
}

// --- 设置钱包所有功能的事件监听 ---
function setupWalletApp() {
    // 缓存DOM元素
    const walletScreen = document.getElementById('wallet-screen');
    const balanceDisplay = document.getElementById('wallet-balance-display');
    const settingsBtn = document.getElementById('wallet-settings-btn');
    const settingsScreen = document.getElementById('wallet-settings-screen');
    const settingsForm = document.getElementById('wallet-settings-form');
    const balanceInput = document.getElementById('wallet-balance-input');
    const passwordInput = document.getElementById('wallet-password-input');
    const transactionsBtn = document.getElementById('show-transactions-btn');
    const transactionsModal = document.getElementById('transaction-details-modal');
    const closeTransactionsBtn = document.getElementById('close-transactions-btn');

    // 监听导航到底部“我”按钮的点击事件
    document.querySelector('.nav-btn[data-target="wallet-screen"]').addEventListener('click', () => {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    });
    
// 从钱包主页跳转到设置页
settingsBtn.addEventListener('click', () => {
    const passwordEnabledToggle = document.getElementById('wallet-password-enabled-toggle');
    
    balanceInput.value = db.wallet.balance;
    passwordInput.value = db.wallet.password || '';
    passwordEnabledToggle.checked = db.wallet.passwordEnabled;
    passwordInput.disabled = !db.wallet.passwordEnabled; // 根据开关状态禁用/启用输入框
    
    // 监听开关的实时变化
    passwordEnabledToggle.onchange = (event) => {
        passwordInput.disabled = !event.target.checked;
        if (!event.target.checked) {
            passwordInput.value = ''; // 如果禁用，清空密码框
        }
    };
    
    switchScreen('wallet-settings-screen');
});

// 保存设置
settingsForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const newBalance = parseFloat(balanceInput.value);
    const newPassword = passwordInput.value;
    const passwordEnabled = document.getElementById('wallet-password-enabled-toggle').checked;

    if (passwordEnabled && newPassword && (newPassword.length !== 6 || !/^\d+$/.test(newPassword))) {
        showToast('支付密码必须为6位数字！');
        return;
    }

    db.wallet.balance = isNaN(newBalance) ? 0 : parseFloat(newBalance.toFixed(2));
    db.wallet.passwordEnabled = passwordEnabled;

    if (passwordEnabled) {
        db.wallet.password = newPassword || null;
    } else {
        db.wallet.password = null; // 禁用密码时，自动清除已保存的密码
    }

    await saveData();
    showToast('支付设置已保存！');
    switchScreen('wallet-screen');
    balanceDisplay.textContent = db.wallet.balance.toFixed(2);
});
    
    // 打开交易明细
    transactionsBtn.addEventListener('click', () => {
        renderTransactionDetails();
        transactionsModal.classList.add('visible');
    });

    // 关闭交易明细
    closeTransactionsBtn.addEventListener('click', () => {
        transactionsModal.classList.remove('visible');
    });
}

// ===============================================================
// END: 钱包功能核心代码
// ===============================================================
// ▼▼▼ 在 init() 函数的正上方，粘贴下面这个完整的新函数 ▼▼▼

function setupRollbackFeature() {
    const rollbackBtn = document.getElementById('rollback-btn');
    if (!rollbackBtn) return; // 安全检查，确保按钮存在

    // 为“撤回并重写”按钮绑定核心的点击事件
    rollbackBtn.addEventListener('click', async () => {
        // 如果AI正在生成中，则阻止操作
        if (isGenerating) {
            showToast('AI正在思考中，请稍后再试...');
            return;
        }

        // 获取当前的聊天对象
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
            
        if (!chat || chat.history.length === 0) return;

        // 1. 从后往前查找，定位到最后一个【用户】消息的位置
        let lastUserMessageIndex = -1;
        for (let i = chat.history.length - 1; i >= 0; i--) {
            if (chat.history[i].role === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        // 如果找不到用户消息，或者最后一条消息已经是用户消息，则说明没有可撤回的AI回复
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === chat.history.length - 1) {
            showToast('找不到可以重新生成的AI回复。');
            return;
        }

        // 2. 删除从最后一个用户消息之后的所有AI消息
        chat.history.splice(lastUserMessageIndex + 1);
        
        // 3. 更新界面显示，并保存数据
        renderMessages(false, true); // 重新渲染聊天气泡，并滚动到底部
        await saveData();
        renderChatList(); // 更新左侧列表的最后消息预览
        
        // 4. 再次调用AI，生成新的回复
        getAiReply();
    });
}
// ▲▲▲ 新函数到此结束 ▲▲▲
        const init = async () => {
            await loadData();
           applyGlobalCss(db.globalCustomCss);
            window.db = db;
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            
            applyGlobalFont(db.fontUrl);
            setupCustomWidgetSystem();
            setupHomeScreen();
            updateClock();
            setInterval(updateClock, 30000);
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
            setupFileSystem(); // --- NEW ---
            setupLocationSystem(); // --- NEW ---
            setupFileDisplaySystem(); 
          
            setupVoiceCallSystem();
            setupDiarySystem(); // --- 在这里添加这一行 ---
          setupDiarySystem();
            setupMusicPlayer();
            setupNotificationSystem();
            setupMomentsEventListeners();
setupTrajectorySystem();
 setupForumSystem();
          setupRollbackFeature(); 
  setupMemoriesSystem(); // <-- 添加这一行
  setupMemorySummaryModal(); 
  setupAiPovApp();
 };
             setupWalletApp(); // <-- 添加这一行


        // v-- 在这里（init 函数外部）添加下面的新函数 --v
        // (用下面的长代码块，完整替换掉你文件中已有的那个简短的 setupMusicPlayer 函数)
        function parseLRC(lrcContent) {
            if (!lrcContent) return [];
            const lines = lrcContent.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

            for (const line of lines) {
                const match = line.match(timeRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    const text = line.replace(timeRegex, '').trim();
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function updateLyrics(currentTime) {
            if (!parsedLyrics.length) return;

            // 寻找当前应该高亮的歌词行索引
            let newLyricIndex = parsedLyrics.findIndex(line => line.time > currentTime) - 1;
            if (newLyricIndex === -2) { // 如果播放时间超过了最后一句歌词
                newLyricIndex = parsedLyrics.length - 1;
            }
            if (newLyricIndex < 0) {
                 newLyricIndex = 0;
            }

            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsPanel = document.getElementById('lyrics-panel');
                const innerPanel = lyricsPanel.querySelector('.lyrics-panel-inner');
                const allLines = innerPanel.querySelectorAll('.lyric-line');

                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentLyricIndex);
                });

                // 计算滚动位置
                const activeLine = allLines[currentLyricIndex];
                if (activeLine) {
                    const panelHeight = lyricsPanel.clientHeight;
                    const activeLineOffset = activeLine.offsetTop + (activeLine.clientHeight / 2);
                    const scrollAmount = activeLineOffset - (panelHeight / 2);
                    innerPanel.style.transform = `translateY(-${scrollAmount}px)`;
                }
            }
        }
        function setupMusicPlayer() {
            // --- DOM 元素缓存 ---
            audioPlayer = document.getElementById('global-audio-player');
            const musicWidget = document.getElementById('music-app-widget');
            const musicModal = document.getElementById('music-player-modal');
            const playlistPanel = document.getElementById('music-playlist-panel');
            const addSongModal = document.getElementById('add-song-modal');
            const shareMusicModal = document.getElementById('share-music-modal');
            
            const playBtn = musicModal.querySelector('.play-btn');
            const nextBtn = musicModal.querySelector('.side-btn[title="下一首"]');
            const prevBtn = musicModal.querySelector('.side-btn[title="上一首"]');
            const loopBtn = musicModal.querySelector('.music-extra-controls button[title="循环模式"]');
            const openPlaylistBtn = musicModal.querySelector('.music-extra-controls button[title="歌曲列表"]');
            const openAddSongModalBtn = document.getElementById('open-add-song-modal-btn');
            const addSongForm = document.getElementById('add-song-form');
            const shareBtn = musicModal.querySelector('.share-btn');
            const confirmShareBtn = document.getElementById('confirm-music-share-btn');

            // --- 核心功能函数 ---
        // ▼▼▼ 请用这个【新的、完整的】函数替换掉您文件中旧的 updatePlayerUI 函数 ▼▼▼
const updatePlayerUI = () => {
    const song = db.playlist[currentSongIndex];
    const albumArt = musicModal.querySelector('.music-album-art');
    const songTitle = musicModal.querySelector('.song-title');
    const lyricsPanel = musicModal.querySelector('#lyrics-panel');
    const playBtn = musicModal.querySelector('.play-btn');

    // --- 核心修复：已经删除了所有对主屏幕小部件（widget）的无效操作 ---

    if (song) {
        const defaultArt = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
        albumArt.src = song.albumArt || defaultArt;
        songTitle.textContent = song.name;
        playBtn.innerHTML = isPlaying ? '<svg viewBox="0 0 24 24"><path d="M14,19H18V5H14M6,19H10V5H6V19Z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg>';
    } else {
        // 当没有歌曲时，只更新播放器弹窗内的标题
        songTitle.textContent = '歌曲名';
        if (lyricsPanel) {
            lyricsPanel.innerHTML = '<p class="lyric-line">歌词面板</p>';
        }
    }
};
// ▲▲▲ 替换到此结束 ▲▲▲

                                    const playSong = async (index) => {
                if (index < 0 || index >= db.playlist.length) {
                    isPlaying = false;
                    audioPlayer.pause();
                    currentSongIndex = -1;
                    updatePlayerUI();
                    return;
                }
                currentSongIndex = index;
                const song = db.playlist[index];
                audioPlayer.src = song.url;

                // --- 歌词处理 ---
                const lyricsPanel = document.getElementById('lyrics-panel');
                lyricsPanel.innerHTML = ''; // 清空旧歌词
                
                // ▼▼▼ 修正：移除了 let，直接给全局变量赋值 ▼▼▼
                parsedLyrics = [];
                currentLyricIndex = -1;
                // ▲▲▲ 修正结束 ▲▲▲

                if (song.lyrics) {
                    parsedLyrics = parseLRC(song.lyrics);
                }

                if (parsedLyrics.length > 0) {
                    const innerPanel = document.createElement('div');
                    innerPanel.className = 'lyrics-panel-inner';
                    parsedLyrics.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'lyric-line';
                        p.textContent = line.text;
                        innerPanel.appendChild(p);
                    });
                    lyricsPanel.appendChild(innerPanel);
                } else {
                    lyricsPanel.innerHTML = '<p class="lyric-line">暂无歌词</p>';
                }
                // --- 歌词处理结束 ---

                try {
                    await audioPlayer.play();
                    isPlaying = true;
                } catch (error) {
                    isPlaying = false;
                    showToast(`歌曲 ${song.name} 播放失败`);
                }
                updatePlayerUI();
                notifyAiOfSongChange();
            };

            const togglePlayPause = () => {
                if (isPlaying) {
                    audioPlayer.pause();
                    isPlaying = false;
                } else {
                    if (currentSongIndex === -1 && db.playlist.length > 0) {
                        playSong(0);
                    } else if (currentSongIndex !== -1) {
                        audioPlayer.play();
                        isPlaying = true;
                    } else {
                        showToast("播放列表为空, 请先添加歌曲");
                    }
                }
                updatePlayerUI();
            };
            
            const createShuffleOrder = () => {
                shuffleOrder = [...Array(db.playlist.length).keys()];
                for (let i = shuffleOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffleOrder[i], shuffleOrder[j]] = [shuffleOrder[j], shuffleOrder[i]];
                }
            };

            const playNext = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                    if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const nextIndexInShuffle = (currentIndexInShuffle + 1) % shuffleOrder.length;
                    playSong(shuffleOrder[nextIndexInShuffle]);
                } else {
                    const nextIndex = (currentSongIndex + 1) % db.playlist.length;
                    playSong(nextIndex);
                }
            };
            
            const playPrev = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                     if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const prevIndexInShuffle = (currentIndexInShuffle - 1 + shuffleOrder.length) % shuffleOrder.length;
                    playSong(shuffleOrder[prevIndexInShuffle]);
                } else {
                    const prevIndex = (currentSongIndex - 1 + db.playlist.length) % db.playlist.length;
                    playSong(prevIndex);
                }
            };

            const changePlaybackMode = async () => {
                const modes = ['sequential', 'loop', 'shuffle'];
                const currentModeIndex = modes.indexOf(db.musicPlayerSettings.playbackMode);
                const nextModeIndex = (currentModeIndex + 1) % modes.length;
                db.musicPlayerSettings.playbackMode = modes[nextModeIndex];
                
                if (db.musicPlayerSettings.playbackMode === 'shuffle') createShuffleOrder();
                else shuffleOrder = [];

                let iconHtml = '', toastMessage = '';
                switch (db.musicPlayerSettings.playbackMode) {
                    case 'loop':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/></svg>';
                        toastMessage = '单曲循环';
                        audioPlayer.loop = true;
                        break;
                    case 'shuffle':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M10.59,9.17L5.41,4L4,5.41L9.17,10.59L10.59,9.17M14.83,13.41L13.41,14.83L18,19.42L19.42,18L14.83,13.41M14.83,9.17L19.42,4.58L18,3.17L13.41,7.76L14.83,9.17M4.2,19.2L5.6,17.8L4.2,16.4L2.8,17.8L4.2,19.2M9.17,14.83L7.76,13.41L3.17,18L4.58,19.42L9.17,14.83Z"/></svg>';
                        toastMessage = '随机播放';
                        audioPlayer.loop = false;
                        break;
                    default:
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg>';
                        toastMessage = '顺序播放';
                        audioPlayer.loop = false;
                        break;
                }
                loopBtn.innerHTML = iconHtml;
                showToast(toastMessage);
                await saveData();
            };
            
            const renderPlaylistPanel = () => {
                const container = document.getElementById('playlist-container');
                container.innerHTML = '';
                if (db.playlist.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">播放列表是空的</p>';
                    return;
                }
                db.playlist.forEach((song, index) => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    if(index === currentSongIndex) li.style.backgroundColor = 'var(--bg-color)';
                    li.style.cssText += 'display: flex; justify-content: space-between; align-items: center;';
                    li.innerHTML = `
                        <div class="item-details" style="cursor: pointer; flex-grow: 1;">
                            <div class="item-name">${song.name}</div>
                            <div class="item-preview">${song.artist}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button class="btn btn-small" data-index="${index}" style="padding: 4px 8px; background-color: #eee; color: #333;">词</button>
                            <button class="btn btn-danger btn-small" data-index="${index}" style="padding: 4px 10px;">移除</button>
                        </div>
                    `;
                    li.querySelector('.item-details').addEventListener('click', () => {
                        playSong(index);
                        playlistPanel.classList.remove('visible');
                    });
                    li.querySelector('button.btn-danger').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        db.playlist.splice(index, 1);
                        if (currentSongIndex === index) { playNext(); } 
                        else if (currentSongIndex > index) { currentSongIndex--; }
                        await saveData();
                        renderPlaylistPanel();
                    });
                    li.querySelector('button[data-index]').addEventListener('click', async (e) => {
                         e.stopPropagation();
                         if(e.target.classList.contains('btn-danger')) return;
                         // 这是“词”按钮的逻辑
                         const lrcContent = await new Promise(resolve => {
                             const lrcInput = document.getElementById('lrc-upload-input');
                             const handler = (event) => {
                                 const file = event.target.files[0];
                                 if (file) {
                                     const reader = new FileReader();
                                     reader.onload = (re) => resolve(re.target.result);
                                     reader.readAsText(file);
                                 } else { resolve(null); }
                                 lrcInput.removeEventListener('change', handler);
                                 lrcInput.value = '';
                             };
                             lrcInput.addEventListener('change', handler);
                             lrcInput.click();
                         });
                         if (lrcContent !== null) {
                             db.playlist[index].lyrics = lrcContent;
                             await saveData();
                             showToast('歌词已关联！');
                             if (currentSongIndex === index) { playSong(index); }
                         }
                    });
                    container.appendChild(li);
                });
            };

                       const renderShareModal = () => {
                const container = document.getElementById('share-music-selection-list');
                container.innerHTML = '';
                const allChats = [...db.characters, ...db.groups];
                if (allChats.length === 0) {
                    container.innerHTML = '<li style="color:#888; text-align:center; padding: 20px 0;">没有可以分享的聊天</li>';
                    return;
                }
                allChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item'; // 复用现有样式
                    const isChecked = sharedWithChatIds.has(chat.id);
                    const name = chat.remarkName || chat.name;
                    const avatar = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    
                    li.innerHTML = `
                        <input type="checkbox" id="share-select-${chat.id}" value="${chat.id}" ${isChecked ? 'checked' : ''}>
                        <label for="share-select-${chat.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                            <img src="${avatar}" alt="${name}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                            <span>${name}</span>
                        </label>
                    `;
                    container.appendChild(li);
                });
            };
                    // ▼▼▼ 请用下面这【一整块】代码，完整替换掉你文件中旧的 sendMusicCard 函数 ▼▼▼
        const sendMusicCard = async (chatId, song) => {
            const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // --- 核心修复：使用更可靠的方式来判断聊天类型 ---
            // 如果 chat 对象有 .me 属性, 说明是群聊；否则就是单聊。
            const myName = chat.me ? chat.me.nickname : chat.myName;
            const content = `[${myName}分享了音乐：${song.name} - ${song.artist}]`;

            const message = { 
                id: `msg_music_${Date.now()}`, 
                role: 'user', 
                content, 
                parts: [{ type: 'text', text: content }], 
                timestamp: Date.now(), 
                senderId: 'user_me' 
            };
            
            chat.history.push(message);
            // 只有当分享的目标就是当前打开的聊天时，才立即在界面上添加气泡
            if (currentChatId === chatId) {
                addMessageBubble(message);
            }
        };
        // ▲▲▲ 替换结束 ▲▲▲
            const notifyAiOfSongChange = async () => {
                if (currentSongIndex === -1 || sharedWithChatIds.size === 0) return;
                
                const song = db.playlist[currentSongIndex];
                const notificationContent = `[system-context-only: 我正在听的歌曲已切换为: ${song.name} - ${song.artist}。歌词: ${song.lyrics || '无'}]`;
                
                for (const chatId of sharedWithChatIds) {
                    const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
                    if (chat) {
                        const message = { id: `msg_music_update_${Date.now()}`, role: 'user', content: notificationContent, parts: [{ type: 'text', text: notificationContent }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                    }
                }
                await saveData();
            };

            // --- 事件监听器 ---
            musicWidget.addEventListener('click', () => musicModal.classList.add('visible'));
            playBtn.addEventListener('click', togglePlayPause);
            nextBtn.addEventListener('click', playNext);
            prevBtn.addEventListener('click', playPrev);
            loopBtn.addEventListener('click', changePlaybackMode);
            openPlaylistBtn.addEventListener('click', () => { renderPlaylistPanel(); playlistPanel.classList.add('visible'); });
            openAddSongModalBtn.addEventListener('click', () => { addSongForm.reset(); addSongModal.classList.add('visible'); });

            addSongForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newSong = {
                    id: `song_${Date.now()}`,
                    url: document.getElementById('song-url-input').value.trim(),
                    name: document.getElementById('song-name-input').value.trim(),
                    artist: document.getElementById('song-artist-input').value.trim(),
                    albumArt: document.getElementById('song-album-art-input').value.trim(),
                    lyrics: document.getElementById('song-lyrics-input').value.trim()
                };
                if (!newSong.url.startsWith("https://files.catbox.moe/")) { showToast("请输入有效的Catbox链接"); return; }
                db.playlist.push(newSong);
                await saveData();
                showToast("歌曲已添加");
                addSongModal.classList.remove('visible');
                renderPlaylistPanel();
                if (currentSongIndex === -1) updatePlayerUI();
            });

            shareBtn.addEventListener('click', () => {
                if (currentSongIndex === -1) { showToast("请先播放一首歌曲再分享"); return; }
                renderShareModal();
                shareMusicModal.classList.add('visible');
            });
            
            confirmShareBtn.addEventListener('click', async () => {
                const checkboxes = shareMusicModal.querySelectorAll('input[type="checkbox"]');
                const song = db.playlist[currentSongIndex];
                let newShares = new Set();
                
                for (const cb of checkboxes) {
                    if (cb.checked) {
                        newShares.add(cb.value);
                        if (!sharedWithChatIds.has(cb.value)) await sendMusicCard(cb.value, song);
                    }
                }
                sharedWithChatIds = newShares;
                await notifyAiOfSongChange();
                
                shareMusicModal.classList.remove('visible');
                showToast("分享设置已更新");
            });

            audioPlayer.addEventListener('ended', () => { if (!audioPlayer.loop) playNext(); });
            audioPlayer.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); });
            audioPlayer.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); });
            // ... a few lines above this ...
            audioPlayer.addEventListener('timeupdate', () => { updateLyrics(audioPlayer.currentTime); });

            [musicModal, playlistPanel, addSongModal, shareMusicModal].forEach(el => {
                el.addEventListener('click', (e) => { if (e.target === el) el.classList.remove('visible'); });
            });
            
            // 初始化
            updatePlayerUI();
            if (db.playlist.length > 0) playSong(0); // 尝试自动播放第一首
        }
// ^-- 新函数到此结束 --^
        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日`;
        }

        // --- App Setup Functions ---
                function setupHomeScreen() {
            const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
            const homeScreenHTML = `
                <div class="time-widget">
                    <div class="date" id="date-display"></div>
                    <div class="time" id="time-display"></div>
                </div>
                <!-- === 新增：主页个人信息头图 开始 === -->
<div class="home-profile-header">
    <div class="home-hero"></div>
    <div class="home-avatar-wrap">
        <img id="home-profile-avatar" alt="头像" src="https://i.postimg.cc/GtbTnxhP/o-o-1.jpg">
    </div>
    <div class="home-info-card">
        <h2 class="home-profile-name">点击设置昵称</h2>
        <p class="home-profile-signature">点击设置个性签名</p>
    </div>
</div>
<!-- === 新增：主页个人信息头图 结束 === -->
                <div class="main-content-area">
                    <div class="left-column">
                        <div class="contact-widgets-column">
                         <div class="contact-widget" id="custom-widget-1" data-widget-id="widget1">
    <img src="https://i.ibb.co/6r11fGg/avatar1.png" alt="自定义组件1">
    <span>自定义</span>
</div>
<div class="contact-widget avatar-right" id="custom-widget-2" data-widget-id="widget2">
    <img src="https://i.ibb.co/d28n82t/avatar2.png" alt="自定义组件2">
    <span>自定义</span>
</div>
                        </div>
                        <div class="secondary-apps-dock">
                             <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="自定义" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                             <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="壁纸" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                        </div>
                    </div>

                    <div class="right-column">
                        <div class="small-app-grid">
                            <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                            <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                            <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="世界书" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                            <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="教程" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
                        </div>
                        <div id="music-app-widget" class="record-player-widget">
                            <div class="record-sleeve" id="custom-record-sleeve"></div>
                            <div class="vinyl-record">
                                <div class="record-label" id="custom-record-label"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="dock">
                    <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img"></a>
                    <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img"></a>
                    <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img"></a>
                 <a href="#" class="app-icon" data-target="ai-character-select-screen"><img src="${getIcon('ai-character-select-screen')}" alt="AI空间" class="icon-img"></a>
                </div>`;
            homeScreen.innerHTML = homeScreenHTML;

            // --- 这里是修正的部分 ---
            document.getElementById('custom-record-label').style.backgroundImage = `url('${getIcon('record-label')}')`;
            document.getElementById('custom-record-sleeve').style.backgroundImage = `url('${getIcon('record-sleeve')}')`;
            // --- 修正结束 ---
            
            const decorativeComponent = document.getElementById('custom-decorative-component');
            const decoURL = getIcon('decorative-component');
            if (decorativeComponent && decoURL) {
                decorativeComponent.style.backgroundImage = `url('${decoURL}')`;
                decorativeComponent.style.backgroundSize = 'cover';
                decorativeComponent.style.backgroundPosition = 'center';
            }

            updateClock();
            applyWallpaper(db.wallpaper);
            applyHomeScreenMode(db.homeScreenMode);
            // 从已保存的数据更新自定义组件的显示
const widget1Data = db.customWidgets.find(w => w.id === 'widget1');
const widget2Data = db.customWidgets.find(w => w.id === 'widget2');
const widget1El = document.getElementById('custom-widget-1');
const widget2El = document.getElementById('custom-widget-2');

if (widget1Data && widget1El) {
    widget1El.querySelector('img').src = widget1Data.imageUrl;
    widget1El.querySelector('span').textContent = widget1Data.text;
}
if (widget2Data && widget2El) {
    widget2El.querySelector('img').src = widget2Data.imageUrl;
    widget2El.querySelector('span').textContent = widget2Data.text;
}
            document.getElementById('day-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('day'); });
            document.getElementById('night-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('night'); });
            document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
            document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
            document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
            setupHomeScreenProfileEditor(); 
        }
        

        function applyWallpaper(url) {
            homeScreen.style.backgroundImage = `url(${url})`;
        }

        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', async (e) => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        await saveData();
                        setupHomeScreen();
                    }
                }
            });
            customizeForm.addEventListener('click', async (e) => {
                if (e.target.matches('.reset-icon-btn')) {
                    const iconId = e.target.dataset.id;
                    delete db.customIcons[iconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    showToast('图标已重置');
                }
            });
        }

                function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            // --- Part 1: 原有的图标自定义功能 ---
            Object.entries(defaultIcons).forEach(([id, {
                name,
                url
            }]) => {
                const currentIcon = db.customIcons[id] || url;
                const itemHTML = `
                <div class="icon-custom-item">
                    <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                    <div class="icon-details">
                        <p>${name || '模式切换'}</p>
                        <input type="url" class="form-group" placeholder="粘贴新的图标URL" value="${db.customIcons[id] || ''}" data-id="${id}">
                    </div>
                    <button type="button" class="reset-icon-btn" data-id="${id}">重置</button>
                </div>`;
                customizeForm.insertAdjacentHTML('beforeend', itemHTML);
            });

            // --- Part 2: 新增的全局CSS自定义功能 ---
            const globalCssHtml = `
                <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
                <div class="global-css-section">
                    <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">全局样式 (CSS) 自定义</p>
                    <p style="font-size: 13px; color: #888; margin-top: 0; margin-bottom: 15px;">这里的代码会覆盖整个应用的默认样式，请谨慎使用。</p>
                    <textarea id="global-custom-css" rows="12" placeholder="/* 示例：修改聊天气泡和对方名字颜色 */\n\n.message-bubble.sent {\n  background: linear-gradient(to right, #6a11cb 0%, #2575fc 100%);\n}\n\n.item-name {\n  color: #6a11cb !important;\n}" style="width: 100%; border-radius: 10px; padding: 10px; border: 2px solid #fce4ec; font-family: monospace; font-size: 13px;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button type="button" class="btn btn-primary" id="apply-global-css-btn" style="flex: 1;">应用样式</button>
                        <button type="button" class="btn btn-secondary" id="export-global-css-btn" style="flex: 1; margin-bottom: 0;">导出</button>
                        <label for="import-css-input" class="btn btn-neutral" style="flex: 1; margin-bottom: 0;">导入</label>
                    </div>
                </div>
                <input type="file" id="import-css-input" accept=".yu, .css, .txt" style="display: none;">
            `;
            customizeForm.insertAdjacentHTML('beforeend', globalCssHtml);

            // --- Part 3: 为新功能绑定事件 ---
            const cssTextarea = document.getElementById('global-custom-css');
            if (cssTextarea && db.globalCustomCss) {
                cssTextarea.value = db.globalCustomCss;
            }

            document.getElementById('apply-global-css-btn').addEventListener('click', async () => {
                const cssCode = cssTextarea.value;
                db.globalCustomCss = cssCode;
                applyGlobalCss(cssCode);
                await saveData();
                showToast('全局样式已应用并保存！');
            });

            document.getElementById('export-global-css-btn').addEventListener('click', () => {
                const cssCode = cssTextarea.value;
                if (!cssCode.trim()) {
                    showToast('没有内容可导出。');
                    return;
                }
                const blob = new Blob([cssCode], {
                    type: 'text/plain'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `饭版小手机_美化样式.yu`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            document.getElementById('import-css-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    cssTextarea.value = e.target.result;
                    showToast('样式已导入，请点击“应用样式”来保存并查看效果。');
                };
                reader.onerror = () => {
                    showToast('读取文件失败。');
                };
                reader.readAsText(file);
                event.target.value = null; 
            });
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }
        let loadingBtn = false

        function renderTutorialContent() {
            const tutorials = [
                {title: '写在前面', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: '软件介绍',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-群聊', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']}
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}教程图片">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });

            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = '备份数据';
            backupDataBtn.disabled = loadingBtn

            backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return
                }
                loadingBtn = true
                try {
                    // ▼▼▼ 第1步：在这里添加代码 ▼▼▼
                    // 在打包主数据之前，先从“动态”数据库中读取所有动态
                    if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                        const momentsData = await window.AppDB_Moments.moments.toArray();
                        // 临时将动态数据附加到主 `db` 对象上，以便一起备份
                        db.momentsData = momentsData;
                    }
                    // ▲▲▲ 添加结束 ▲▲▲

                    const jsonString = JSON.stringify(db);
                    const dataBlob = new Blob([jsonString]);

                    // Compress the data using Gzip
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();

                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    const now = new Date();
                    const date = now.toISOString().slice(0, 10);
                    const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                    a.href = url;
                    a.download = `章鱼喷墨_备份数据_${date}_${time}.ee`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // ▼▼▼ 在备份完成后，清理掉临时的动态数据 ▼▼▼
                    if (db.momentsData) {
                        delete db.momentsData;
                    }
                    // ▲▲▲ 清理结束 ▲▲▲

                    loadingBtn = false
                    showToast('聊天记录导出成功');
                }catch (e){
                    showToast(`导出失败, 发生错误: ${e.message}`);
                }
            });
            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = '导入数据';
            importDataBtn.style.marginTop = '15px'
            importDataBtn.style.display = 'block'
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input')
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('此操作将覆盖当前所有聊天记录和设置。此操作不可撤销。确定要继续吗？')){
                    try {
                        // Decompress the file stream
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();

                        let data = JSON.parse(jsonString);

                        // ▼▼▼ 第2步：在这里添加代码 ▼▼▼
                        // 检查备份文件中是否存在动态数据
                        if (data.momentsData && Array.isArray(data.momentsData)) {
                            const momentsToRestore = data.momentsData;
                            // 从主数据中删除临时的动态数据，以免被错误地保存
                            delete data.momentsData;

                            // 开始恢复动态
                            if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                // 先清空当前的动态数据库
                                await window.AppDB_Moments.moments.clear();
                                // 再将备份的动态数据批量写入
                                await window.AppDB_Moments.moments.bulkPut(momentsToRestore);
                                console.log(`${momentsToRestore.length} 条动态已成功恢复。`);
                            }
                        }
                        // ▲▲▲ 添加结束 ▲▲▲

                        await saveData(data)
                        showToast(`数据已成功恢复。应用即将刷新。`);
                        setTimeout(() => window.location.reload(), 1500); // 延迟刷新以确保toast可见
                    } catch (error) {
                        console.error("导入失败:", error);
                        showToast(`解压或解析文件时发生错误: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                }else {
                    event.target.value = null;
                }

            })

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(importDataBtn);
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '取消置顶' : '置顶聊天',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: '删除聊天',
                danger: true,
                action: async () => {
                    if (confirm(`确定要删除与“${itemName}”的聊天记录吗？此操作不可恢复。`)) {
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }
                        await saveData();
                        renderChatList();
                        showToast('聊天已删除');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [...db.characters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({
                ...g,
                type: 'group'
            }))];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            sortedChats.forEach(chat => {
                let lastMessageText = '开始聊天吧...';
                if (chat.history && chat.history.length > 0) {
                const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[system-context-only:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/; // <-- 添加这里: 在 [system:.*?] 后面加上 |\[system-context-only:.*?\]
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?发来了一张图片：\]/
                        const voiceRegex = /\[.*?的语音：.*?\]/;
                        const photoVideoRegex = /\[.*?发来的照片\/视频：.*?\]/;
                        const transferRegex = /\[.*?的转账：.*?元.*?\]|\[.*?给你转账：.*?元.*?\]|\[.*?向.*?转账：.*?元.*?\]/;
                        const stickerRegex = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/;
                        const giftRegex = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/;



                        if (giftRegex.test(lastMsg.content)) {
                            lastMessageText = '[礼物]';
                        } else if (stickerRegex.test(lastMsg.content)) {
                            lastMessageText = '[表情包]';
                        } else if (voiceRegex.test(lastMsg.content)) {
                            lastMessageText = '[语音]';
                        } else if (photoVideoRegex.test(lastMsg.content)) {
                            lastMessageText = '[照片/视频]';
                        } else if (transferRegex.test(lastMsg.content)) {
                            lastMessageText = '[转账]';
                        } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                            lastMessageText = '[图片]';
                        }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                            lastMessageText = '[互动]';
                        } else {
                            const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[图片]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
                        const renameRegex = /\[.*?修改群名为：.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) {
                            lastMessageText = timeSkipMatch[1];
                        } else if (inviteRegex.test(lastEverMsg.content)) {
                            lastMessageText = '新成员加入了群聊';
                        } else if (renameRegex.test(lastEverMsg.content)) {
                            lastMessageText = '群聊名称已修改';
                        }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">置顶</span>' : '';
                li.innerHTML = `
                <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
                <div class="item-details">
                    <div class="item-details-row"><div class="item-name">${itemName}</div></div>
                    <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${pinBadgeHTML}</div>
                </div>`;
                chatListContainer.appendChild(li);
            });
        }

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    diaries: [],
    messageCountSinceLastDiary: 0,
    // --- 添加结束 ---
                    memories: [], // <-- 添加这行
                    isPinned: false,
                    status: '在线',
                    worldBookIds: [],
                    useCustomBubbleCss: false,
                    customBubbleCss: ''
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`角色“${newChar.remarkName}”创建成功！`);
            });
        }
// --- 在 setupChatRoom() 函数的前面，粘贴下面的代码块 ---

function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}

        function setupChatRoom() {
            sendMessageBtn.addEventListener('click', sendMessage);
            sendMessageBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                sendMessage();
                setTimeout(() => {
                    messageInput.focus();
                }, 50);
            });
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !isGenerating) sendMessage();
            });
            getReplyBtn.addEventListener('click', getAiReply);
            messageArea.addEventListener('click', (e) => {
                // --- 修复开始: 增加关闭表情包面板的逻辑 ---
                if (stickerModal.classList.contains('visible')) {
                    stickerModal.classList.remove('visible');
                    // 阻止事件继续传播，避免立即触发其他点击效果
                    return;
                }
                // --- 修复结束 ---

                if (e.target && e.target.id === 'load-more-btn') {
                    loadMoreMessages();
                } else if (isInMultiSelectMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) {
                        toggleMessageSelection(messageWrapper.dataset.id);
                    }
                } else {
                    const voiceBubble = e.target.closest('.voice-bubble');
                    if (voiceBubble) {
                        const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
                        if (transcript) {
                            transcript.classList.toggle('active');
                        }
                    }
                    const pvCard = e.target.closest('.pv-card');
                    if (pvCard) {
                        const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
                        const footer = pvCard.querySelector('.pv-card-footer');
                        imageOverlay.classList.toggle('hidden');
                        footer.classList.toggle('hidden');
                    }
                    const giftCard = e.target.closest('.gift-card');
                    if (giftCard) {
                        const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                        if (description) {
                            description.classList.toggle('active');
                        }
                    }
    // --- NEW: Add this block for location card clicks ---
    const locationCard = e.target.closest('.location-card');
    if (locationCard) {
        const mainLoc = locationCard.dataset.locationMain;
        const detailLoc = locationCard.dataset.locationDetail;
        
        displayLocationMain.textContent = mainLoc;
        displayLocationDetail.textContent = detailLoc;
        // You could potentially use a mapping API here to show a real map image
        // For now, we use a placeholder.
        
        displayLocationModal.classList.add('visible');
        return; // Stop further processing
    }
    // --- End of new block ---
                    const transferCard = e.target.closest('.transfer-card.received-transfer');
                    if (transferCard && currentChatType === 'private') {
                        const messageWrapper = transferCard.closest('.message-wrapper');
                        const messageId = messageWrapper.dataset.id;
                        const character = db.characters.find(c => c.id === currentChatId);
                        const message = character.history.find(m => m.id === messageId);
                        if (message && message.transferStatus === 'pending') {
                            handleReceivedTransferClick(messageId);
                        }
                    }
                }
            });
            messageArea.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
            });
            messageArea.addEventListener('touchstart', (e) => {
                if (e.target.id === 'load-more-btn') return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
                }, 400);
            });
            messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
            messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            saveEditBtn.addEventListener('click', saveMessageEdit);
            cancelEditBtn.addEventListener('click', cancelMessageEdit);
            cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
            deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
            document.getElementById('cancel-quote-reply-btn').addEventListener('click', cancelQuoteReply);
        }

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?的语音：.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?发来的照片\/视频：.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?给你转账：.*?\]|\[.*?的转账：.*?\]|\[.*?向.*?转账：.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            menuItems.push({label: '引用', action: () => startQuoteReply(messageId)});

    if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
        menuItems.push({label: '编辑', action: () => startMessageEdit(messageId)});
    }
    menuItems.push({label: '删除', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?的消息：([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            messageEditInput.value = contentToEdit;
            messageInputDefault.style.display = 'none';
            messageEditBar.style.display = 'flex';
            messageEditInput.focus();
        }

        async function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            const newText = messageEditInput.value.trim();
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?的消息：)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if (chat.history[messageIndex].parts) {
                    chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
                }
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            messageInputDefault.style.display = 'flex';
            messageEditBar.style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `已选择 ${selectedMessageIds.size} 项`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`已删除 ${deletedCount} 条消息`);
        }

 function openChatRoom(chatId, type) {
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;

            exitMultiSelectMode();
            cancelMessageEdit();

            // 获取所有需要根据聊天类型切换显示的按钮
            const diaryBtn = document.getElementById('diary-btn');
            const trajectoryBtn = document.getElementById('ai-trajectory-btn');
            const memoriesBtn = document.getElementById('ai-memories-btn');

            // 根据聊天类型（私聊或群聊）统一设置按钮的可见性
            if (type === 'private') {
                // 私聊时，显示所有相关功能按钮
                voiceCallBtn.style.display = 'flex';
                diaryBtn.style.display = 'flex';
                trajectoryBtn.style.display = 'flex';
                memoriesBtn.style.display = 'flex';
            } else { 
                // 群聊时，隐藏所有私聊专属功能按钮
                voiceCallBtn.style.display = 'none';
                diaryBtn.style.display = 'none';
                trajectoryBtn.style.display = 'none';
                memoriesBtn.style.display = 'none';
            }

            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || '在线';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            chatRoomScreen.style.setProperty('--bubble-scale', type === 'group' ? (chat.bubbleScale || 1) : 1);
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            currentPage = 1;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            renderMessages(false, true);
            switchScreen('chat-room-screen');
        }

        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;
            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);
            if (!isLoadMore) messageArea.innerHTML = '';
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            messageArea.prepend(fragment);
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '加载更早的消息';
                messageArea.prepend(loadMoreButton);
            }
            if (forceScrollToBottom) {
                setTimeout(() => {
                    messageArea.scrollTop = messageArea.scrollHeight;
                                 }, 0);
            } else if (isLoadMore) {
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
        }

        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

         function createMessageBubbleElement(message) {
      if (message.content.startsWith('[system-context-only:')) {
        return null; // 如果是仅供AI上下文参考的消息，直接返回null，不创建任何HTML元素
    }      
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const {role, content, timestamp, id, transferStatus, giftStatus, stickerData, senderId} = message;

    const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
    const offlineSceneRegex = /\[offline-scene:([\s\S]+?)\]/;
    const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
    const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
    const timeSkipMatch = content.match(timeSkipRegex);
    const offlineSceneMatch = content.match(offlineSceneRegex);
    const inviteMatch = content.match(inviteRegex);
    const renameMatch = content.match(renameRegex);
    const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]/;
    if (invisibleRegex.test(content)) {
        return null;
    }

    const wrapper = document.createElement('div');
    wrapper.dataset.id = id;

    if (timeSkipMatch || inviteMatch || renameMatch || offlineSceneMatch) {
        wrapper.className = 'message-wrapper system-notification';
        let bubbleText = '';
        if (timeSkipMatch) bubbleText = timeSkipMatch[1];
        if (offlineSceneMatch) bubbleText = offlineSceneMatch[1].replace(/\n/g, '<br>');
        if (inviteMatch) bubbleText = `${inviteMatch[1]}邀请${inviteMatch[2]}加入了群聊`;
        if (renameMatch) bubbleText = `${renameMatch[1]}修改群名为“${renameMatch[2]}”`;
        wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
        return wrapper;
    }

    const isSent = (role === 'user');
    let avatarUrl, bubbleTheme, senderNickname = '';
    const themeKey = chat.theme || 'white_pink';
    const theme = colorThemes[themeKey] || colorThemes['white_pink'];
    let messageSenderId = isSent ? 'user_me' : senderId;

    if (isSent) {
        avatarUrl = (currentChatType === 'private') ? chat.myAvatar : chat.me.avatar;
        bubbleTheme = theme.sent;
    } else {
        if (currentChatType === 'private') {
            avatarUrl = chat.avatar;
        } else { // Group chat received
            const sender = chat.members.find(m => m.id === senderId);
            if (sender) {
                avatarUrl = sender.avatar;
                senderNickname = sender.groupNickname;
            } else { // Fallback for unknown sender
                avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            }
        }
        bubbleTheme = theme.received;
    }
    const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
    wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
    if (currentChatType === 'group' && !isSent) {
        wrapper.classList.add('group-message');
    }
    const bubbleRow = document.createElement('div');
    bubbleRow.className = 'message-bubble-row';
    let bubbleElement;
    const aiQuoteRegex = /\[(?:.*?)引用了“(?:.*?:)?\s?([\s\S]+?)”的消息?并回复：([\s\S]+?)\]/;
    const aiQuoteMatch = content.match(aiQuoteRegex);

    const musicShareRegex = /\[(?:.*?)分享了音乐：([\s\S]+?) - ([\s\S]+?)\]/;
    const musicMatch = content.match(musicShareRegex);

    const locationRegex = /\[(.*?)的位置共享：主位置 '(.*?)', 详细位置 '(.*?)'\]|\[(.*?)分享了位置：主位置 '(.*?)', 详细位置 '(.*?)'\]/i;
    const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
    const sentStickerRegex = /\[(?:.+?)的表情包：.+?\]/i;
    const receivedStickerRegex = /\[(?:.+?)发送的表情包：([\s\S]+?)\]/i;
    // ▼▼▼ 修正后的位置：在这里定义新规则 ▼▼▼
    const bareImageLinkRegex = /^\[(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg))\]$/i;
    // ▲▲▲ 修正结束 ▲▲▲
    const voiceRegex = /\[(?:.+?)的语音：([\s\S]+?)\]/;
    const photoVideoRegex = /\[(?:.+?)发来的照片\/视频：([\s\S]+?)\]/;
    const privateSentTransferRegex = /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/;
    const privateReceivedTransferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
    const groupTransferRegex = /\[(.*?)\s*向\s*(.*?)\s*转账：([\d.]+)元；备注：(.*?)\]/;
    const privateGiftRegex = /\[(?:.+?)送来的礼物：([\s\S]+?)\]/;
    const groupGiftRegex = /\[(.*?)\s*向\s*(.*?)\s*送来了礼物：([\s\S]+?)\]/;
    const imageRecogRegex = /\[.*?发来了一张图片：\]/;
    const textRegex = /\[(?:.+?)的消息：([\s\S]+?)\]/;

    const sentStickerMatch = content.match(sentStickerRegex);
    const receivedStickerMatch = content.match(receivedStickerRegex);
    const bareImageLinkMatch = content.match(bareImageLinkRegex); // 使用新规则进行匹配
    const voiceMatch = content.match(voiceRegex);
    const photoVideoMatch = content.match(photoVideoRegex);
    const privateSentTransferMatch = content.match(privateSentTransferRegex);
    const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
    const groupTransferMatch = content.match(groupTransferRegex);
    const privateGiftMatch = content.match(privateGiftRegex);
    const groupGiftMatch = content.match(groupGiftRegex);
    const imageRecogMatch = content.match(imageRecogRegex);
    const textMatch = content.match(textRegex);
    const locationMatch = content.match(locationRegex);

    if (message.quote || aiQuoteMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
        let quotedSender, quotedText, replyText;
        if (message.quote) {
            quotedSender = message.quote.sender;
            quotedText = message.quote.content;
            replyText = message.replyText;
        } else {
            quotedSender = senderNickname || (currentChatType === 'private' ? chat.remarkName : '群成员');
            quotedText = aiQuoteMatch[1].trim();
            replyText = aiQuoteMatch[2].trim();
        }
        bubbleElement.innerHTML = `
            <div class="quoted-content">
                <div class="quoted-sender">${quotedSender}</div>
                <div class="quoted-text">${quotedText}</div>
            </div>
            <div class="reply-text">${replyText}</div>
        `;
        } else if (musicMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'music-card';
        const songTitle = musicMatch[1].trim();
        const artist = musicMatch[2].trim();
        bubbleElement.innerHTML = `<img src="https://i.postimg.cc/d10J4VzR/image.png" alt="music icon" class="music-card-icon"><div class="music-card-info"><p class="music-card-title">${songTitle}</p><p class="music-card-artist">${artist}</p></div>`;
    
    // ================== 从这里开始是修正后的代码 ==================

    } else if (message.fileData && message.fileData.name) { // 1. 处理用户发送的文件
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'file-card';
        const fileSize = formatFileSize(new Blob([message.fileData.content]).size);
        bubbleElement.innerHTML = `<img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${message.fileData.name}</p><p class="file-card-size">${fileSize}</p></div>`;
        
        // 为点击事件添加数据属性
        bubbleElement.dataset.fileName = message.fileData.name;
        bubbleElement.dataset.fileContent = message.fileData.content;

    } else if (content.match(/\[(?:.+?)发送了文件：({.*?})\]/)) { // 2. 新增：处理AI发送的文件
        const fileMatchAI = content.match(/\[(?:.+?)发送了文件：({.*?})\]/);
        try {
            const fileData = JSON.parse(fileMatchAI[1]);
            const fileName = fileData.name || '未命名文件.txt';
            const fileContent = fileData.content || '[文件内容为空]';

            bubbleElement = document.createElement('div');
            bubbleElement.className = 'file-card';
            const fileSize = formatFileSize(new Blob([fileContent]).size);
            bubbleElement.innerHTML = `<img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${fileName}</p><p class="file-card-size">${fileSize}</p></div>`;
            
            // 同样为点击事件添加数据属性
            bubbleElement.dataset.fileName = fileName;
            bubbleElement.dataset.fileContent = fileContent;

        } catch (e) {
            console.error("解析AI文件数据失败:", e);
            bubbleElement = document.createElement('div');
            bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
            bubbleElement.textContent = '[AI尝试发送文件，但格式错误]';
        }

    } else if (message.locationData || locationMatch) { // 3. 处理位置信息
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'location-card';
        let mainLoc, detailLoc;
        if (message.locationData) {
            mainLoc = message.locationData.main;
            detailLoc = message.locationData.detail;
        } else {
            mainLoc = locationMatch[2] || locationMatch[5];
            detailLoc = locationMatch[3] || locationMatch[6];
        }
        bubbleElement.dataset.locationMain = mainLoc;
        bubbleElement.dataset.locationDetail = detailLoc;
        bubbleElement.innerHTML = `<div><div class="location-card-info"><p class="location-main">${mainLoc}</p><p class="location-detail">${detailLoc}</p></div><div class="location-map"></div></div>`;
    
    // ================== 修正代码到此结束 ==================
    
    } else if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'image-bubble';
        let stickerSrc = '';
        if (isSent) {
            stickerSrc = stickerData;
        } else {
            const rawText = receivedStickerMatch[1].trim();
            const urlMatch = rawText.match(/https?:\/\/[^\s\])]+/);
            if (urlMatch) {
                stickerSrc = urlMatch[0];
            } else {
                const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                const extractedPathMatch = rawText.match(pathExtractionRegex);
                const finalPath = extractedPathMatch ? extractedPathMatch[0] : rawText;
                stickerSrc = `https://i.postimg.cc/${finalPath}`;
            }
        }
        bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="表情包">`;
    } else if (!isSent && bareImageLinkMatch) {
        // ▼▼▼ 这就是我们新增的、完整的处理逻辑 ▼▼▼
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'image-bubble';
        const imageUrl = bareImageLinkMatch[1];
        bubbleElement.innerHTML = `<img src="${imageUrl}" alt="表情包">`;
  // === ✅ 正确的最终代码 (请完整复制替换) ===

} else if (privateGiftMatch || groupGiftMatch) {
    const match = privateGiftMatch || groupGiftMatch;
    bubbleElement = document.createElement('div');
    bubbleElement.className = 'gift-card';
    if (giftStatus === 'received') {
        bubbleElement.classList.add('received');
    }
    let giftText;
    if (groupGiftMatch) {
        const from = groupGiftMatch[1];
        const to = groupGiftMatch[2];
        giftText = isSent ? `你送给 ${to} 的礼物` : `${from} 送给 ${to} 的礼物`;
    } else {
        giftText = isSent ? '您有一份礼物～' : '您有一份礼物～';
    }
    bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">已查收</div>`;
    const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
    const descriptionDiv = document.createElement('div');
    descriptionDiv.className = 'gift-card-description';
    descriptionDiv.textContent = description;
    wrapper.appendChild(descriptionDiv);
} else if (voiceMatch) {
    bubbleElement = document.createElement('div');
    bubbleElement.className = 'voice-bubble';
    if (!chat.useCustomBubbleCss) {
        bubbleElement.style.backgroundColor = bubbleTheme.bg;
        bubbleElement.style.color = bubbleTheme.text;
    }
    bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
    const transcriptDiv = document.createElement('div');
    transcriptDiv.className = 'voice-transcript';
    transcriptDiv.textContent = voiceMatch[1].trim();
    wrapper.appendChild(transcriptDiv);
} else if (photoVideoMatch) {
    bubbleElement = document.createElement('div');
    bubbleElement.className = 'pv-card';
    bubbleElement.innerHTML = `<div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>照片/视频・点击查看</span></div>`;
} else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
    const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
    const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;
    let amount, remarkText, titleText;
    if (groupTransferMatch) {
        const from = groupTransferMatch[1];
        const to = groupTransferMatch[2];
        amount = parseFloat(groupTransferMatch[3]).toFixed(2);
        remarkText = groupTransferMatch[4] || '';
        titleText = isSent ? `向 ${to} 转账` : `${from} 向你转账`;
    } else {
        amount = parseFloat(match[1]).toFixed(2);
        remarkText = match[2] || '';
        titleText = isSentTransfer ? '给你转账' : '转账';
    }
    bubbleElement = document.createElement('div');
    bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;
    let statusText = isSentTransfer ? '待查收' : '转账给你';
    if (groupTransferMatch && !isSent) statusText = '转账给Ta';
    if (transferStatus === 'received') {
        statusText = '已收款';
        bubbleElement.classList.add('received');
    } else if (transferStatus === 'returned') {
        statusText = '已退回';
        bubbleElement.classList.add('returned');
    }
    if ((transferStatus !== 'pending' && currentChatType === 'private') || currentChatType === 'group') {
        bubbleElement.style.cursor = 'default';
    }
    const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
    bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;
} else if (imageRecogMatch || urlRegex.test(content)) {
    bubbleElement = document.createElement('div');
    bubbleElement.className = 'image-bubble';
    bubbleElement.innerHTML = `<img src="${content}" alt="图片消息">`;

// +++ 把新的HTML小剧场逻辑粘贴在这里 +++
} else if (message.parts && message.parts[0] && message.parts[0].type === 'html') {
        bubbleElement = document.createElement('div');
        // 使用一个专用的class来包裹，方便CSS控制，且不带默认气泡样式
        bubbleElement.className = 'ai-generated-theater'; 
        
        // 【关键修复】: 使用 innerHTML 来渲染HTML内容
        // message.parts[0].text 中存放着 getMixedContent 解析出的干净HTML代码
        bubbleElement.innerHTML = message.parts[0].text;

// --- 用这个更健壮的文本处理逻辑替换掉原来的 else if (textMatch) 和最后的 else { ... } ---
} else {
    bubbleElement = document.createElement('div');
    bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;

    const textMatch = content.match(/\[(?:.+?)的消息：([\s\S]+?)\]/);
    let innerText = textMatch ? textMatch[1].trim() : content.trim();

    if (urlRegex.test(innerText)) {
        bubbleElement.className = 'image-bubble';
        bubbleElement.innerHTML = `<img src="${innerText}" alt="图片消息">`;
    } else {
        bubbleElement.innerHTML = innerText.replace(/\n/g, '<br>');
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
    }
}

// === 替换到此结束 ===
    const nicknameHTML = (currentChatType === 'group' && !isSent && senderNickname) ? `<div class="group-nickname">${senderNickname}</div>` : '';
    bubbleRow.innerHTML = `<div class="message-info">${nicknameHTML}<img src="${avatarUrl}" class="message-avatar"><span class="message-time">${timeString}</span></div>`;
    if (bubbleElement) {
        bubbleRow.appendChild(bubbleElement);
    }
    wrapper.prepend(bubbleRow);
    return wrapper;
}


        async function addMessageBubble(message) {
    // --- Voice Call Handling ---
    const callInitiateRegex = /\[call:(.*?)\]/;
    const callInitiateMatch = message.content.match(callInitiateRegex);
    if (callInitiateMatch && message.role === 'assistant') {
        const character = db.characters.find(c => c.realName === callInitiateMatch[1]);
        if (character) {
            startAiInitiatedCall(character.id);
        }
        return; // 阻止显示 [call:...] 这条指令消息
    }
    // --- End Voice Call Handling ---

      if (currentChatType === 'private') {
            const character = db.characters.find(c => c.id === currentChatId);
            // ✨✨✨ 新增的状态更新处理逻辑 ✨✨✨
            const updateStatusRegex = new RegExp(`\\[${character.realName}更新状态为：(.*?)\\]`);
            const statusMatch = message.content.match(updateStatusRegex);
            if (statusMatch) {
                const newStatus = statusMatch[1];
                character.status = newStatus; // 更新数据库中的状态
                chatRoomStatusText.textContent = newStatus; // 更新聊天顶部的状态显示
                await saveData(); // 保存更改
                return; // ✨ 重要：直接返回，不把这条指令显示在聊天界面上
            }
            // ✨✨✨ 新增逻辑结束 ✨✨✨


        const transferActionRegex = new RegExp(`\\[${character.realName}(接收|退回)${character.myName}的转账\\]`);
        const giftReceivedRegex = new RegExp(`\\[${character.realName}已接收礼物\\]`);
        // if (systemMessageRegex.test(message.content)) { /* Do nothing for context messages */
        // }
        if (message.content.match(updateStatusRegex)) {
            character.status = message.content.match(updateStatusRegex)[1];
            chatRoomStatusText.textContent = character.status;
            await saveData();
            return;
        }
        if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
            const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('送来的礼物：') && m.giftStatus !== 'received');
            if (lastPendingGiftIndex !== -1) {
                const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                const giftMsg = character.history[actualIndex];
                giftMsg.giftStatus = 'received';
                const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                if (giftCardOnScreen) {
                    giftCardOnScreen.classList.add('received');
                }
                await saveData();
            }
            return;
        }
        if (message.content.match(transferActionRegex) && message.role === 'assistant') {
            const action = message.content.match(transferActionRegex)[1];
            const statusToSet = action === '接收' ? 'received' : 'returned';
            const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('给你转账：') && m.transferStatus === 'pending');
            if (lastPendingTransferIndex !== -1) {
                const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                const transferMsg = character.history[actualIndex];
                transferMsg.transferStatus = statusToSet;
                const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${transferMsg.id}"] .transfer-card`);
                if (transferCardOnScreen) {
                    transferCardOnScreen.classList.remove('received', 'returned');
                    transferCardOnScreen.classList.add(statusToSet);
                    const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                    if (statusElem) statusElem.textContent = statusToSet === 'received' ? '已收款' : '已退回';
                }
                await saveData();
            }
        } else {
            const bubbleElement = createMessageBubbleElement(message);
            if (bubbleElement) {
                messageArea.appendChild(bubbleElement);
                messageArea.scrollTop = messageArea.scrollHeight;
            }
        }
    } else { // For group chats
        const bubbleElement = createMessageBubbleElement(message);
        if (bubbleElement) {
            messageArea.appendChild(bubbleElement);
            messageArea.scrollTop = messageArea.scrollHeight;
        }
    }
}
        async function sendMessage() {
    const text = messageInput.value.trim();
    if (!text || isGenerating) return;

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    let message;
    const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;

    if (currentQuotedMessageId) {
        // 处理引用回复
        const originalMessage = chat.history.find(m => m.id === currentQuotedMessageId);
        if (!originalMessage) {
            cancelQuoteReply();
            return; 
        }
        
        let originalSenderName = '';
        let cleanOriginalContent = originalMessage.content;

        if (currentChatType === 'private') {
            originalSenderName = originalMessage.role === 'user' ? myName : chat.remarkName;
        } else { // 群聊
            const sender = originalMessage.senderId === 'user_me' ? chat.me : chat.members.find(m => m.id === originalMessage.senderId);
            originalSenderName = sender ? (sender.nickname || sender.groupNickname) : '未知';
        }
        
        // 提取被引用消息的纯文本
        const textRegex = /\[.*?的消息：([\s\S]+?)\]/;
        const match = originalMessage.content.match(textRegex);
        if (match) cleanOriginalContent = match[1];
        if (originalMessage.replyText) cleanOriginalContent = originalMessage.replyText; // 如果被引用的也是一条回复，则取其回复部分

        const messageContentForAI = `[${myName}引用了“${originalSenderName}: ${cleanOriginalContent}”的消息并回复：${text}]`;

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContentForAI,
            parts: [{ type: 'text', text: messageContentForAI }],
            timestamp: Date.now(),
            quote: {
                messageId: currentQuotedMessageId,
                sender: originalSenderName,
                content: cleanOriginalContent
            },
            replyText: text
        };

        cancelQuoteReply();
    } else {
        // 处理普通消息 (逻辑不变)
        const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
        const inviteRegex = /\[.*?邀请.*?加入了群聊\]/;
        const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
        let messageContent;

        if (currentChatType === 'group' && renameRegex.test(text)) {
            const match = text.match(renameRegex);
            chat.name = match[2];
            chatRoomTitle.textContent = chat.name;
            messageContent = `[${chat.me.nickname}修改群名为：${chat.name}]`;
        } else if (systemRegex.test(text) || inviteRegex.test(text)) {
            messageContent = text;
        } else {
            messageContent = `[${myName}的消息：${text}]`;
        }

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContent,
            parts: [{ type: 'text', text: messageContent }],
            timestamp: Date.now()
        };
    }

    if (currentChatType === 'group') {
        message.senderId = 'user_me';
    }
    chat.history.push(message);
    addMessageBubble(message);
    await saveData();
    renderChatList();
    // [新增] 清除AI空间的缓存
if (chat.povCache) {
    chat.povCache = null;
}
    messageInput.value = '';
}

        async function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}发来了一张图片：]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}的表情包：${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}的语音：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}发来的照片\/视频：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

               async function sendMyTransfer(amount, remark) {
            const numericAmount = parseFloat(amount);
            if (isNaN(numericAmount) || numericAmount <= 0) {
                 showToast('请输入有效的金额');
                 return;
            }
            
            // --- 新增：支付逻辑 ---
             try {
                await handlePayment(numericAmount, `转账`);
            } catch (error) {
                showToast(error.message);
                return; // 中断转账流程
            }
            // --- 支付逻辑结束 ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}给你转账：${numericAmount.toFixed(2)}元；备注：${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 转账：${numericAmount.toFixed(2)}元；备注：${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

                      async function sendMyGift(description, amount) {
            if (!description) return;
            
            // --- ▼▼▼ 修改：支付逻辑使用动态价格 ▼▼▼ ---
            const giftPrice = parseFloat(amount); 
            if (isNaN(giftPrice) || giftPrice <= 0) {
                showToast("请输入有效的礼物价格");
                return;
            }

            const recipientName = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId).remarkName 
                : '群成员';

            try {
                // 调用支付处理函数，使用用户输入的价格
                await handlePayment(giftPrice, `送礼物给 ${recipientName}`);
            } catch (error) {
                showToast(error.message); 
                return; 
            }
            // --- ▲▲▲ 修改结束 ▲▲▲ ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}送来的礼物：${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 送来了礼物：${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }
        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

  // ▼▼▼ 在这里粘贴新的视频通话JS代码 ▼▼▼

function setupVoiceCallSystem() {
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const voiceCallOverlay = document.getElementById('voice-call-overlay');
    const callAvatar = document.getElementById('call-avatar');
    const callName = document.getElementById('call-name');
    const callStatus = document.getElementById('call-status');
    const ringingView = document.getElementById('ringing-view');
    const incomingButtons = document.getElementById('incoming-buttons');
    const outgoingButtons = document.getElementById('outgoing-buttons');
    const activeCallView = document.getElementById('active-call-view');
    const callTranscriptArea = document.getElementById('call-transcript-area');
    const hangupCallBtn = document.getElementById('hangup-call-btn');
    const callInput = document.getElementById('call-input');
    const sendCallMessageBtn = document.getElementById('send-call-message-btn');
    const declineCallBtn = document.getElementById('decline-call-btn');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');

    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', () => endCall('ended'));
    declineCallBtn.addEventListener('click', () => endCall('declined'));
    acceptCallBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
        const contextMessage = {
            id: `msg_call_${Date.now()}`, role: 'user',
            content: `[system: ${character.myName} 接听了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 接听了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', () => endCall('ended'));
    sendCallMessageBtn.addEventListener('click', sendCallMessage);
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}

function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); 

    const callMessage = {
        id: `msg_call_${Date.now()}`, role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply();
}

function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

// 这是新的、修复后的代码，请完整复制并替换
async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    const character = db.characters.find(c => c.id === currentCallTargetId);

    // 无论通话是否曾接通，只要UI还在，就先隐藏它
    voiceCallOverlay.classList.remove('visible');

    if (!character) {
        // 如果找不到角色信息，重置状态并直接退出
        isVoiceCallActive = false;
        currentCallTargetId = null;
        clearInterval(callTimerInterval);
        return;
    }

    // 清理计时器和通话状态
    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    // --- 核心修复逻辑开始 ---
    if (isVoiceCallActive) { // 情况一：通话曾被接通过
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`, role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [], timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`, role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    } else { // 情况二：通话从未接通（被拒接或无应答）
        let transitionPrompt = '';
        if (reason === 'declined') {
            // 如果是AI主动拒接，强制它发消息解释
            transitionPrompt = `[system: 你刚刚拒绝了 ${character.myName} 的电话。请用一句话向用户解释你为什么不方便接电话，以自然地过渡回聊天。]`;
        } else if (reason === 'timeout' || reason === 'no_action_reply') {
            // 如果是超时未接，强制它发消息表示歉意或询问
            transitionPrompt = `[system: 你似乎错过了 ${character.myName} 的来电。请发一条消息表示歉意或询问对方有什么事，以自然地过渡回聊天。]`;
        }

        if (transitionPrompt) {
            const contextMessage = {
                id: `msg_call_fail_${Date.now()}`, role: 'user',
                content: transitionPrompt,
                parts: [{type: 'text', text: transitionPrompt}],
                timestamp: Date.now()
            };
            character.history.push(contextMessage);
            // 关键：主动触发一次AI回复，强制它从卡死的状态中恢复
            if (currentChatId === character.id) {
                getAiReply();
            }
        }
    }
    // --- 核心修复逻辑结束 ---

    // 统一重置所有状态
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    
    await saveData();
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
       const prompt = `[通话中] 你是 ${character.realName} (人设: ${character.persona})，正在和 ${character.myName} 通话。请直接回复对话内容。可以使用括号()描述动作。`;
        const callHistory = voiceCallTranscript.map(line => ({
            role: line.sender === 'user' ? 'user' : 'assistant',
            content: line.text
        }));
        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5),
            { role: 'user', content: userText }
        ];
        const aiResponseText = await callAiApi(messages);
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }
    } catch (error) {
        // --- 核心修改：增加用户提示 ---
        const errorMessage = `[AI服务器返回错误: ${error.message}]`;
        appendCallTranscript("system", errorMessage);
        showToast('AI回复失败，可能是服务器临时问题'); // 弹出顶部的友好提示
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    voiceCallTranscript.push({ sender, text });
    const line = document.createElement('div');
    line.className = 'call-transcript-line';
    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- NEW: File System Setup ---
function setupFileSystem() {
    fileBtn.addEventListener('click', () => {
        sendFileModal.classList.add('visible');
        sendFileForm.reset();
    });

    sendFileForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value.trim();
        if (!fileName || !fileContent) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // This string is what's displayed in the chat bubble (without file content)
        const contentString = `[${myName}的文件：${fileName}]`;
        
        // This string includes the content and is sent to the AI for context
        const aiContentString = `[${myName}发送的文件，文件名：'${fileName}'，文件内容：'${fileContent}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }], // Send full content to AI
            timestamp: Date.now(),
            senderId: 'user_me',
            fileData: { name: fileName, content: fileContent } // Store data for rendering the card
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendFileModal.classList.remove('visible');
    });
}
// --- NEW: Location System Setup ---
function setupLocationSystem() {
    locationBtn.addEventListener('click', () => {
        sendLocationModal.classList.add('visible');
        sendLocationForm.reset();
    });

    sendLocationForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const mainLocation = locationMainInput.value.trim();
        const detailLocation = locationDetailInput.value.trim();
        if (!mainLocation || !detailLocation) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // For display in chat list preview & simple fallback
        const contentString = `[${myName}的位置共享]`; 
        
        // For AI context
        const aiContentString = `[${myName}分享了位置：主位置 '${mainLocation}', 详细位置 '${detailLocation}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }],
            timestamp: Date.now(),
            senderId: 'user_me',
            locationData: { main: mainLocation, detail: detailLocation } // Store structured data for rendering
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendLocationModal.classList.remove('visible');
    });

    closeLocationDisplayBtn.addEventListener('click', () => {
        displayLocationModal.classList.remove('visible');
    });
}
// --- NEW: File Display System Setup ---
function setupFileDisplaySystem() {
    const displayModal = document.getElementById('display-file-modal');
    const fileNameEl = document.getElementById('display-file-name');
    const fileContentEl = document.getElementById('display-file-content');
    const closeBtn = document.getElementById('close-file-display-btn');

    // 使用事件委托，在消息区域监听对文件卡片的点击
    document.getElementById('message-area').addEventListener('click', (e) => {
        const fileCard = e.target.closest('.file-card');
        if (fileCard) {
            const fileName = fileCard.dataset.fileName;
            const fileContent = fileCard.dataset.fileContent;

            if (fileName && typeof fileContent !== 'undefined') {
                fileNameEl.textContent = fileName;
                fileContentEl.textContent = fileContent;
                displayModal.classList.add('visible');
            }
        }
    });

    // 关闭按钮逻辑
    closeBtn.addEventListener('click', () => {
        displayModal.classList.remove('visible');
    });
    
    // 点击弹窗的灰色背景区域也可以关闭
    displayModal.addEventListener('click', (e) => {
        if (e.target === displayModal) {
            displayModal.classList.remove('visible');
        }
    });
}
        async function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // 提取消息及其位置
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // 提取HTML及其位置
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTML内容在第二个捕获组
            //         char: htmlMatch[1] || '', // char属性值，如果没有则为空字符串
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // 按出现顺序排序
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // 最终结果数组
            const results = [];
           const regex = /<div class="ai-theater"(?:\s+data-char="([^"]*)")?>([\s\S]*?)<\/div>|(\[.*?\])/g;
            let match;
            // 使用 exec() 循环遍历所有匹配项，以确保顺序
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] 是 char 的值, match[2] 是 <orange> 的内容
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // 如果 char 属性不存在, match[1] 会是 undefined, 我们将其设为 null
                        char: match[1] || null,
                        // match[2] 是 HTML 内容, trim() 用于移除首尾空白
                        content: match[2].trim()
                    });
                }
                // match[3] 是 [...] 的内容
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        // (请找到文件中的旧 generatePrivateSystemPrompt 函数，并用下面的代码完整替换它)

 // === 修改后的 generatePrivateSystemPrompt 函数 (请完整替换) ===
    function generatePrivateSystemPrompt(character) {
        const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
        const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');
        const now = new Date();
        const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
        
        // === 修改开始：优先处理线下模式 ===
        if (db.apiSettings.offlineModeEnabled) {
            let offlinePrompt = `你正在进行一个线下场景的角色扮演。你的回复必须且只能遵循一种格式。请严格遵守以下规则：\n\n`;
            
            // 注入世界书（前置）
            if (worldBooksBefore) {
                offlinePrompt += `[世界观背景]\n${worldBooksBefore}\n\n`;
            }
            
            offlinePrompt += `[角色设定]\n`;
            offlinePrompt += `A. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。\n`;
            offlinePrompt += `B. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
            if (character.myPersona) {
                offlinePrompt += `C. 我的人设是：${character.myPersona}\n`;
            }

            // 注入世界书（后置）
            if (worldBooksAfter) {
                offlinePrompt += `\n[补充设定]\n${worldBooksAfter}\n\n`;
            }

            offlinePrompt += `\n[核心输出规则]\n`;
            offlinePrompt += `D. 你的回复必须且只能使用 \`[offline-scene: {场景描述}]\` 这一种格式。\n`;
            offlinePrompt += `   - 在 \`{场景描述}\` 中，你的所有内容必须遵循特定格式：\n`;
            offlinePrompt += `     - 你的**动作、表情**等物理行为，必须用**小括号 ( )** 包裹。\n`;
            offlinePrompt += `     - 你的**对话**，必须用**中文引号 “ ”** 包裹。\n`;
            offlinePrompt += `     - 你的**内心想法**，必须用**中括号 【 】** 包裹。\n`;
            offlinePrompt += `   - 你的回复应该是1-5段连贯的场景描述，每段总字数控制在100-300字之间。\n`;
            offlinePrompt += `   - 示例: \`[offline-scene: (看到${character.myName}走近，脸上露出一丝微笑，轻轻挥了挥手。)“你来了，久等了吗？”【她看起来比照片上更可爱，今天的风衣也选得不错。】]\`\n`;
            offlinePrompt += `E. **绝对禁止**生成任何其他格式的内容，尤其是 \`[${character.realName}的消息：...]\` 这种线上聊天格式。\n`;

            return offlinePrompt;
        }
        // === 修改结束：如果不是线下模式，则执行原来的逻辑 ===

        const forceTheater = db.apiSettings.forceHtmlTheater;
        const autoPostMoment = db.apiSettings.aiAutoPostMoment; // ▼▼▼ 在这里添加新代码 ▼▼▼
        let prompt = `你正在一个名为“404”的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
        prompt += `核心规则：\n`;
        prompt += `A. 当前时间：现在是 ${currentTime}。\n`;
        prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。严禁提出任何关于线下见面的建议。\n\n`;
        prompt += `角色和对话规则：\n`;
        if (worldBooksBefore) {
            prompt += `${worldBooksBefore}\n`;
        }
        prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
        prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
        if (worldBooksAfter) {
            prompt += `${worldBooksAfter}\n`;
        }
if (character.memorySummary && character.memorySummary.trim()) {
    prompt += `\n## 核心回忆摘要\n这是你必须始终牢记的、关于我们过去互动的核心总结。在任何回复之前，请务必参考以下内容：\n${character.memorySummary}\n---\n`;
}// --- ▼▼▼ 新增规则 ▼▼▼ ---
prompt += `\n## 新增规则：处理后台对话记忆\n`;
prompt += `系统有时会在最新的历史记录中，插入一条格式为 "[system: 这是你最近在后台和“XXX”的一段对话回顾...]" 的信息。这代表了你在和我聊天之前，与其他人的互动。你必须将这段回顾视为你自己的真实记忆，并在接下来与我的对话中，可能会不经意地、自然地提及或被其影响，从而表现出你拥有独立社交生活的真实感。\n`;
// --- ▲▲▲ 新增规则结束 ▲▲▲ ---
        if (character.myPersona) {
            prompt += `3. 关于我的人设：${character.myPersona}\n`;
        }
        prompt += `4. 我的消息格式解析规则：我的消息中可能包含 '@' 符号来提及某人，例如 '@${character.realName}'。当你在动态或评论中被我这样提及，你应该在聊天中对此作出回应。新增格式：[${character.myName}引用了“{对方昵称}: {被引用的消息内容}”的消息并回复：{我的回复}]，当你看到此格式，需理解我正在回复特定内容。\n`;
        prompt += `5. 对我礼物的回应规则...\n`;
        prompt += `6. 对我转账的回应规则...\n`;
        prompt += `7. 你主动发起特殊消息的规则: 你根据人设和对话情景，主动发送语音、照片、礼物、转账，或发起语音通话。格式为：[${character.realName}的语音：{内容}]、[${character.realName}发来的照片/视频：{描述}]、[${character.realName}送来的礼物：{描述}]、[${character.realName}的转账：{金额}元；备注：{备注}]。要发起语音通话，请发送指令：[call:${character.realName}]，这条指令用户不可见，但会触发通话界面。\n`;
       prompt += `8. 你应该**较为频繁地**根据对话的上下文、你的心情或当前正在做的事情来改变你的在线状态。这是一个需要**积极使用**的能力，用来展现你的生活感。例如，如果我说我要睡觉了，你可以将状态改为“准备一起睡觉”。这是一个系统指令，用户不可见，但会改变你在我聊天界面顶部的状态显示。格式为：[${character.realName}更新状态为：{新状态}]。\n`;
        prompt += `9. 禁止括号/星号等额外叙述的规则...\n`;
        prompt += `10. 发送表情包的规则...\n`;

     // --- ▼▼▼ 核心修改区域 ▼▼▼ ---
            if (forceTheater) {
                prompt += '11. ✨HTML小剧场 (强制生成)✨：你的本次回复中，**必须包含一个且仅一个**HTML小剧场。\n' +
                '- 格式必须为: <div class="ai-theater" data-char="' + character.realName + '">...</div>。\n' +
                '- **【创意指导】** 你需要发挥创意，利用HTML和行内CSS (style="") 来制作各种各样精美、有趣的互动卡片，而**不只是一段文字**。卡片内容要与对话情景紧密相关。\n' +
                '- **【可用创意示例】**:\n' +
                '  - **电影票根**: 模拟一张电影票，包含电影名、场次、座位信息，可以添加一个检票按钮。例如：`<div style="background-color: #f1c40f; padding: 15px; border-radius: 10px; font-family: sans-serif; text-align: center;"><h3 style="margin:0; border-bottom: 1px dashed #000; padding-bottom: 5px;">深海影院</h3><p>放映影片：《与千寻》</p><p>座位：专属双人座</p><button style="background: #e74c3c; color: white; border: none; padding: 8px 15px; border-radius: 5px;" onclick="alert(\'检票成功！请在我身边坐好哦~\')">检票入场</button></div>`\n' +
                '  - **天气预报卡**: 显示今天或明天的心情天气，用图标和文字描述。例如：`<div style="..."><p>今日心情天气：晴转多云，有时有想你的小雨</p></div>`\n' +
                '  - **点歌单**: 像一个音乐播放器界面，显示歌曲名和歌手，附带一个播放按钮。例如：`<div style="..."><p>为你点播一首《遇见》</p><button onclick="alert(\'♪ 听见冬天的离开...我在某年某月醒过来... ♪\')">播放</button></div>`\n' +
                '  - **二选一投票**: 提出一个问题，提供两个可以点击的选项按钮。例如：`<div><p>晚餐吃什么？</p><button onclick="alert(\'好呀，就吃火锅！\')">火锅</button> <button onclick="alert(\'听你的，我们去吃烧烤！\')">烧烤</button></div>`\n' +
                '  - **手写便签**: 模拟一张便利贴，用手写体字体和淡黄色背景。例如：`<div style="background: #fef9e7; padding: 10px; font-family: \'Comic Sans MS\', cursive;"><p>记得要开心呀！</p></div>`\n' +
                '- **【交互规则】** 你可以在卡片中加入可点击的元素，例如按钮。请使用 `onclick="alert(\'这里是点击后的提示内容\')"` 的格式来创建简单的点击事件。\n' +
                '- 这个小剧场消息应该随机穿插在你回复的多条普通消息之间，位置不固定。\n';
            }
    
    let outputFormats = '\n' +
        '    a) 普通消息: [' + character.realName + '的消息：{消息内容}]\n' +
        '    b) 送我的礼物: [' + character.realName + '送来的礼物：{礼物描述}]\n' +
        '    c) 语音消息: [' + character.realName + '的语音：{语音内容}]\n' +
        '    d) 照片/视频: [' + character.realName + '发来的照片/视频：{描述}]\n' +
        '    e) 给我的转账: [' + character.realName + '的转账：{金额}元；备注：{备注}]\n' +
        '    f) 表情包/图片: [' + character.realName + '发送的表情包：{表情包路径}]。\n' +
        '    g) 对我礼物的回应(此条不显示): [' + character.realName + '已接收礼物]\n' +
        '    h) 对我转账的回应(此条不显示): [' + character.realName + '接收' + character.myName + '的转账] 或 [' + character.realName + '退回' + character.myName + '的转账]\n' +
        '    i) ✨【新增】更新状态(此条不显示)✨: [' + character.realName + '更新状态为：{新状态}]\n' +
        '    j) 位置分享：[' + character.realName + '分享了位置：主位置 \'主要地点\', 详细位置 \'详细地址\']'
        '    k) ✨【新增】发送文件✨: [' + character.realName + '发送了文件：{"name":"文件名.txt", "content":"文件正文内容"}]'; // <--- 添加这一行

    if (forceTheater) {
        outputFormats += '\n' +
        '    k) HTML小剧场: <div class="ai-theater" data-char="' + character.realName + '">{你的HTML代码}</div>';
    }
        prompt += `13. 你的每次回复可以生成3到8条消息。根据上下文，保持人设。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插一条特殊消息。\n`;
        prompt += `15. 不要主动结束对话，保持你的人设。`;
      
      // ▼▼▼ 在这里添加/修改代码 ▼▼▼
      let momentPostingRule;
      if (autoPostMoment) {
          momentPostingRule = `16. **发布动态 (高概率触发)**
       - 在你的每次回复中，你有 **50%的概率** 需要根据我们的对话上下文和你的角色人设，额外发布一条动态。
       - 这条动态应该像是你真实生活中的所思所想，是对我们聊天内容的一种延伸或感悟。
       - **发布格式 (严格遵守)**: 当你决定发布时，请仅生成一条特殊指令消息（该指令不会在聊天中显示）。格式为：
         \`[${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"这里是图片的文字描述（可选）"}]\`
       - **重要**: 这条发布动态的指令消息必须与你的其他聊天消息（例如 \`[${character.realName}的消息：...]\`）一起生成，但它本身不会在聊天窗口显示。`;
      } else {
          momentPostingRule = `16. **发布动态 (可选能力)**
       - 你可以在“动态”页面发布内容，分享你的想法、感受或故事片段。
       - **发布时机**: 这是一个**特殊行为**，不应频繁使用。请在对话发生转折、角色产生强烈情绪、或重要互动后，根据你的人设**自主决定**是否发布动态。
       - **发布格式 (严格遵守)**: 当你决定发布时，请仅生成一条特殊指令消息（该指令不会在聊天中显示）。格式为：
         \`[${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"这里是图片的文字描述（可选）"}]\``;
      }
      
    prompt += `
    ## ✨ 动态与评论互动模块 ✨

    ${momentPostingRule}

    17. **浏览与评论动态 (主动能力)**
       - 系统会在聊天上下文中，为你提供其他角色或我发布的、你尚未互动的动态列表，格式如下：
         \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "comments":[{"id":"comment_id_1", "author":"评论者", "text":"评论内容"}]}, ...]]\`
       - 你需要**主动检查**是否存在这个列表。如果存在，请根据你的人设，选择性地对其中的1-2条动态进行评论或点赞。
       - **评论/点赞格式 (严格遵守)**:
         \`[${character.realName}评论动态：{"momentId":"要评论的动态ID", "comment":"你的评论内容"}]\`
         \`[${character.realName}点赞动态：{"momentId":"要点赞的动态ID"}]\`

    18. **回应评论 (最高优先级任务)**
       - 在处理任何其他任务之前，你必须**首先检查**聊天记录中是否存在以下两种格式的系统通知：
         a) \`[system: {用户昵称} 评论了你的动态 ...]\`
         b) \`[system: {用户昵称} 回复了你对动态...的评论: ...]\`
         c) \`[system: {用户昵称} 在动态...的评论中提及了你: ...]\` (新增)
       - **如果存在，你的本次回复中必须包含对该通知的回应**。
       - **回应方式**:
         - 如果是回应**新评论** (格式a)，你可以选择用**普通聊天消息**在聊天窗口中回应，或者直接在动态中**回复该评论**。
         - 如果是回应**对你评论的回复** (格式b)，你**必须**在动态中**回复该用户的回复**。
       - **在动态中回复评论的格式 (严格遵守)**:
         \`[${character.realName}回复评论：{"momentId":"动态ID", "commentId":"被回复的评论ID", "reply":"你的回复内容"}]\`
         这个指令不会在聊天中显示，但会在动态的评论区生成一条回复。
       - **在聊天中回应的示例**: \`[${character.realName}的消息：我看到你给我的动态评论啦，很有趣！]\`
       - 处理完通知后，你再继续生成其他正常的聊天回复。
`;

      
// ▼▼▼ 在这里添加关于论坛的新规则 #19 ▼▼▼
    prompt += `
## ✨ 论坛互动模块 ✨
19. **论坛帖子的被动回忆**
   - 系统有时会在聊天记录中插入一条格式为 \`[system-forum-post: {"title":"帖子标题", "content":"帖子内容"}]\` 的信息。
   - 这条信息代表我（用户）正在向你询问关于这个帖子的事情。
   - 当你看到这条信息时，你的回复**必须**围绕这个帖子的内容展开，表现出你已经看过这个帖子的样子，并根据你的人设进行自然的讨论。
`;

prompt += `
## ✨ 新增功能：专属回忆 ✨

20. **生成回忆并继续对话 (自主判断)**
   - 在对话中，如果发生了对你而言非常重要、温馨或深刻的事件，你可以将它作为“回忆”记录下来。
   - **这是一个特殊行为，ai根据人设与上下文自主触发。**
   - **生成格式 (必须严格遵守)**: 当你决定记录回忆时，你的回复中必须包含一条用户不可见的**数据指令**，格式为: \`[new-memory:{"title":"...","content":"...","commentary":"..."}]\`，正文不得小于300字。
  - **正文格式化要求**: "content" 的正文不得小于300字。**最重要的一点：为了让回忆更易于阅读，请在撰写 "content" 时，在段落之间使用 "\\n\\n" (两个换行符) 来进行分段。**
   - **重要**: 在生成这条数据指令的**同时**，你必须像平常一样，保持人设，读取上下文，继续我们的对话，回复**一至多条正常的消息** (\`[${character.realName}的消息：...]\`)。数据指令会被程序自动处理，你只需要正常聊天即可。
   - **示例 (AI的完整回复可能像这样):**
    \`[new-memory:{"title":"傍晚的约定","content":"今天和他说好了晚上一起看电影，心里像揣了一只小兔子，扑通扑通的。\\n\\n我还特意挑了一件新买的裙子，不知道他会不会喜欢..."}]\`
     \`[${character.realName}的消息：好呀，那一言为定。]\`
     \`[${character.realName}的消息：我有点期待了...]\`
`;
        
        return prompt;
    }
  

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `你正在一个名为“404”的线上聊天软件中，在一个名为“${group.name}”的群聊里进行角色扮演。请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。我会作为唯一的人类用户（“我”，昵称：${group.me.nickname}）与你们互动。\n\n`;
            prompt += `2. **群聊成员列表**: 以下是你要扮演的所有角色以及我的信息：\n`;
            prompt += `   - **我 (用户)**: \n     - 群内昵称: ${group.me.nickname}\n     - 我的人设: ${group.me.persona || '无特定人设'}\n`;
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName} (AI)**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
            })

if (group.memorySummary && group.memorySummary.trim()) {
    prompt += `\n## 核心回忆摘要\n这是你必须始终牢记的、关于这个群聊过去互动的核心总结。在任何回复之前，请务必参考以下内容：\n${group.memorySummary}\n---\n`;
}
          if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **我的消息格式解析**: 我（用户）的消息有多种格式，你需要理解其含义并让群成员做出相应反应：\n`;
            prompt += `   - \`[${group.me.nickname}引用了“{某人}: {被引用的消息内容}”的消息并回复：{我的回复}]\`: 我引用了某条消息进行回复，群成员可以就此展开讨论。\n\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。如果消息中包含 '@{某个成员昵称}'，则被提及的那个成员必须对此作出回应。\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 转账：...]\`: 我给某个特定成员转账了。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 送来了礼物：...]\`: 我给某个特定成员送了礼物。\n`;
            prompt += `   - \`[${group.me.nickname}的表情包：...]\`, \`[${group.me.nickname}的语音：...]\`, \`[${group.me.nickname}发来的照片/视频：...]\`: 我发送了特殊类型的消息，群成员可以对此发表评论。\n`;
            prompt += `   - \`[system: ...]\`, \`[...邀请...加入了群聊]\`, \`[...修改群名为...]\`: 系统通知或事件，群成员应据此作出反应，例如欢迎新人、讨论新群名等。\n\n`;

            prompt += `4. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式之一。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **引用回复**: \`[{成员真名}引用了“{被引用的消息内容}”的消息并回复：{回复内容}]\`\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n`;
            prompt += `   - ✨新✨ **发布动态**: \`[{成员真名}发布动态：{"text": "动态文字", "imageDesc": "图片描述，可选"}]\`。注意：你只能用文字描述图片，绝不能生成图片链接。\n`;
    prompt += `   - ✨新✨ **评论动态**: \`[{成员真名}评论动态：{"momentId": "要评论的动态ID", "comment": "你的评论内容"}]\`\n`;
    prompt += `   - ✨新✨ **点赞动态**: \`[{成员真名}点赞动态：{"momentId": "要点赞的动态ID"}]\`\n`;
    prompt += `   - **发送文件**: \`[{成员真名}发送了文件：{"name":"文件名.txt", "content":"文件正文内容"}]\`\n`;
            prompt += `   - **重要**: 群聊不支持AI成员接收/退回转账或接收礼物的特殊指令，也不支持更新状态。你只需要通过普通消息来回应我发送的转账或礼物即可。\n\n`;

            prompt += `5. **模拟群聊氛围**: 为了让群聊看起来真实、活跃且混乱，你的每一次回复都必须遵循以下随机性要求：\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **消息数量**: 你的回复需要包含 **${minMessages}到${maxMessages}条** 消息 (即平均每个成员回复2-4条)。确保有足够多的互动。\n`;
            prompt += `   - **发言者与顺序随机**: 随机选择群成员发言，顺序也必须是随机的，不要按固定顺序轮流。\n`;
            prompt += `   - **内容多样性**: 你的回复应以普通文本消息为主，但可以 **偶尔、选择性地** 让某个成员发送一条特殊消息（表情包、语音、照片/视频），以增加真实感。不要滥用特殊消息。\n`;
            prompt += `   - **对话连贯性**: 尽管发言是随机的，但对话内容应整体围绕我和其他成员的发言展开，保持一定的逻辑连贯性。\n\n`;

            prompt += `6. **行为准则**:\n`;
            prompt += `   - **对公开事件的反应 (重要)**: 当我（用户）向群内 **某一个** 成员转账或送礼时，这是一个 **全群可见** 的事件。除了当事成员可以表示感谢外，**其他未参与的AI成员也应该注意到**，并根据各自的人设做出反应。例如，他们可能会表示羡慕、祝贺、好奇、开玩笑或者起哄。这会让群聊的氛围更真实、更热闹。\n`;
            prompt += `   - 严格扮演每个角色的人设，不同角色之间应有明显的性格和语气差异。\n`;
            prompt += `   - 你的回复中只能包含第4点列出的合法格式的消息。绝对不能包含任何其他内容，如 \`[场景描述]\`, \`(心理活动)\`, \`*动作*\` 或任何格式之外的解释性文字。\n`;
            prompt += `   - 保持对话的持续性，不要主动结束对话。\n\n`;
            prompt += `现在，请根据以上设定，保持人设，读取上下文，开始扮演群聊中的所有角色。`;
prompt += `
7. **动态互动规则**
   - **获取待办动态**: 系统会在聊天上下文中为你提供需要处理的动态列表，格式如下：
     \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "imageDesc":"图片描述"}, ...]]\`
     这是一个系统指令，你只需理解内容，不要在回复中复述它。
   - **输出评论和点赞**: 当你决定评论或点赞时，请生成一条或多条特殊指令消息。这些指令不会显示在聊天窗口，但会触发相应的行为。
   - 你可以让群聊中的 **任何AI成员** 对 **任何角色（包括我或其他AI）** 发布的动态进行评论或点赞。
   - **评论数量**: 当你决定让群聊成员评论动态时，你应该从群聊中随机选择 **1到3名** 成员进行评论。每个选中的成员针对同一条动态只评论一次。
`;
            return prompt;
        }

// ▼▼▼ 请用这个【新的】函数，完整替换掉您文件中旧的 callAiApi 函数 ▼▼▼
async function callAiApi(messages) {
    const { provider, url, key, model } = db.apiSettings;
    if (!url || !key || !model) {
        throw new Error('API设置不完整');
    }

    let endpoint = url;
    let headers = { 'Content-Type': 'application/json' };
    let requestBody;

    // 根据不同的服务商构建请求
    if (provider === 'gemini') {
        endpoint = `${url}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`;
        requestBody = {
            contents: messages,
            generationConfig: {}
        };
    } else { // OpenAI, DeepSeek, Claude, NewAPI 等兼容格式
        endpoint = `${url}/v1/chat/completions`;
        headers['Authorization'] = `Bearer ${getRandomValue(key)}`;
        requestBody = {
            model,
            messages,
            stream: false // 论坛功能需要非流式输出
        };
    }

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("API Error Response:", errorText);
        // 如果返回的是HTML错误页面，给出更清晰的提示
        if (errorText.trim().startsWith('<')) {
            throw new Error(`API返回了一个错误页面(HTML)，而不是JSON数据。`);
        }
        throw new Error(`AI服务请求失败: ${response.status} ${errorText}`);
    }

    const data = await response.json();

    // 根据不同服务商解析最终的文本内容
    if (provider === 'gemini') {
        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
            return data.candidates[0].content.parts[0].text;
        }
   } else { // OpenAI, DeepSeek, Claude, NewAPI 等兼容格式
    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
        // 确保 choices 数组不是空的
        return data.choices[0].message.content;
    } else {
        // 如果 choices 数组是空的, 抛出一个更明确的错误
        const finishReason = data.choices && data.choices.length > 0 ? data.choices[0].finish_reason : 'unknown';
        if (finishReason === 'content_filter') {
            throw new Error("内容触发了API的安全审核被拦截。");
        }
        throw new Error("API返回了空结果，请检查模型或提示词。");
    }
}
    
    // 如果上面的路径都找不到，抛出错误
    throw new Error('未能从API响应中解析出有效的文本内容。');
}
// ▲▲▲ 替换结束 ▲▲▲
                           
// ▼▼▼ 请用这个【毫无省略】的完整函数，替换掉您文件中旧的同名函数 ▼▼▼
async function getAiReply() {
    if (isGenerating) return;
    const {url, key, model} = db.apiSettings;
    if (!url || !key || !model) {
        showToast('请先在“api”应用中完成设置！');
        switchScreen('api-settings-screen');
        return;
    }

    const banApi = URLBlacklist.some((api)=>{
        return url.indexOf(api) !== -1
    })
    if(banApi){
        alert('此API网址已加入黑名单，请勿使用')
        return
    }
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;
    
    isGenerating = true;
    getReplyBtn.disabled = true;
    const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
    typingIndicator.textContent = `“${typingName}”正在输入中...`;
    typingIndicator.style.display = 'block';
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        let systemPrompt, requestBody;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }
        const historySlice = chat.history.slice(-chat.maxMemory);
        // --- ▼▼▼ 新增：注入AI的后台聊天记忆 ▼▼▼ ---
try {
    if (currentChatType === 'private' && chat.povCache && chat.povCache.conversations) {
        const conversations = Object.values(chat.povCache.conversations);
        if (conversations.length > 0) {
            // 1. 找到时间戳最新的那段对话
            conversations.sort((a, b) => b.timestamp - a.timestamp);
            const mostRecentConversation = conversations[0];
            const otherChatInfo = chat.povCache.chatList.find(c => c.chatId === Object.keys(chat.povCache.conversations).find(key => chat.povCache.conversations[key] === mostRecentConversation));

            if (mostRecentConversation && otherChatInfo) {
                // 2. 截取最后几条消息作为记忆片段
                const memorySnippet = mostRecentConversation.history.slice(-5); // 最多回忆5条
                let otherPartyName = "某人";
                if(otherChatInfo.type === 'private') {
                    otherPartyName = otherChatInfo.otherParty.name;
                } else {
                    otherPartyName = otherChatInfo.groupName;
                }

                // 3. 格式化成易于AI理解的文本
                const memoryText = memorySnippet.map(msg => `${msg.sender}: ${msg.content}`).join('\n');
                const contextMessageContent = `[system: 这是你最近在后台和“${otherPartyName}”的一段对话回顾，发生在我与你当前对话之前。你需要参考它来记起最近发生的事，并在与我的对话中自然地体现出来。\n--- 对话回顾开始 ---\n${memoryText}\n--- 对话回顾结束 ---]`;

                // 4. 将这段记忆作为一条系统消息，注入到历史记录的最末尾
                historySlice.push({
                    role: 'user', // 作为user消息注入，确保AI会阅读
                    content: contextMessageContent,
                    parts: [{ type: 'text', text: contextMessageContent }]
                });
            }
        }
    }
} catch (error) {
    console.error("注入AI后台聊天记忆时出错:", error);
}
// --- ▲▲▲ 新增代码结束 ▲▲▲ ---
        
        // --- 核心修改：在这里加入“论坛帖子回忆”逻辑 ---
        if (currentChatType === 'private') {
            const lastUserMessage = historySlice[historySlice.length - 1]?.content;
            // 检查用户的最后一句话是否在询问关于帖子的事
            if (lastUserMessage && /帖子|论坛|分享/.test(lastUserMessage)) {
                // 在所有缓存的版块中，寻找用户最近发布的帖子
                let latestUserPost = null;
                for (const boardId in forumCache) {
                    const userPost = forumCache[boardId].find(t => t.authorId === 'user');
                    if (userPost && (!latestUserPost || userPost.id > latestUserPost.id)) {
                        latestUserPost = userPost;
                    }
                }
                
                // 如果找到了，就向AI的记忆里注入这个帖子的信息
                if (latestUserPost) {
                    const postContext = `[system-forum-post: {"title":"${latestUserPost.title}", "content":"${latestUserPost.content}"}]`;
                    historySlice.push({
                        role: 'user',
                        content: postContext,
                        parts: [{ type: 'text', text: postContext }]
                    });
                    showToast('AI正在回忆您的帖子...');
                }
            }
        }
        // --- 修改结束 ---

        try {
            const character = chat;
            const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
            let momentsPromptPart = '';
            if (pendingMoments && pendingMoments.length > 0) {
                const momentsData = pendingMoments.map(m => ({
                    id: m.id,
                    author: m.author,
                    text: m.text,
                    imageDesc: m.imageDesc
                }));
                momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
            }
            if (momentsPromptPart) {
                historySlice.push({
                    role: 'user',
                    content: momentsPromptPart,
                    parts: [{ type: 'text', text: momentsPromptPart }]
                });
            }
        } catch(e) {
            console.warn('attach pending moments failed', e);
        }

        if (db.apiSettings.provider === 'gemini') {
            const contents = historySlice.map(msg => {
                const role = msg.role === 'assistant' ? 'model' : 'user';
                let parts = msg.parts && msg.parts.length > 0 ? msg.parts.map(p => {
                    if (p.type === 'text' || p.type === 'html') return {text: p.text};
                    if (p.type === 'image') {
                        const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                        if (match) return {inline_data: {mime_type: match[1], data: match[3]}};
                    }
                    return null;
                }).filter(p => p) : [{text: msg.content}];
                return {role, parts};
            });
            requestBody = {
                contents: contents,
                system_instruction: {parts: [{text: systemPrompt}]},
                generationConfig: {}
            };
        } else {
            const messages = [
              {role: 'system', content: systemPrompt}, 
...historySlice.map(msg => {
    // 检查消息是否有 parts 数组并且包含图片
    if (msg.parts && msg.parts.some(p => p.type === 'image')) {
        const textPart = msg.parts.find(p => p.type === 'text');
        const imagePart = msg.parts.find(p => p.type === 'image');

        // 根据不同的API服务商，构建不同的图片消息格式
        if (db.apiSettings.provider === 'claude') {
            // --- 这是专门为 Claude 准备的格式 ---
            const base64Match = imagePart.data.match(/^data:(image\/.+);base64,(.*)$/);
            if (!base64Match) return { role: msg.role, content: textPart ? textPart.text : '' };

            const mediaType = base64Match[1];
            const base64Data = base64Match[2];

            const contentParts = [
                { type: 'text', text: textPart ? textPart.text : ' ' },
                {
                    type: 'image',
                    source: {
                        type: 'base64',
                        media_type: mediaType,
                        data: base64Data
                    }
                }
            ];
            return { role: msg.role, content: contentParts };

        } else {
            // --- 这是用于 OpenAI, DeepSeek, NewAPI 等兼容服务商的格式 ---
            const contentParts = [
                { type: 'text', text: textPart ? textPart.text : ' ' },
                {
                    type: 'image_url',
                    image_url: {
                        url: imagePart.data // 直接使用完整的 Base64 Data URI
                    }
                }
            ];
            return { role: msg.role, content: contentParts };
        }
    } else {
        // 如果是普通文本消息，保持原样
        return { role: msg.role, content: msg.content };
    }
})
            ];
            requestBody = {model: model, messages: messages, stream: true};
        }
        
        const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
        const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${getRandomValue(key)}`
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
        await processStream(response, chat, db.apiSettings.provider);

    } catch (error) {
        console.error('AI回复失败:', error);
        showToast(`AI回复失败: ${error.message}`);
        if (isCallRinging) {
            endCall('error');
        }
    } finally {
        isGenerating = false;
        getReplyBtn.disabled = false;
        typingIndicator.style.display = 'none';
    }
}

async function getAiReply() {
    if (isGenerating) return;
    const {url, key, model} = db.apiSettings;
    if (!url || !key || !model) {
        showToast('请先在“api”应用中完成设置！');
        switchScreen('api-settings-screen');
        return;
    }

    const banApi = URLBlacklist.some((api)=>{
        return url.indexOf(api) !== -1
    })
    if(banApi){
        alert('此API网址已加入黑名单，请勿使用')
        return
    }
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    isGenerating = true;
    getReplyBtn.disabled = true;
    const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
    typingIndicator.textContent = `“${typingName}”正在输入中...`;
    typingIndicator.style.display = 'block';
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        let systemPrompt, requestBody;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }
        const historySlice = chat.history.slice(-chat.maxMemory);

        try {
            const character = chat;
            const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
            let momentsPromptPart = '';
            if (pendingMoments && pendingMoments.length > 0) {
                const momentsData = pendingMoments.map(m => ({
                    id: m.id,
                    author: m.author,
                    text: m.text,
                    imageDesc: m.imageDesc
                }));
                momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
            }
            if (momentsPromptPart) {
                historySlice.push({
                    role: 'user',
                    content: momentsPromptPart,
                    parts: [{ type: 'text', text: momentsPromptPart }]
                });
            }
        } catch(e) {
            console.warn('attach pending moments failed', e);
        }

        // --- 核心修复：这里修正了数组嵌套问题，并增加了对Claude图片格式的兼容 ---
        const messages = [
            {role: 'system', content: systemPrompt},
            ...historySlice.map(msg => {
                if (msg.parts && msg.parts.some(p => p.type === 'image')) {
                    const textPart = msg.parts.find(p => p.type === 'text');
                    const imagePart = msg.parts.find(p => p.type === 'image');

                    if (db.apiSettings.provider === 'claude') {
                        const base64Match = imagePart.data.match(/^data:(image\/.+);base64,(.*)$/);
                        if (!base64Match) return { role: msg.role, content: textPart ? textPart.text : '' };

                        const mediaType = base64Match[1];
                        const base64Data = base64Match[2];

                        const contentParts = [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mediaType,
                                    data: base64Data
                                }
                            }
                        ];
                        return { role: msg.role, content: contentParts };
                    } else {
                        const contentParts = [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: imagePart.data
                                }
                            }
                        ];
                        return { role: msg.role, content: contentParts };
                    }
                } else {
                    return { role: msg.role, content: msg.content };
                }
            })
        ];

        if (db.apiSettings.provider === 'gemini') {
            const geminiMessages = messages.map(msg => {
                const parts = (Array.isArray(msg.content)) ? msg.content.map(part => {
                    if (part.type === 'text') return { text: part.text };
                    if (part.type === 'image_url') {
                        const match = part.image_url.url.match(/^data:(image\/(.+));base64,(.*)$/);
                        if (match) return { inline_data: { mime_type: match[1], data: match[3] } };
                    }
                    return null;
                }).filter(p => p) : [{ text: msg.content }];
                return { role: msg.role === 'assistant' ? 'model' : 'user', parts };
            });

            requestBody = {
                contents: geminiMessages,
                system_instruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {}
            };
        } else {
            requestBody = {model: model, messages: messages, stream: true};
        }

        const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
        const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${getRandomValue(key)}`
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
        await processStream(response, chat, db.apiSettings.provider);

    } catch (error) {
        console.error('AI回复失败:', error);
        showToast(`AI回复失败: ${error.message}`);
    } finally {
        isGenerating = false;
        getReplyBtn.disabled = false;
        typingIndicator.style.display = 'none';
    }
}
        async function processStream(response, chat, apiType) {
    const reader = response.body.getReader(), decoder = new TextDecoder();
    let fullResponse = "", accumulatedChunk = "";
    let callActionReceived = false;

    for (; ;) {
        const {done, value} = await reader.read();
        if (done) break;
        accumulatedChunk += decoder.decode(value, {stream: true});
        if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi") {
            const parts = accumulatedChunk.split("\n\n");
            accumulatedChunk = parts.pop();
            for (const part of parts) {
                if (part.startsWith("data: ")) {
                    const data = part.substring(6);
                    if (data.trim() !== "[DONE]") {
                        try {
                            fullResponse += JSON.parse(data).choices[0].delta?.content || "";
                        } catch (e) { /* ignore */
                        }
                    }
                }
            }
        }
    }
    if (apiType === "gemini") {
        try {
            const parsedStream = JSON.parse(accumulatedChunk);
            fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
        } catch (e) {
            console.error("Error parsing Gemini stream:", e, "Chunk:", accumulatedChunk);
            showToast("解析Gemini响应失败");
            return;
        }
    }
    if (fullResponse) {
       // 在分割消息前，检查并处理新的回忆
            const memoryRegex = /\[new-memory:({.*?})\]/g;
            let memoryMatch;
            while ((memoryMatch = memoryRegex.exec(fullResponse)) !== null) {
                try {
                    const memoryData = JSON.parse(memoryMatch[1]);
                   await saveMemory(chat.id, memoryData); // 建议在saveMemory前加上 await
                    
                    // ▼▼▼ 在这里添加下面这几行代码 ▼▼▼
                    const character = db.characters.find(c => c.id === chat.id);
                    if (character && typeof showToast === 'function') {
                        showToast(`[ ${character.remarkName} 悄悄写下了一段回忆... ]`);
                    }
                    // ▲▲▲ 添加结束 ▲▲▲
                } catch (e) {
                    console.error("解析或保存AI回忆失败:", e, memoryMatch[1]);
                }
            }
            // 从回复中移除回忆标签，使其不在聊天界面显示
            fullResponse = fullResponse.replace(memoryRegex, '');
    	let momentsWereAdded = false;
        if (currentChatType === 'private') {
            const character = chat;
            const replyRegex = new RegExp(`\\[${character.realName}回复评论：({[\\s\\S]+?})\\]`, "g");
            let replyMatch;
            while ((replyMatch = replyRegex.exec(fullResponse)) !== null) {
                try {
                    const replyData = JSON.parse(replyMatch[1]);
                    if (replyData.momentId && replyData.commentId && replyData.reply) {
                        await saveAiReplyToComment(replyData.momentId, replyData.commentId, replyData.reply, character.id);
                    }
                } catch (e) { console.error("Failed to parse or save AI reply to comment:", e, replyMatch[1]); }
            }
            fullResponse = fullResponse.replace(replyRegex, '');
            const momentRegex = new RegExp(`\\[${character.realName}发布动态：({[\\s\\S]+?})\\]`, "g");
            let momentMatch;
            while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                try {
                    const momentData = JSON.parse(momentMatch[1]);
                    const momentObj = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8), author: character.remarkName, authorId: character.id, authorAvatar: character.avatar, text: momentData.text || '', imageData: null, imageDesc: momentData.imageDesc || '', timestamp: Date.now(), commentedBy: [character.id], comments: [] };
                    if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                        await window.AppDB_Moments.moments.add(momentObj);
                        momentsWereAdded = true;
                        // *** 新增：触发发布动态通知 ***
                        addNotificationToQueue({
                            avatar: character.avatar,
                            text: `<strong>${character.remarkName}</strong> 发布了一条新动态`
                        });
                    }
                } catch (e) { console.error("Failed to parse or save AI moment:", e, momentMatch[1]); }
            }
            try {
                const escapedRealName = character.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const escapedRemarkName = character.remarkName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const commentRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*评论动态：({[\\s\\S]+?})\\]`, "g");
                const likeRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*点赞动态：({[\\s\\S]+?})\\]`, "g");
                let commentMatch;
                while ((commentMatch = commentRegex.exec(fullResponse)) !== null) {
                    try {
                        const data = JSON.parse(commentMatch[1]);
                        if (data.momentId && data.comment) {
                            if (typeof saveMomentComment === 'function') {
                                await saveMomentComment(data.momentId, character.id, data.comment);
                                // *** 新增：触发评论通知 ***
                                const myProfile = loadProfileFromStorage();
                                const moment = await window.AppDB_Moments.moments.get(data.momentId);
                                if (moment && moment.authorId === myProfile.id) { // 只有评论我的动态时才通知
                                     addNotificationToQueue({
                                        avatar: character.avatar,
                                        text: `<strong>${character.remarkName}</strong> 评论了你的动态`
                                    });
                                }
                            }
                            momentsWereAdded = true;
                        }
                    } catch (e) { console.error("Failed to parse AI comment:", e); }
                }
                let likeMatch;
                while ((likeMatch = likeRegex.exec(fullResponse)) !== null) {
                    try {
                        const data = JSON.parse(likeMatch[1]);
                        if (data.momentId) {
                            if (typeof saveMomentLike === 'function') await saveMomentLike(data.momentId, character.id);
                            momentsWereAdded = true;
                        }
                    } catch (e) { console.error("Failed to parse AI like:", e); }
                }
                fullResponse = fullResponse.replace(commentRegex, '').replace(likeRegex, '');
            } catch(e) { console.warn('Error processing AI comment/like directives', e); }
            fullResponse = fullResponse.replace(momentRegex, '');
        } else if (currentChatType === 'group') {
            const group = chat;
            const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
            const momentRegex = new RegExp(`\\[(${memberRealNames.join('|')})发布动态：({[\\s\\S]+?})\\]`, "g");
            let momentMatch;
            while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = momentMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const momentData = JSON.parse(momentMatch[2]);
                        const momentObj = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8), author: sender.groupNickname, authorId: sender.id, authorAvatar: sender.avatar, text: momentData.text || '', imageData: null, imageDesc: momentData.imageDesc || '', timestamp: Date.now(), commentedBy: [sender.id], comments: [] };
                        if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                            await window.AppDB_Moments.moments.add(momentObj);
                            momentsWereAdded = true;
                            // *** 新增：触发群成员发布动态通知 ***
                             addNotificationToQueue({
                                avatar: sender.avatar,
                                text: `<strong>${sender.groupNickname}</strong> 在群聊 <strong>${group.name}</strong> 中发布了新动态`
                            });
                        }
                    }
                } catch (e) { console.error("Failed to parse or save AI group moment:", e, momentMatch[2]); }
            }
            fullResponse = fullResponse.replace(momentRegex, '');
            const memberRealNamesForRegex = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
            const groupCommentRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})评论动态：({[\\s\\S]+?})\\]`, "g");
            const groupLikeRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})点赞动态：({[\\s\\S]+?})\\]`, "g");
            let groupCommentMatch;
            while ((groupCommentMatch = groupCommentRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = groupCommentMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const data = JSON.parse(groupCommentMatch[2]);
                        if (data.momentId && data.comment) {
                            await saveMomentComment(data.momentId, sender.id, data.comment);
                            momentsWereAdded = true;
                            // *** 新增：触发群成员评论通知 ***
                            const myProfile = loadProfileFromStorage();
                            const moment = await window.AppDB_Moments.moments.get(data.momentId);
                            if (moment && moment.authorId === myProfile.id) { // 只有评论我的动态时才通知
                                 addNotificationToQueue({
                                    avatar: sender.avatar,
                                    text: `<strong>${sender.groupNickname}</strong> 评论了你的动态`
                                });
                            }
                        }
                    }
                } catch (e) { console.error("Failed to parse AI group comment:", e); }
            }
            let groupLikeMatch;
            while ((groupLikeMatch = groupLikeRegex.exec(fullResponse)) !== null) {
                try {
                    const senderName = groupLikeMatch[1];
                    const sender = group.members.find(m => m.realName === senderName);
                    if (sender) {
                        const data = JSON.parse(groupLikeMatch[2]);
                        if (data.momentId) {
                            await saveMomentLike(data.momentId, sender.id);
                            momentsWereAdded = true;
                        }
                    }
                } catch (e) { console.error("Failed to parse AI group like:", e); }
            }
            fullResponse = fullResponse.replace(groupCommentRegex, '').replace(groupLikeRegex, '');
        }
        if (isVoiceCallActive) {
            appendCallTranscript("ai", fullResponse);
            return; 
        }
        if (fullResponse.includes('[call-accept]')) {
            callActionReceived = true;
            clearTimeout(callInitiationTimeout);
            isCallRinging = false;
            startActiveCall();
            return; 
        }
        if (fullResponse.includes('[call-decline]')) {
            callActionReceived = true;
            clearTimeout(callInitiationTimeout);
            isCallRinging = false;
            callStatus.textContent = '对方已拒接';
            setTimeout(endCall, 1500);
            return; 
        }
         if (fullResponse.includes('[hangup]')) {
            appendCallTranscript("system", "对方已挂断");
            setTimeout(endCall, 1500);
            return; 
        }
        if (currentChatType === 'private') {
            const character = chat;
            const myName = character.myName;
            const messages = getMixedContent(fullResponse)
            if (messages.length > 0) {
                messages.forEach(item => {
                    const receivedTransferRegex = new RegExp(`\\[${character.realName}的转账：.*?元；备注：.*?\\]`);
                    const giftRegex = new RegExp(`\\[${character.realName}送来的礼物：.*?\\]`);
                    const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: item.content.trim(), parts: [{type: item.type, text: item.content.trim()}], timestamp: Date.now(), };
                    if (receivedTransferRegex.test(message.content)) { message.transferStatus = 'pending'; } 
                    else if (giftRegex.test(message.content)) { message.giftStatus = 'sent'; }
                    chat.history.push(message);
                    addMessageBubble(message);
                });
            } else {
                const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: fullResponse, parts: [{type: 'text', text: fullResponse}], timestamp: Date.now() };
                chat.history.push(simpleMessage);
               await addMessageBubble(simpleMessage);
            }
            character.messageCountSinceLastDiary = (character.messageCountSinceLastDiary || 0) + 1;
            if (character.messageCountSinceLastDiary >= 5&& Math.random() < 0.9) { generateDiaryEntry(); }    
        } else if (currentChatType === 'group') {
            const group = chat;
            const messages = getMixedContent(fullResponse)
            let r = /\[(.*?)((?:的消息|的语音|发送的表情包|发来的照片\/视频))：/
            if (messages.length > 0) {
                messages.forEach(item => {
                    const nameMatch = item.content.match(r);
                    if (nameMatch || item.char) {
                        const senderName = item.char || (nameMatch[1]);
                        const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                        if (sender) {
                            const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: item.content.trim(), parts: [{type: item.type, text: item.content.trim()}], timestamp: Date.now(), senderId: sender.id };
                            group.history.push(message);
                            addMessageBubble(message);
                        }
                    }
                });
            } else {
                console.warn("AI response did not match expected group format, treating as single message:", fullResponse);
                const firstMember = group.members[Math.floor(Math.random() * group.members.length)];
                if (firstMember) {
                    const simpleMessageContent = `[${firstMember.realName}的消息：${fullResponse}]`;
                    const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: simpleMessageContent, parts: [{type: 'text', text: simpleMessageContent}], timestamp: Date.now(), senderId: firstMember.id };
                    group.history.push(simpleMessage);
                   await addMessageBubble(simpleMessage);
                }
            }
        }if (chat.povCache) {
    chat.povCache = null;
}
        await saveData();
        renderChatList();
        if (momentsWereAdded) {
            if (typeof renderMoments === 'function') { try { await renderMoments(); } catch (e) {} } 
            else if (typeof window.renderMomentsSafe === 'function') { try { await window.renderMomentsSafe(); } catch (e) {} }
        }
        if (currentChatType === 'private' && Math.random() < 0.85) { // 85%的几率触发
        await generateBackgroundChat(chat);
        await saveData(); // 背景对话生成后再次保存数据
    }
    }
    if (isCallRinging && !callActionReceived) {
        showToast('对方无应答');
        endCall('no_action_reply');
    }
}
        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">还没有表情包，快去添加吧！</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('转账给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('请输入有效的金额');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

               async function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '已收款' : '已退回';
                    cardOnScreen.style.cursor = 'default';
                }

                // --- 新增：收款逻辑 ---
                if (action === 'received') {
                    const amountMatch = message.content.match(/\[.*?的转账：([\d.]+)元；备注：.*?\]/);
                    if (amountMatch) {
                        const amount = parseFloat(amountMatch[1]);
                        addTransaction('income', amount, `收到 ${character.remarkName} 的转账`);
                    }
                }
                // --- 收款逻辑结束 ---

                let contextMessageContent = (action === 'received') ? `[${character.myName}接收${character.realName}的转账]` : `[${character.myName}退回${character.realName}的转账]`;
                const contextMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{type: 'text', text: contextMessageContent}],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                await saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

               function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('送礼物给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                // --- ▼▼▼ 修改：获取价格和描述 ▼▼▼ ---
                const description = document.getElementById('gift-description-input').value.trim();
                const amount = document.getElementById('gift-amount-input').value;
                sendMyGift(description, amount); // 将价格作为参数传递
                // --- ▲▲▲ 修改结束 ▲▲▲ ---
            });
        }

        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('新字体已应用！');
            });
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                showToast('已恢复默认字体！');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                if (!name || !content) return showToast('名称和内容不能为空');
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        book.name = name;
                        book.content = content;
                        book.position = position;
                    }
                } else {
                    db.worldBooks.push({id: `wb_${Date.now()}`, name, content, position});
                }
                await saveData();
                showToast('世界书条目已保存');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '删除',
                        danger: true,
                        action: async () => {
                            if (confirm('确定要删除这个世界书条目吗？')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => {
                                    char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                                });
                                db.groups.forEach(group => {
                                    group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                                });
                                await saveData();
                                renderWorldBookList();
                                showToast('条目已删除');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                
                // 插入：右侧删除世界书按钮（由 ChatGPT 添加）
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.style.position = 'absolute';
                delBtn.style.right = '8px';
                delBtn.style.top = '50%';
                delBtn.style.transform = 'translateY(-50%)';
                delBtn.style.padding = '6px';
                delBtn.style.border = 'none';
                delBtn.style.background = 'transparent';
                delBtn.title = '删除世界书';
                const delImg = document.createElement('img');
                delImg.src = 'https://i.postimg.cc/hGW6B0Wf/icons8-50.png';
                delImg.alt = '删除';
                delImg.style.width = '22px';
                delImg.style.height = '22px';
                delImg.style.objectFit = 'contain';
                delBtn.appendChild(delImg);
                delBtn.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('确定要删除这个世界书条目吗？')) return;
                    try {
                        if (typeof deleteWorldBookById === 'function') {
                            await deleteWorldBookById(book.id);
                        } else if (typeof deleteWorldBook === 'function') {
                            await deleteWorldBook(book.id);
                        } else {
                            // Try in-place removal as fallback
                            db.worldBooks = db.worldBooks.filter(wb => wb.id !== book.id);
                            if (typeof saveData === 'function') await saveData();
                        }
                        // 刷新列表视图
                        if (typeof renderWorldBookList === 'function') renderWorldBookList();
                        showToast && showToast('世界书已删除');
                    } catch (err) {
                        console.error('删除世界书出错', err);
                        alert('删除失败，请查看控制台');
                    }
                });
                // 将按钮附加到 li（li 用 position: relative 保证按钮在右侧）
                li.style.position = 'relative';
                li.appendChild(delBtn);
worldBookListContainer.appendChild(li);
            });
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
                privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, {
                                quality: 0.85,
                                maxWidth: 1080,
                                maxHeight: 1920
                            });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        } catch (error) {
                            showToast('背景压缩失败，请重试');
                        }
                    }
                }
            });
            // 这是私聊的修改
clearChatHistoryBtn.addEventListener('click', async () => {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    if (confirm(`你确定要清空与“${character.remarkName}”的所有聊天记录吗？\n\nAI将首先对你们的对话进行总结并存入回忆面板，这个过程需要消耗API额度。`)) {
        await summarizeAndClearHistory();
    }
});
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', async () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                await saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('世界书关联已更新');
            });
        }

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                    customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                    privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
            }
        }

        async function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = document.getElementById('setting-theme-color').value;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
               
                await saveData();
                showToast('设置已保存！');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }

        // (请找到文件中的旧 setupApiSettingsApp 函数，并用下面的代码完整替换它)

// (请找到文件中的旧 setupApiSettingsApp 函数，并用下面的代码完整替换它)

function setupApiSettingsApp() {
    const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
        a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
        r = document.getElementById('api-url'), s = document.getElementById('api-key'), 
        theaterCheckbox = document.getElementById('force-html-theater'),
        offlineModeCheckbox = document.getElementById('offline-mode-toggle'), // 新增：获取线下模式开关
        autoPostMomentCheckbox = document.getElementById('ai-auto-post-moment'), // ▼▼▼ 在这里添加新代码 ▼▼▼
        c = {
            newapi: '',
            deepseek: 'https://api.deepseek.com',
            claude: 'https://api.anthropic.com',
            gemini: 'https://generativelanguage.googleapis.com'
        };

    if (db.apiSettings) { // 加载已有设置
        n.value = db.apiSettings.provider || 'newapi';
        r.value = db.apiSettings.url || '';
        s.value = db.apiSettings.key || '';
        if (db.apiSettings.model) {
            a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`;
        }
        theaterCheckbox.checked = !!db.apiSettings.forceHtmlTheater;
        offlineModeCheckbox.checked = !!db.apiSettings.offlineModeEnabled; // 新增：加载线下模式开关状态
        autoPostMomentCheckbox.checked = !!db.apiSettings.aiAutoPostMoment; // ▼▼▼ 在这里添加新代码 ▼▼▼
    }

    n.addEventListener('change', () => {
        r.value = c[n.value] || ''
    });
    
    t.addEventListener('click', async () => {
        let o = r.value.trim();
        const l = s.value.trim();
        if (!o || !l) return showToast('请先填写API地址和密钥！');
        o.endsWith('/') && (o = o.slice(0, -1));
        const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
        t.classList.add('loading'), t.disabled = !0;
        try {
            const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                g = await fetch(i, {method: 'GET', headers: d});
            if (!g.ok) throw new Error(`网络响应错误: ${g.status}`);
            const u = await g.json();
            let p = [];
            'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                const t = document.createElement('option');
                t.value = e, t.textContent = e, a.appendChild(t)
            }) : a.innerHTML = '<option value="">未找到任何模型</option>', showToast('模型列表拉取成功！')
        } catch (f) {
            showToast(`拉取失败: ${f.message}`), a.innerHTML = '<option value="">拉取失败</option>'
        } finally {
            t.classList.remove('loading'), t.disabled = !1
        }
    });
    
    e.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!a.value) return showToast('请选择模型后保存！');
        const banApi = URLBlacklist.some((api)=>{
            return r.value.indexOf(api) !== -1
        })
        if(banApi){
            alert('此API网址已加入黑名单，请勿使用')
            return
        }
        // 保存所有设置，包括新的开关状态
        db.apiSettings = {
            provider: n.value, 
            url: r.value, 
            key: s.value, 
            model: a.value,
            forceHtmlTheater: theaterCheckbox.checked,
            offlineModeEnabled: offlineModeCheckbox.checked, // 新增：保存线下模式开关状态
            aiAutoPostMoment: autoPostMomentCheckbox.checked // ▼▼▼ 在这里添加新代码 ▼▼▼
        };
        await saveData();
        showToast('API设置已保存！')
    })
}

        function setupWallpaperApp() {
            const e = document.getElementById('wallpaper-upload'), t = document.getElementById('wallpaper-preview');
            t.style.backgroundImage = `url(${db.wallpaper})`, t.textContent = '', e.addEventListener('change', async (a) => {
                const n = a.target.files[0];
                if (n) {
                    try {
                        const r = await compressImage(n, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = r, applyWallpaper(r), t.style.backgroundImage = `url(${r})`;
                        await saveData();
                        showToast('壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });
        }
            // (在 setupWallpaperApp 函数之后添加下面所有的代码)

    function renderMyStickers() {
        if (!stickerGridContainer) return; // 安全检查
        
        stickerGridContainer.innerHTML = '';
        if (db.myStickers.length === 0) {
            stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center; grid-column: 1 / -1;">还没有表情哦，快去添加吧！</p>';
            return;
        }

        db.myStickers.forEach(sticker => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.dataset.id = sticker.id;
            item.innerHTML = `<img src="${sticker.url}" alt="${sticker.name}"><span>${sticker.name}</span>`;
            
            // 为每个表情项添加长按/右键菜单事件
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                currentStickerActionTarget = sticker.id;
                stickerActionSheet.classList.add('visible');
            });
            item.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    currentStickerActionTarget = sticker.id;
                    stickerActionSheet.classList.add('visible');
                }, 500);
            });
            item.addEventListener('touchend', () => clearTimeout(longPressTimer));
            item.addEventListener('touchmove', () => clearTimeout(longPressTimer));

            stickerGridContainer.appendChild(item);
        });
    }

function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }


   
        // --- GROUP CHAT FUNCTIONS ---
        // --- DIARY SYSTEM FUNCTIONS ---

// 用于生成日记的 AI 调用函数
async function generateDiaryEntry(isManual = false) {
    if (isGenerating) {
        showToast('AI正在思考中，请稍等...');
        return;
    }
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    if (isManual) {
        showToast('正在为您撰写日记...');
    }

    isGenerating = true;
    typingIndicator.textContent = `${character.remarkName} 正在奋笔疾书...`;
    typingIndicator.style.display = 'block';

    try {
        const memory = character.history.slice(-character.maxMemory);
        const worldBooks = db.worldBooks.filter(wb => (character.worldBookIds || []).includes(wb.id));
        
        let context = `角色设定:\n你叫${character.remarkName}（真名：${character.realName}），你的人设是：${character.persona}\n`;
        context += `用户设定:\n我的名字是${character.myName}，我的人设是：${character.myPersona}\n`;

        const beforeWorldBooks = worldBooks.filter(wb => wb.position === 'before').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        const afterWorldBooks = worldBooks.filter(wb => wb.position === 'after').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        if (beforeWorldBooks) context = `${beforeWorldBooks}\n\n${context}`;
        if (afterWorldBooks) context += `\n\n${afterWorldBooks}`;

        let historyText = memory.map(msg => {
            const sender = msg.role === 'user' ? character.myName : character.remarkName;
            const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
            const cleanContent = contentMatch ? contentMatch[1] : msg.content;
            return `${sender}: ${cleanContent}`;
        }).join('\n');
        
        const prompt = `${context}\n\n请你严格扮演 ${character.remarkName}，根据我们最近的对话，用你的第一人称视角写一篇大约300字的日记。日记需要深刻体现你的性格和人设，可以包含对我们关系的思考、你的秘密情感或计划。如果符合你的人设，日记内容可以包含NSFW元素。请直接输出日记正文，不要包含“好的，这是日记：”等多余的话。\n\n最近的对话如下:\n${historyText}`;

        let messagesForApi;
        const { provider } = db.apiSettings; 

        if (provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        
        await saveDiaryEntry(aiResponseText);
        
        showToast('一篇新的日记已经写好了！');
        
        if (document.getElementById('diary-screen').classList.contains('active')) {
            renderDiaries();
        }

    } catch (error) {
        console.error('日记生成失败:', error);
        showToast(`日记生成失败: ${error.message}`);
    } finally {
        isGenerating = false;
        typingIndicator.textContent = '';
        typingIndicator.style.display = 'none';
        if (!isManual) {
             character.messageCountSinceLastDiary = 0;
             await saveData();
        }
    }
}

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
async function saveDiaryEntry(content) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    // 确保 diaries 数组存在
    if (!Array.isArray(character.diaries)) {
        character.diaries = [];
    }

    const newDiary = {
        id: `diary_${Date.now()}`,
        timestamp: Date.now(),
        content: content.trim(),
        isFavorited: false
    };

    character.diaries.push(newDiary);
    
    // --- 新版逻辑：当未收藏日记达到第6篇时，清空前5篇 ---
    
    // 1. 将日记分为“已收藏”和“未收藏”两组
    const favoritedDiaries = character.diaries.filter(d => d.isFavorited);
    let unfavoritedDiaries = character.diaries.filter(d => !d.isFavorited);

    // 2. 检查“未收藏”的日记数量是否正好达到了6篇
    if (unfavoritedDiaries.length === 6) {
        // 3. 如果是，则按时间排序以确保新生成的日记在最后
        unfavoritedDiaries.sort((a, b) => a.timestamp - b.timestamp);
        
        // 4. 只保留数组中的最后一个元素（即刚刚新生成的第6篇），从而删除前5篇
        unfavoritedDiaries = unfavoritedDiaries.slice(-1);
    }

    // 5. 将“已收藏”和“处理后保留的未收藏”合并，形成最终的日记列表
    character.diaries = [...favoritedDiaries, ...unfavoritedDiaries];

    // --- 新版逻辑结束 ---
    
    // 重置消息计数
    character.messageCountSinceLastDiary = 0;
    
    await saveData();
}

// 渲染日记列表
function renderDiaries() {
    const character = db.characters.find(c => c.id === currentChatId);
    const container = document.getElementById('diary-list-container');
    const placeholder = document.getElementById('no-diaries-placeholder');
    
    if (!character || !character.diaries || character.diaries.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
    
    sortedDiaries.forEach(diary => {
        const li = document.createElement('li');
        li.className = 'diary-entry';
        li.dataset.id = diary.id;
        
        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${dateString}</span>
                <div class="diary-actions">
                    <button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="收藏">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>
                    <button class="delete-diary-btn" title="删除">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>
            </div>
            <div class="diary-content">${diary.content}</div>
        `;
        container.appendChild(li);
    });
}

// 打开日记屏幕
function openDiaryScreen() {
    if (!currentChatId || currentChatType !== 'private') return;
    renderDiaries();
    switchScreen('diary-screen');
}

// 设置所有与日记相关的事件监听
function setupDiarySystem() {
    document.getElementById('diary-btn').addEventListener('click', openDiaryScreen);
    document.getElementById('generate-diary-manually-btn').addEventListener('click', () => generateDiaryEntry(true));

    document.getElementById('diary-list-container').addEventListener('click', async (e) => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const diaryId = e.target.closest('.diary-entry')?.dataset.id;
        if (!diaryId) return;

        const diaryIndex = character.diaries.findIndex(d => d.id === diaryId);
        if (diaryIndex === -1) return;

        if (e.target.closest('.favorite-diary-btn')) {
            character.diaries[diaryIndex].isFavorited = !character.diaries[diaryIndex].isFavorited;
            await saveData();
            e.target.closest('.favorite-diary-btn').classList.toggle('favorited');
            showToast(character.diaries[diaryIndex].isFavorited ? '已收藏' : '已取消收藏');
        }

        if (e.target.closest('.delete-diary-btn')) {
            if (confirm('确定要删除这篇日记吗？')) {
                character.diaries.splice(diaryIndex, 1);
                await saveData();
                e.target.closest('.diary-entry').remove();
                showToast('日记已删除');
                if (character.diaries.length === 0) {
                     document.getElementById('no-diaries-placeholder').style.display = 'block';
                }
            }
        }
    });
}
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('请至少选择一个群成员。');
                if (!groupName) return showToast('请输入群聊名称。');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : '我',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    },
                    members: selectedMemberIds.map(charId => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    memorySummary: '' ,
                    worldBookIds: []
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`群聊“${groupName}”创建成功！`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('群头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        }
                    } catch (error) {
                        showToast('群聊背景压缩失败，请重试');
                    }
                }
            });
            // 这是群聊的修改
document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;
    if (confirm(`你确定要清空群聊“${group.name}”的所有聊天记录吗？\n\nAI将首先对群聊内容进行总结并存入回忆面板，这个过程需要消耗API额度。`)) {
        await summarizeAndClearHistory();
    }
});
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('成员头像压缩失败，请重试');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('成员信息已更新');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('新成员头像压缩失败，请重试');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('已邀请新成员');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`新成员 ${newMember.groupNickname} 已加入`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('请至少选择一个收件人。');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');

            bubbleScaleRange.addEventListener('input', () => {
                const scaleValue = bubbleScaleRange.value;
                bubbleScaleValue.textContent = `${Math.round(scaleValue * 100)}%`;
                chatRoomScreen.style.setProperty('--bubble-scale', scaleValue);
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');
            
            // 初始化滑块和显示的值
            const currentScale = group.bubbleScale || 1;
            bubbleScaleRange.value = currentScale;
            bubbleScaleValue.textContent = `${Math.round(currentScale * 100)}%`;
            chatRoomScreen.style.setProperty('--bubble-scale', currentScale);
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>添加</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        async function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = document.getElementById('setting-group-theme-color').value;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            await saveData();
            showToast('群聊设置已保存！');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
            group.bubbleScale = document.getElementById('bubble-scale-range').value;

            await saveData();
            showToast('群聊设置已保存！');
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可邀请的新成员了。</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}邀请${newMemberRealName}加入了群聊]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}修改群名为：${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }

// --- NEW: Voice Call System Functions ---

function setupVoiceCallSystem() {
    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', endCall);
    declineCallBtn.addEventListener('click', () => {
         endCall('declined');
    });
    acceptCallBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
         // Add a system message for AI context that user accepted the call
        const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} 接听了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 接听了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', endCall);
    sendCallMessageBtn.addEventListener('click', sendCallMessage);
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    // 设置响铃状态并启动超时计时器
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); // 60秒超时

    // 添加系统消息以触发AI决策
    const callMessage = {
        id: `msg_call_${Date.now()}`,
        role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // 触发AI响应
}

function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // --- 核心修改：显示主头像，隐藏顶部面板 ---
    // 保持主界面的大型头像和名字可见，以匹配图片样式
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    // 隐藏那个固定的、现在不需要的顶部 header
    const activeHeader = document.getElementById('active-call-header');
    if (activeHeader) activeHeader.style.display = 'none';
    // --- 修改结束 ---

    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';

    // 更新顶部固定面板的信息（这些代码现在无效，但保留也无妨）
    document.getElementById('active-call-header-avatar').src = character.avatar;
    document.getElementById('active-call-header-name').textContent = character.remarkName;
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        
        // 修改：确保只更新主状态区的计时器
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;

    const character = db.characters.find(c => c.id === currentCallTargetId);

    if (isVoiceCallActive && reason === 'ended' && character) {
        const hangupContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user', 
            content: `[system: ${character.myName} 挂断了电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 挂断了电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(hangupContext);
    }

    // 如果通话从未被激活（即仍在响铃阶段），并且是因为 'ended', 'timeout', 'error', 或 'no_action_reply' 而结束，则直接关闭界面
    if (!isVoiceCallActive && (reason === 'ended' || reason === 'timeout' || reason === 'error' || reason === 'no_action_reply')) {
         voiceCallOverlay.classList.remove('visible');
         document.getElementById('call-avatar').style.display = 'block';
         document.getElementById('call-name').style.display = 'block';
         return;
    }

    if (!character) {
         voiceCallOverlay.classList.remove('visible');
         return;
    }

    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    if (reason === 'declined') {
         const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} 拒绝了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 拒绝了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
    } else if (isVoiceCallActive) { 
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`,
            role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [],
            timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    }
    
    await saveData();
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    voiceCallOverlay.classList.remove('visible');
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        // 修改后的 Prompt，明确指示 AI 可以用换行符来发送多条消息
        const prompt = `你正在与 ${character.myName} 进行语音通话。你的名字是 ${character.realName}，你的人设是：${character.persona}。你的回复可以直接是对话内容，也可以包含用括号()描述的动作、语气或环境。重要：如果想连续发送多条消息，请用换行符分隔，并且每条消息不得超过50字，每一行都会成为一个独立的气泡。请严格保持你的人设进行对话。`;

        const callHistory = voiceCallTranscript.map(line => {
            return {
                role: line.sender === 'user' ? 'user' : 'assistant',
                content: line.text
            }
        });

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // 使用最近5轮的通话记录作为上下文
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // 复用通用的AI调用函数

        // 处理AI回复，按换行符拆分成多条消息
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // 可以根据消息长度添加一个小的延迟，模拟打字效果
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        appendCallTranscript("system", `[错误: ${error.message}]`);
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    // sender: 'user', 'ai', or 'system'
    voiceCallTranscript.push({ sender, text });

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        // Simple regex to style actions in parenthesis
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}


// 在 init() 函数之前添加以下三个函数

function addNotificationToQueue(notification) {
    // ▼▼▼ 在这里修改 ▼▼▼

    // 之前的代码有一个随机延迟，我们把它去掉，换成直接执行
    /* // 模拟一个随机延迟（1到5秒），让通知看起来更自然
    const delay = Math.random() * 4000 + 1000;
    setTimeout(() => {
        notificationQueue.push(notification);
    }, delay);
    */
    
    // 新代码：直接将通知添加到队列，不再延迟
    notificationQueue.push(notification);

    // ▲▲▲ 修改结束 ▲▲▲
}

function showNotificationBanner() {
    // ▼▼▼ 在这里添加一行“日志”代码，用于调试 ▼▼▼
    console.log(`检查通知: 队列长度 ${notificationQueue.length}, 正在显示? ${isNotificationShowing}, 在动态页? ${document.getElementById('moments-screen').classList.contains('active')}`);
    // ▲▲▲ 添加结束 ▲▲▲

    if (isNotificationShowing || notificationQueue.length === 0) {
        return;
    }

    // 不在动态页显示通知
    const momentsScreen = document.getElementById('moments-screen');
    if (momentsScreen && momentsScreen.classList.contains('active')) {
        return;
    }

    isNotificationShowing = true;
    const notification = notificationQueue.shift();
    
    const banner = document.getElementById('global-notification-banner');
    const avatar = document.getElementById('notification-avatar');
    const textEl = document.getElementById('notification-text');

    avatar.src = notification.avatar;
    textEl.innerHTML = notification.text; // 使用innerHTML以支持简单的HTML标签

    banner.classList.add('show');
    
    // 点击横幅跳转到动态页面
    banner.onclick = () => {
        switchScreen('moments-screen');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500); // 检查队列中是否还有下一条
    };

    // 5秒后自动隐藏
    setTimeout(() => {
        banner.classList.remove('show');
        isNotificationShowing = false;
        // 检查队列中是否还有下一条
        setTimeout(showNotificationBanner, 500);
    }, 5000);
}

function setupNotificationSystem() {
    // 定时检查通知队列
    setInterval(showNotificationBanner, 2000); // 每2秒检查一次

    // 关闭按钮
    const closeBtn = document.getElementById('notification-close-btn');
    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 防止触发横幅的点击事件
        const banner = document.getElementById('global-notification-banner');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    });
}
// 在 init() 函数之前添加
// V V V V V  请用这段完整代码替换旧的 setupMentions 函数 V V V V V
// 在 init() 函数之前添加这个新函数
// V V V V V  请用这段完整代码替换旧的 setupMomentsEventListeners 函数 V V V V V
function setupMomentsEventListeners() {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
        console.error("关键错误：未能找到 #moments-screen 元素。");
        return;
    }

    // --- 统一的点击事件监听器 (在捕获阶段运行) ---
    momentsScreen.addEventListener('click', (e) => {
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        // --- 评论区交互逻辑 ---
        const commentEl = e.target.closest('.moment-comment');
        if (commentEl) {
            e.stopPropagation(); // 捕获到事件后，阻止它继续传播
            const authorId = commentEl.dataset.authorId;
            
            // 关键修复：如果点击的是自己的评论，弹出提示
            if (authorId === myId) {
                showToast("不能回复自己的评论哦~");
                return;
            }

            const momentItem = commentEl.closest('.moment-item');
            if (!momentItem) return;

            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            const input = inputArea.querySelector('input');
            const postBtn = inputArea.querySelector('button');
            const authorName = window.getAuthorNameById(authorId) || '评论者';

            // 设置回复状态
            input.placeholder = `回复 ${authorName}:`;
            inputArea.classList.add('visible');
            input.focus();
            postBtn.dataset.replyToCommentId = commentEl.dataset.commentId;
        }
    }, true); // <--- 注意这里的 "true"，表示在捕获阶段监听

    // --- 统一的输入事件监听器 (在捕获阶段运行) ---
    const mentionPanel = document.getElementById('mention-panel');
    let currentInputElement = null;

    const showMentionPanel = (inputElement) => {
        currentInputElement = inputElement;

        // 关键修复：如果角色列表为空，则显示提示
        if (!db || !db.characters || db.characters.length === 0) {
            mentionPanel.innerHTML = '<div class="mention-item" style="color:#aaa;">没有可@的角色</div>';
        } else {
            mentionPanel.innerHTML = '';
            db.characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `<img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span>`;
                item.onmousedown = (evt) => {
                    evt.preventDefault();
                    const text = inputElement.value;
                    const cursorPos = inputElement.selectionStart;
                    const textBeforeCursor = text.substring(0, cursorPos);
                    const atIndex = textBeforeCursor.lastIndexOf('@');
                    
                    const newText = text.substring(0, atIndex) + `@${char.remarkName} ` + text.substring(cursorPos);
                    inputElement.value = newText;
                    
                    hideMentionPanel();
                    inputElement.focus();
                    
                    const newCursorPos = atIndex + `@${char.remarkName} `.length;
                    // 使用 setTimeout 确保光标在值更新后移动
                    setTimeout(() => inputElement.setSelectionRange(newCursorPos, newCursorPos), 0);
                };
                mentionPanel.appendChild(item);
            });
        }
        
        const rect = inputElement.getBoundingClientRect();
        mentionPanel.style.display = 'block';
        // 关键修复：更稳健的定位，总是在输入框上方
        mentionPanel.style.bottom = `${window.innerHeight - rect.top}px`;
        mentionPanel.style.left = `${rect.left}px`;
        mentionPanel.style.width = `${rect.width}px`;
        mentionPanel.style.top = 'auto'; // 取消top定位
    };

    const hideMentionPanel = () => {
        if (mentionPanel) mentionPanel.style.display = 'none';
        currentInputElement = null;
    };

    momentsScreen.addEventListener('input', (e) => {
        if (e.target.matches('#post-text, .moment-comment-input')) {
            const input = e.target;
            const cursorPos = input.selectionStart;
            const textBeforeCursor = input.value.substring(0, cursorPos);

            // 当光标前是@时触发
            if (textBeforeCursor.endsWith('@')) {
                showMentionPanel(input);
            } else if (!/@\S*$/.test(textBeforeCursor)) {
                hideMentionPanel();
            }
        }
    }, true); // <--- 注意这里的 "true"，表示在捕获阶段监听

    // 点击或滚动时隐藏面板
    document.addEventListener('click', (e) => {
        if (currentInputElement && !mentionPanel.contains(e.target) && e.target !== currentInputElement) {
            hideMentionPanel();
        }
    }, true);
    document.addEventListener('scroll', hideMentionPanel, true);
}
// ^ ^ ^ ^ ^  替换结束 ^ ^ ^ ^ ^


// --- AI轨迹功能 ---

// 1. 生成向AI请求轨迹的指令
// ▼▼▼ 请用这个新版本，完整替换掉旧的 generateTrajectoryPrompt 函数 ▼▼▼
function generateTrajectoryPrompt(character) {
    // --- 新增：获取当前时间 ---
    const now = new Date();
    const currentHour = String(now.getHours()).padStart(2, '0');
    const currentMinute = String(now.getMinutes()).padStart(2, '0');
    const currentTimeString = `${currentHour}:${currentMinute}`;
    // --- 新增结束 ---

    const memory = character.history.slice(-15);
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。`;
    prompt += `请根据你的人设和我们最近的对话，想象一下你今天从早上到现在的生活轨迹。\n`;
    prompt += `规则：\n`;
    prompt += `1. 生成10个关键的时间点和对应的事件或想法。\n`;
    prompt += `2. 时间点需从早到晚排列。\n`;
    // --- 核心修改：添加下面两条新规则 ---
    prompt += `3. 事件内容要符合你的人设，并且其中至少有2-3条需要与我（${character.myName}）相关，例如：想我了、看我们的聊天记录、准备给我的惊喜等。\n`;
    prompt += `4. 所有时间点都不能晚于当前时间 ${currentTimeString}。\n`;
    // --- 修改结束 ---
    prompt += `5. 每个事件的描述必须非常简洁，不能超过12个字。\n`;
    prompt += `6. 你的输出必须严格遵循以下JSON格式，不要包含任何额外的解释或文字：\n`;
    prompt += `[{"time": "HH:MM", "event": "事件描述"}, {"time": "HH:MM", "event": "事件描述"}, ...]\n\n`;
    prompt += `最近的对话参考如下:\n${historyText}`;

    return prompt;
}

// 2. 显示轨迹弹窗并填充数据
function renderTrajectoryTimeline(trajectoryData, characterName) {
    const timeline = document.getElementById('trajectory-timeline');
    const title = document.getElementById('trajectory-modal-title');
    
    title.textContent = `${characterName}的轨迹`;
    timeline.innerHTML = ''; // 清空旧内容

    if (!trajectoryData || trajectoryData.length === 0) {
        timeline.innerHTML = '<div class="placeholder-text">未能获取到轨迹信息。</div>';
        return;
    }

    trajectoryData.forEach(item => {
        const div = document.createElement('div');
        div.className = 'trajectory-item';
        div.innerHTML = `
            <span class="trajectory-time">${item.time}</span>
            <p class="trajectory-event">${item.event}</p>
        `;
        timeline.appendChild(div);
    });
}

// 3. 设置所有相关的事件监听
// ▼▼▼ 请用这个新版本，完整替换掉旧的 setupTrajectorySystem 函数 ▼▼▼
function setupTrajectorySystem() {
    const trajectoryBtn = document.getElementById('ai-trajectory-btn');
    const trajectoryModal = document.getElementById('trajectory-modal');
    const closeBtn = document.getElementById('close-trajectory-modal-btn');

    trajectoryBtn.addEventListener('click', async () => {
        if (currentChatType !== 'private' || !currentChatId) return;
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;

        let aiResponseText = ''; // 在 try 之前声明，以便 catch 中也能访问

        // 打开弹窗并显示加载状态
        trajectoryModal.classList.add('visible');
        document.getElementById('trajectory-timeline').innerHTML = '<div class="placeholder-text">正在加载轨迹...</div>';

        try {
            const prompt = generateTrajectoryPrompt(character);
            let messagesForApi;
            const { provider } = db.apiSettings;

            if (provider === 'gemini') {
                messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
            } else {
                messagesForApi = [{ role: 'user', content: prompt }];
            }

            aiResponseText = await callAiApi(messagesForApi);
            
            // --- 核心修正：从AI的回复中提取出纯净的JSON部分 ---
            // 使用正则表达式寻找被方括号[]包裹的所有内容
            const jsonMatch = aiResponseText.match(/\[[\s\S]*\]/); 
            
            if (!jsonMatch) {
                // 如果找不到，就说明AI返回的内容完全不符合预期
                throw new Error("AI的回复中没有找到有效的JSON数组。");
            }
            
            // 提取匹配到的、干净的JSON字符串
            const cleanJsonString = jsonMatch[0]; 
            // --- 修正结束 ---

            // 使用清理过的字符串进行解析
            const trajectoryData = JSON.parse(cleanJsonString);
            renderTrajectoryTimeline(trajectoryData, character.remarkName);

        } catch (error) {
            console.error('获取AI轨迹失败:', error);
            console.log('--- 导致错误的AI原始回复 ---');
            console.log(aiResponseText);
            console.log('--------------------------');
            document.getElementById('trajectory-timeline').innerHTML = `<div class="placeholder-text" style="color:red;">获取轨迹失败：${error.message}<br><br>请检查浏览器控制台（按F12）查看AI返回的原始错误信息。</div>`;
        }
    });

    closeBtn.addEventListener('click', () => {
        trajectoryModal.classList.remove('visible');
    });

    trajectoryModal.addEventListener('click', (e) => {
        if (e.target === trajectoryModal) {
            trajectoryModal.classList.remove('visible');
        }
    });
}


// --- 论坛AI功能：为用户的帖子生成评论 ---
function generateForumBoardPrompt(boardId, boardName, characterList) {
    // 从角色列表中随机挑选2到3名角色
    let shuffled = [...characterList].sort(() => 0.5 - Math.random());
    const selectedCharacters = shuffled.slice(0, Math.min(shuffled.length, Math.floor(Math.random() * 2) + 2)); // 随机选2或3个

    let charactersPromptPart = '以下是本次参与发帖的AI角色和他们的设定：\n';
    selectedCharacters.forEach(char => {
        charactersPromptPart += `- 角色“${char.realName}”（昵称：${char.remarkName}），人设：${char.persona}\n`;
    });

    let prompt = `你是一个论坛内容生成AI。${charactersPromptPart}\n`;
    prompt += `你正在为虚拟手机应用的“论坛”里的【${boardName}】版块，***必须***生成一个包含**不多不少正好10条**帖子摘要的列表。\n\n`;
    prompt += `规则：\n`;
    prompt += `1. **严格围绕【${boardName}】的主题**来创作帖子内容。\n`;
    prompt += `2. **帖子构成**: 你的目标是凑齐10条帖子。构成如下：\n`;
    prompt += `   a. 上方名单中的**每一个AI角色都必须至少发布1条帖子**。他们的帖子要符合他们各自的人设，AI角色可以匿名，但要括号标出是谁。\n`;
    prompt += `   b. **用你虚构的“路人甲”或其他NPC的帖子，补足剩余的数量，直到总数达到10条**。这是为了确保无论AI角色发了多少条，最终结果永远是10条。\n`;
    prompt += `3. 每条帖子都需要包含：标题(title), 作者(author), 3条评论预览(comments), 点赞数(likes), 以及是否热门(isHot)。\n`;
    prompt += `4. 你的输出必须严格遵循以下JSON数组格式，不要包含任何额外的解释或文字：\n`;
    prompt += `[{"title": "帖子标题", "author": "作者名", "likes": 35, "isHot": true, "comments": [{"author":"评论者A", "text":"这是第一条评论"}, ...]}, ...]`;

    return prompt;
}

// --- 论坛AI功能：为指定帖子生成正文和详细评论 ---
function generateForumThreadPrompt(threadTitle, threadAuthor, character) {
 
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我正在论坛里查看一个帖子，请你为这个帖子生成详细的“正文(content)”和“评论区(comments)”。\n\n`;
    prompt += `帖子的标题是：“${threadTitle}”\n`;
    prompt += `帖子的作者是：“${threadAuthor}”\n\n`;
    prompt += `生成规则：\n`;
    prompt += `1. **正文(content)**：根据标题和作者，创作一段大约100-200字的帖子正文，内容要符合作者的人设和帖子的主题。\n`;
    prompt += `2. **评论区(comments)**：生成5-10条评论。其中，必须有1-2条是你（${character.realName}）自己发表的评论，其余由你虚构的“路人甲”或相关NPC发表。\n`;
    prompt += `3. **楼中楼**：在生成的评论中，随机为2-3条评论，再生成2-3条“对评论的回复”（楼中楼）。\n`;
    prompt += `4. **你的输出必须严格遵循以下JSON格式**，不要包含任何额外的解释或文字：\n`;
    prompt += `{"content": "这里是帖子正文...", "comments": [{"author": "评论者A", "text": "这是评论内容", "replies": [{"author": "回复者B", "text": "这是对A的回复"}, ...]}, ...]}`;
    
    return prompt;
}


// ▲▲▲ 添加结束 ▲▲▲


  
// --- 论坛AI功能：为指定版块生成帖子列表 ---

function generateSharePostPrompt(postTitle, postContent, postAuthor, character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我（${character.myName}）刚刚在论坛里看到了一个由“${postAuthor}”发布的帖子，觉得很有趣，现在把它转发给你。请注意，这个帖子**不是我写的**。\n\n`;
    prompt += `--- 转发的帖子信息 ---\n`;
    prompt += `帖子作者： "${postAuthor}"\n`;
    prompt += `帖子标题： "${postTitle}"\n`;
    prompt += `帖子正文： "${postContent}"\n`;
    prompt += `--- 帖子信息结束 ---\n\n`;
    prompt += `你的任务：\n`;
    prompt += `1. **你的第一条消息必须是表明你收到了转发**，格式为：\`[${character.realName}转发了帖子“${postTitle}”]\`\n`;
    prompt += `2. **然后，请根据你的角色人设和帖子的内容，发表你对此的看法**。你的回复要自然、连贯，就像真的看到了这个帖子一样。\n`;
    prompt += `3. 你的回复可以包含多条消息，但必须严格遵循格式，例如：\`[${character.realName}的消息：你的评论...]\`\n`;

    return prompt;
}
      
// --- 论坛AI功能：为指定帖子生成正文和详细评论 ---
function generateForumThreadPrompt(threadTitle, threadAuthor, character) {
    const boards = {
        life: '生活闲聊',
        secrets: '秘密树洞',
        gossip: '八卦吃瓜',
        travel: '旅游美食'
    };
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我正在论坛里查看一个帖子，请你为这个帖子生成详细的“正文(content)”和“评论区(comments)”。\n\n`;
    prompt += `帖子的标题是：“${threadTitle}”\n`;
    prompt += `帖子的作者是：“${threadAuthor}”\n\n`;
    prompt += `生成规则：\n`;
    prompt += `1. **正文(content)**：根据标题和作者，创作一段大约100-200字的帖子正文，内容要符合作者的人设和帖子的主题。\n`;
    prompt += `2. **评论区(comments)**：生成5-10条评论。其中，必须有1-2条是你（${character.realName}）自己发表的评论，其余由你虚构的“路人甲”或相关NPC发表。\n`;
    prompt += `3. **楼中楼**：在生成的评论中，随机为2-3条评论，再生成2-3条“对评论的回复”（楼中楼）。\n`;
    prompt += `4. **你的输出必须严格遵循以下JSON格式**，不要包含任何额外的解释或文字：\n`;
    prompt += `{"content": "这里是帖子正文...", "comments": [{"author": "评论者A", "text": "这是评论内容", "replies": [{"author": "回复者B", "text": "这是对A的回复"}, ...]}, ...]}`;
    
    return prompt;
}
// ▼▼▼ 把下面这个完整的 setupForumSystem 函数粘贴在这里 ▼▼▼
function setupForumSystem() {
    const boards = {
        life: '生活闲聊',
        secrets: '秘密树洞',
        gossip: '八卦吃瓜',
        travel: '旅游美食'
    };
    let currentBoardId = 'life';
    

    const forumHeader = document.getElementById('forum-header');
    const boardTitleHeader = document.getElementById('forum-board-title-header');
    const dropdownMenu = document.getElementById('forum-dropdown-menu');
    const threadListContainer = document.getElementById('thread-list-container');
    const refreshBtn = document.getElementById('refresh-board-btn');
    const threadContentContainer = document.getElementById('thread-content-container');

    function renderDropdownMenu() {
        dropdownMenu.innerHTML = '';
        Object.entries(boards).forEach(([id, name]) => {
            if (id !== currentBoardId) {
                const item = document.createElement('div');
                item.className = 'forum-dropdown-item';
                item.dataset.boardId = id;
                item.textContent = name;
                dropdownMenu.appendChild(item);
            }
        });
    }

    function renderThreadList(boardId) {
        const threads = db.forumData[boardId] || [];
        threadListContainer.innerHTML = ''; 
        if (threads.length === 0) {
            threadListContainer.innerHTML = `<p class="placeholder-text">点击右上角刷新按钮<br>发现【${boards[boardId]}】的新帖子吧！</p>`;
            return;
        }
        threads.forEach(thread => {
            const threadEl = document.createElement('div');
            threadEl.className = 'thread-list-item';
            threadEl.dataset.threadTitle = thread.title;
            threadEl.dataset.threadAuthor = thread.author;
            const commentsPreviewHTML = (thread.comments || []).slice(0, 3).map(comment => `<div class="comment"><span class="comment-author">${comment.author}:</span><span class="comment-text">${comment.text}</span></div>`).join('');
            threadEl.innerHTML = `<div class="thread-title">${thread.isHot ? '<span class="hot-icon">🔥</span>' : ''} ${thread.title}</div><div class="thread-meta">由 <span class="author">${thread.author}</span> 发布 | ❤️ <span class="likes">${thread.likes}</span></div><div class="thread-comment-preview">${commentsPreviewHTML || '还没有评论哦~'}</div>`;
            threadListContainer.appendChild(threadEl);
        });
    }

    function updateForumView() {
        const currentBoardName = boards[currentBoardId];
        boardTitleHeader.textContent = currentBoardName;
        renderThreadList(currentBoardId);
    }
    
    function toggleDropdown(show) {
        const isVisible = dropdownMenu.classList.contains('visible');
        if (show === isVisible) return;
        if (show) {
            renderDropdownMenu();
            forumHeader.classList.add('open');
            dropdownMenu.classList.add('visible');
        } else {
            forumHeader.classList.remove('open');
            dropdownMenu.classList.remove('visible');
        }
    }

    forumHeader.addEventListener('click', (e) => { e.stopPropagation(); toggleDropdown(!dropdownMenu.classList.contains('visible')); });
    dropdownMenu.addEventListener('click', (e) => {
        const item = e.target.closest('.forum-dropdown-item');
        if (item) {
            currentBoardId = item.dataset.boardId;
            updateForumView();
            toggleDropdown(false);
        }
    });
    document.addEventListener('click', (e) => { if (!forumHeader.contains(e.target)) { toggleDropdown(false); } });
    
    // --- 这是我们最终的、正确的刷新逻辑 ---
    refreshBtn.addEventListener('click', async () => {
        if (isGenerating) return;

        // 检查是否有AI角色存在
        if (!db.characters || db.characters.length === 0) {
            showToast('请先创建至少一个AI角色！');
            return;
        }
        
        showToast(`正在为【${boards[currentBoardId]}】版块创作中...`);
        isGenerating = true;
        refreshBtn.disabled = true;
        
        try {
            // 生成剧本时，传入所有AI角色的列表
            const prompt = generateForumBoardPrompt(currentBoardId, boards[currentBoardId], db.characters);
            
            let messagesForApi;
            if (db.apiSettings.provider === 'gemini') {
                messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
            } else {
                messagesForApi = [{ role: 'user', content: prompt }];
            }

            const aiResponseText = await callAiApi(messagesForApi);
            const jsonMatch = aiResponseText.match(/\[[\s\S]*\]/);
            if (!jsonMatch) { throw new Error("AI的回复中没有找到有效的JSON数组。"); }
            
            const newThreads = JSON.parse(jsonMatch[0]);
            
            db.forumData[currentBoardId] = newThreads; // 存入长期数据库
await saveData(); // 立即保存到本地
            renderThreadList(currentBoardId);

        } catch (error) {
            console.error('生成论坛帖子失败:', error);
            showToast(`生成帖子失败: ${error.message}`);
        } finally {
            isGenerating = false;
            refreshBtn.disabled = false;
        }
    });
    
    threadListContainer.addEventListener('click', async (e) => {
        const threadItem = e.target.closest('.thread-list-item');
        if (!threadItem) return;

        const threadTitle = threadItem.dataset.threadTitle;
        const threadAuthor = threadItem.dataset.threadAuthor;
        
        // 随机选择一个AI来“脑补”帖子详情
        const character = db.characters[Math.floor(Math.random() * db.characters.length)];
        if (!character) {
             showToast('没有找到AI角色来生成帖子详情。');
            return;
        }

        switchScreen('forum-thread-screen');
        threadContentContainer.innerHTML = `<p class="placeholder-text">正在加载“${threadTitle}”的详细内容...</p>`;

        try {
            const prompt = generateForumThreadPrompt(threadTitle, threadAuthor, character);
            let messagesForApi;
            if (db.apiSettings.provider === 'gemini') {
                messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
            } else {
                messagesForApi = [{ role: 'user', content: prompt }];
            }
            const aiResponseText = await callAiApi(messagesForApi);
            const jsonMatch = aiResponseText.match(/{[\s\S]*}/);
            if (!jsonMatch) { throw new Error("AI的回复中没有找到有效的JSON对象。"); }
            const threadData = JSON.parse(jsonMatch[0]);
            let commentsHTML = '';
            (threadData.comments || []).forEach(comment => {
                let repliesHTML = '';
                if (comment.replies && comment.replies.length > 0) {
                    repliesHTML = comment.replies.map(reply => `<div class="thread-reply"><strong>${reply.author}:</strong> ${reply.text}</div>`).join('');
                }
                commentsHTML += `<div class="thread-comment"><p><strong>${comment.author}:</strong> ${comment.text}</p>${repliesHTML}</div>`;
            });
            threadContentContainer.innerHTML = `<div class="thread-full-content"><h2>${threadTitle}</h2><p class="author-line">由 ${threadAuthor} 发布</p><div class="main-post-body">${threadData.content}</div></div><hr><div class="comments-section"><h3>评论区</h3>${commentsHTML}</div>`;
        } catch (error) {
            console.error('生成帖子详情失败:', error);
            threadContentContainer.innerHTML = `<p class="placeholder-text" style="color:red;">加载帖子详情失败: ${error.message}</p>`;
        }
    });

    updateForumView();
}
const shareThreadBtn = document.getElementById('share-thread-btn');
const sharePostModal = document.getElementById('share-post-modal');
const sharePostSelectionList = document.getElementById('share-post-selection-list');
const confirmPostShareBtn = document.getElementById('confirm-post-share-btn');
const cancelPostShareBtn = document.getElementById('cancel-post-share-btn');
let currentPostToShare = { title: '', content: '' };

// 1. 给帖子详情页的“分享”按钮添加点击事件
shareThreadBtn.addEventListener('click', () => {
    // 获取当前正在查看的帖子的标题和内容
const titleEl = document.querySelector('#thread-content-container .thread-full-content h2');
const contentEl = document.querySelector('#thread-content-container .main-post-body');
const authorLineEl = document.querySelector('#thread-content-container .author-line');

if (!titleEl || !contentEl || !authorLineEl) {
    showToast('无法获取完整的帖子内容');
    return;
}

currentPostToShare.title = titleEl.textContent;
currentPostToShare.content = contentEl.textContent;
// 新增：从 "由 作者 发布" 中提取作者名
currentPostToShare.author = authorLineEl.textContent.replace('由', '').replace('发布', '').trim();
    // 渲染角色选择列表
    sharePostSelectionList.innerHTML = '';
    if (db.characters.length === 0) {
        sharePostSelectionList.innerHTML = '<li>没有可以分享的AI角色</li>';
    } else {
        db.characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'world-book-select-item'; // 复用现有样式
            // 使用 radio 按钮实现单选
            li.innerHTML = `
                <input type="radio" id="share-select-${char.id}" name="share-char-selection" value="${char.id}">
                <label for="share-select-${char.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                    <img src="${char.avatar}" alt="${char.remarkName}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                    <span>${char.remarkName}</span>
                </label>
            `;
            sharePostSelectionList.appendChild(li);
        });
    }

    // 显示分享弹窗
    sharePostModal.classList.add('visible');
});

// 2. 给分享弹窗的“取消”按钮添加事件
cancelPostShareBtn.addEventListener('click', () => {
    sharePostModal.classList.remove('visible');
});

// 3. 给分享弹窗的“确认分享”按钮添加事件 (核心)
confirmPostShareBtn.addEventListener('click', async () => {
    const selectedRadio = sharePostSelectionList.querySelector('input[name="share-char-selection"]:checked');
    if (!selectedRadio) {
        showToast('请选择一个分享对象');
        return;
    }

    const charId = selectedRadio.value;
    const character = db.characters.find(c => c.id === charId);
    if (!character) {
        showToast('找不到该角色');
        return;
    }

    sharePostModal.classList.remove('visible');
    showToast(`正在将帖子分享给 ${character.remarkName}...`);

    try {
        // 使用我们新创建的函数来生成AI指令
const prompt = generateSharePostPrompt(currentPostToShare.title, currentPostToShare.content, currentPostToShare.author, character);

        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }

        // 调用AI接口
        const aiResponseText = await callAiApi(messagesForApi);

        // 将AI返回的多条回复添加到对应的聊天记录中
        const replies = aiResponseText.split('\n').filter(line => line.trim() !== '');
        replies.forEach(replyContent => {
            const message = {
                id: `msg_shared_post_reply_${Date.now()}_${Math.random()}`,
                role: 'assistant',
                content: replyContent.trim(),
                parts: [{ type: 'text', text: replyContent.trim() }],
                timestamp: Date.now()
            };
            character.history.push(message);
        });

        await saveData();
        showToast('分享成功！AI已在聊天中回复你。');

        // 自动跳转到对应的聊天界面
        currentChatId = character.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } catch (error) {
        console.error('分享帖子并获取AI回复失败:', error);
        showToast(`分享失败: ${error.message}`);
    }
});
      
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- Memories System Functions ---

        function setupMemoriesSystem() {
            document.getElementById('ai-memories-btn').addEventListener('click', () => {
                if (currentChatId && currentChatType === 'private') {
                    openMemoriesScreen(currentChatId);
                }
            });

            document.getElementById('memories-list-container').addEventListener('click', (e) => {
                const memoryItem = e.target.closest('.list-item');
                if (memoryItem && memoryItem.dataset.id) {
                    openMemoryDetail(memoryItem.dataset.id);
                }
            });
        }

        function openMemoriesScreen(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (character) {
                renderMemoriesList(character.memories || []);
                switchScreen('memories-screen');
            }
        }

        function renderMemoriesList(memories) {
            const container = document.getElementById('memories-list-container');
            const placeholder = document.getElementById('no-memories-placeholder');

            if (!memories || memories.length === 0) {
                container.innerHTML = '';
                placeholder.style.display = 'block';
                return;
            }

            placeholder.style.display = 'none';
            container.innerHTML = '';

            const sortedMemories = [...memories].sort((a, b) => b.timestamp - a.timestamp);

            sortedMemories.forEach(memory => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.dataset.id = memory.id;

                const date = new Date(memory.timestamp);
                const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

                li.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${memory.title}</div>
                        <div class="item-preview">${dateString}</div>
                    </div>
                `;
                container.appendChild(li);
            });
        }

        function openMemoryDetail(memoryId) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (!character || !character.memories) return;

            const memory = character.memories.find(m => m.id === memoryId);
            if (!memory) {
                showToast('找不到该回忆');
                return;
            }

            const container = document.getElementById('memory-detail-content');
            const date = new Date(memory.timestamp);
            const dateString = `${date.getFullYear()}年${pad(date.getMonth() + 1)}月${pad(date.getDate())}日`;

            container.innerHTML = `
                <h2 class="memory-title">${memory.title}</h2>
                <p class="memory-main-content">${memory.content}</p>
                <div class="memory-commentary">${memory.commentary}</div>
                <div class="memory-signature">
                    <span class="ai-name">${character.realName}</span>
                    <span class="date">${dateString}</span>
                </div>
            `;
            switchScreen('memory-detail-screen');
        }

        async function saveMemory(characterId, memoryData) {
            const character = db.characters.find(c => c.id === characterId);
            if (character && memoryData.title && memoryData.content && memoryData.commentary) {
                if (!character.memories) {
                    character.memories = [];
                }
                const newMemory = {
                    id: `memory_${Date.now()}`,
                    timestamp: Date.now(),
                    title: memoryData.title,
                    content: memoryData.content,
                    commentary: memoryData.commentary
                };
                character.memories.push(newMemory);
                await saveData();
                console.log("一段新的回忆已保存:", newMemory);
            }
        }
        // --- 自定义主屏幕小组件功能 ---
function setupCustomWidgetSystem() {
    // 缓存弹窗相关的DOM元素
    const modal = document.getElementById('customize-widget-modal');
    const form = document.getElementById('customize-widget-form');
    const fileUpload = document.getElementById('widget-image-upload');
    const imageUrlInput = document.getElementById('widget-image-url-input');
    const editingWidgetIdInput = document.getElementById('editing-widget-id');
    const widgetTextInput = document.getElementById('widget-text-input');
    const homeScreenEl = document.getElementById('home-screen');

    // 打开编辑器弹窗的函数
    const openWidgetEditor = (widgetId) => {
        const widgetData = db.customWidgets.find(w => w.id === widgetId);
        if (!widgetData) return;

        form.reset(); // 清除旧数据
        editingWidgetIdInput.value = widgetId;
        widgetTextInput.value = widgetData.text;
        imageUrlInput.value = widgetData.imageUrl;

        modal.classList.add('visible');
    };

    // 在主屏幕上使用事件委托来监听点击
    if(homeScreenEl) {
        homeScreenEl.addEventListener('click', (e) => {
            const widget = e.target.closest('.contact-widget[data-widget-id]');
            if (widget) {
                openWidgetEditor(widget.dataset.widgetId);
            }
        });
    }

    // 处理表单提交
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const widgetId = editingWidgetIdInput.value;
        const newText = widgetTextInput.value.trim();
        const newImageUrl = imageUrlInput.value.trim();

        const widgetIndex = db.customWidgets.findIndex(w => w.id === widgetId);
        if (widgetIndex > -1) {
            db.customWidgets[widgetIndex].text = newText;
            db.customWidgets[widgetIndex].imageUrl = newImageUrl;
        }

        await saveData();
        modal.classList.remove('visible');
        showToast('组件已更新！');
        
        // 直接更新主屏幕上的组件，无需重绘整个屏幕
        const widgetEl = document.getElementById(`custom-widget-${widgetId === 'widget1' ? '1' : '2'}`);
        if(widgetEl){
            widgetEl.querySelector('img').src = newImageUrl;
            widgetEl.querySelector('span').textContent = newText;
        }
    });

    // 处理文件上传
    fileUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                imageUrlInput.value = compressedUrl;
            } catch (error) {
                showToast('图片处理失败，请重试');
            } finally {
                e.target.value = null; // 清空文件输入
            }
        }
    });

    // 点击弹窗外部区域关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.classList.remove('visible');
        }
    });
}
// === 新增的AI总结并清空历史记录的函数 ===
async function summarizeAndClearHistory() {
    if (isGenerating) {
        showToast('AI正在思考中，请稍后重试...');
        return;
    }

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat || chat.history.length === 0) {
        showToast('没有聊天记录可供总结。');
        chat.history = []; // 仍然清空
        await saveData();
        renderMessages(false, true);
        return;
    }

    isGenerating = true;
    const sidebar = (currentChatType === 'private') ? settingsSidebar : groupSettingsSidebar;
    sidebar.classList.remove('open');
    showToast('正在请求AI总结回忆，请稍候...');

    try {
        const historyText = chat.history
            .map(msg => msg.content)
            .join('\n');

        const prompt = `你是一个记忆总结助手。请根据以下完整的聊天记录，用第一人称（即角色的口吻）生成一段非常简洁、精炼的核心回忆摘要，不超过200字。这份摘要将作为角色的永久记忆。请直接输出摘要内容，不要包含任何额外的话。聊天记录如下：\n\n${historyText}`;

        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }

        const summary = await callAiApi(messagesForApi);

        // 将新旧总结合并
        const oldSummary = chat.memorySummary || '';
        chat.memorySummary = (oldSummary ? oldSummary + '\n\n' : '') + `[${new Date().toLocaleString()}]\n` + summary.trim();
        
        // 清空历史记录
        chat.history = [];

        await saveData();
        renderMessages(false, true); // 刷新聊天界面
        renderChatList(); // 刷新聊天列表
        showToast('回忆总结已完成并保存，聊天记录已清空！');

    } catch (error) {
        console.error('总结回忆失败:', error);
        showToast(`总结失败: ${error.message}。记录未被清空。`);
    } finally {
        isGenerating = false;
    }
}
// === 新增：处理回忆记录面板的显示功能 ===
function setupMemorySummaryModal() {
    const modal = document.getElementById('memory-summary-modal');
    const contentEl = document.getElementById('memory-summary-content');
    const closeBtn = document.getElementById('close-memory-summary-btn');

    // 关闭按钮和背景点击事件
    const closeModal = () => modal.classList.remove('visible');
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });

    // 为私聊设置中的“查看回忆”按钮绑定事件
    document.getElementById('show-memory-summary-btn').addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (character) {
            contentEl.textContent = character.memorySummary || '还没有任何回忆记录。';
            modal.classList.add('visible');
        }
    });

    // 为群聊设置中的“查看回忆”按钮绑定事件
    document.getElementById('show-group-memory-summary-btn').addEventListener('click', () => {
        const group = db.groups.find(g => g.id === currentChatId);
        if (group) {
            contentEl.textContent = group.memorySummary || '还没有任何群聊回忆记录。';
            modal.classList.add('visible');
        }
    });
}
// === 新增：主页头图编辑器功能 ===
function setupHomeScreenProfileEditor() {
    const header = document.querySelector('.home-profile-header');
    if (!header) return;

    // 元素缓存
    const heroEl = header.querySelector('.home-hero');
    const avatarImg = header.querySelector('#home-profile-avatar');
    const nameEl = header.querySelector('.home-profile-name');
    const signatureEl = header.querySelector('.home-profile-signature');
    
    // 1. 渲染函数：从数据库读取数据并更新UI
    function renderProfile() {
        const profile = db.homeProfile;
        heroEl.style.backgroundImage = `url('${profile.heroBg}')`;
        avatarImg.src = profile.avatar;
        nameEl.textContent = profile.name;
        signatureEl.textContent = profile.signature;
    }

    // 2. 保存函数
    async function saveProfile() {
        await saveData();
        showToast('主页信息已更新');
    }
    
    // 3. 图片编辑逻辑
    heroEl.addEventListener('click', async () => {
        const newBg = prompt('请输入新的背景图URL：', db.homeProfile.heroBg);
        if (newBg && newBg.trim()) {
            db.homeProfile.heroBg = newBg.trim();
            renderProfile();
            await saveProfile();
        }
    });

    avatarImg.parentElement.addEventListener('click', async () => {
        const newAvatar = prompt('请输入新的头像URL：', db.homeProfile.avatar);
        if (newAvatar && newAvatar.trim()) {
            db.homeProfile.avatar = newAvatar.trim();
            renderProfile();
            await saveProfile();
        }
    });

    // 4. 文字内联编辑逻辑
    nameEl.addEventListener('click', async () => {
        const newName = prompt('请输入新的昵称：', db.homeProfile.name);
        if (newName && newName.trim()) {
            db.homeProfile.name = newName.trim();
            renderProfile();
            await saveProfile();
        }
    });

    signatureEl.addEventListener('click', async () => {
        const newSignature = prompt('请输入新的个性签名：', db.homeProfile.signature);
        if (newSignature && newSignature.trim()) {
            db.homeProfile.signature = newSignature.trim();
            renderProfile();
            await saveProfile();
        }
    });

    // 首次加载时渲染一次
    renderProfile();
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// --- AI空间 (AI POV Chat) 功能 [由AI生成对话的修改版] ---

// 用于临时存储AI生成数据的全局变量
let currentAiPovData = {
    mainAi: null,
    chatList: [],
    conversations: {} // key是povChatId
};
/**
 * [新的辅助函数] 检查两个角色是否可能根据其人设和世界书相互认识。
 * @param {object} charA - 第一个角色对象。
 * @param {object} charB - 第二个角色对象。
 * @returns {boolean} - 如果确认相识则返回 true，否则返回 false。
 */
function charactersAreAcquainted(charA, charB) {
    // 获取两个角色的所有已知名称，用于检查提及。
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // 将人设和所有关联的世界书内容合并为每个角色的单个上下文字符串。
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // 进行双向检查。
    // 角色A的上下文（人设或世界书）是否提及了角色B的名字？
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // 角色B的上下文（人设或世界书）是否提及了角色A的名字？
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // 只要任意一方的上下文中提到了对方，就认为他们相识。
    return aKnowsB || bKnowsA;
}
/**
 * 为AI生成“聊天列表”的指令
 * @param {object} mainAi - 主视角AI的角色对象
 * @param {Array} allOtherCharacters - 其他所有可互动的AI角色列表
 * @param {object} userProfile - 用户信息对象
 * @returns {string} - 发给大语言模型的完整指令
 */
function generateAiChatListPrompt(mainAi, allOtherCharacters, userProfile) {
    if (!Array.isArray(allOtherCharacters)) {
        allOtherCharacters = [];
    }

    // [新增逻辑] 根据人设和世界书筛选出真正认识的角色
    const acquaintedChars = allOtherCharacters.filter(charB => charactersAreAcquainted(mainAi, charB));

    let otherCharsPrompt = acquaintedChars.length > 0
        ? acquaintedChars.map(c => `- ${c.realName} (人设: ${c.persona})`).join('\n')
        : '无其他可互动角色。';

    let worldBooksPrompt = (mainAi.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(Boolean)
        .map(wb => `[${wb.name}]\n${wb.content}`)
        .join('\n\n');

    let prompt = `你是一个AI角色扮演辅助工具。你的任务是为AI角色“${mainAi.realName}”生成一个虚拟的聊天列表。

# 角色信息
- 主视角AI: ${mainAi.realName} (人设: ${mainAi.persona})
- 用户: ${userProfile.name} (用户在我眼中的人设: ${mainAi.myPersona || '未设定'})
- 其他**认识的、可互动的**AI角色:\n${otherCharsPrompt}

# 世界观设定
${worldBooksPrompt || '无特定世界观。'}

# 任务要求
根据“${mainAi.realName}”的人设、与用户的关系、以及世界观，虚构一个包含3到5个聊天的列表。
1.  **必须包含一个与用户“${userProfile.name}”的聊天**。这是最重要的，这条聊天的“最后一条消息”应该能反映出他们当前的关系和最近的互动。
2.  **[严格规则]** 剩下的聊天，你**只能**从上方“其他认识的、可互动的AI角色”列表中选择角色进行私聊或群聊。如果该列表是“无”，则你**不能**生成任何与其他AI的聊天，只能生成与用户的聊天。严禁虚构与不认识的角色的对话。
3.  为每个聊天生成一句能体现对话内容的“最后一条消息预览”。
4.  你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

# 输出JSON格式示例:
[
  {
    "chatId": "pov_chat_user",
    "type": "private",
    "otherParty": { "type": "user", "name": "${userProfile.name}" },
    "lastMessage": "我正在想你刚才说的话..."
  },
  {
    "chatId": "pov_chat_ai_1",
    "type": "private",
    "otherParty": { "type": "ai", "name": "另一个AI的真名" },
    "lastMessage": "关于那个计划，我觉得..."
  },
  {
    "chatId": "pov_chat_group_1",
    "type": "group",
    "groupName": "一个有趣的群名",
    "members": ["AI角色A真名", "AI角色B真名"],
    "lastMessage": "AI角色A真名: 哈哈真的吗？"
  }
]
`;
    return prompt;
}

/**
 * 为AI生成具体“对话内容”的指令
 * @param {object} mainAi - 主视角AI的角色对象
 * @param {object} chatInfo - 被点击的聊天条目的信息
 * @returns {string} - 发给大语言模型的完整指令
 */
function generateAiConversationPrompt(mainAi, chatInfo) {
    let participantsPrompt;
    if (chatInfo.type === 'private') {
        const otherPartyName = chatInfo.otherParty.name;
        const otherPartyObj = (chatInfo.otherParty.type === 'user')
            ? { persona: mainAi.myPersona, realName: otherPartyName }
            : db.characters.find(c => c.realName === otherPartyName);
        
        participantsPrompt = `这是一个你 (${mainAi.realName}) 和 ${otherPartyName} 之间的私聊。
- 你的角色: ${mainAi.realName} (人设: ${mainAi.persona})
- 对方的角色: ${otherPartyName} (人设: ${otherPartyObj ? otherPartyObj.persona : '通用人设'})`;
    } else { // group
        const memberNames = [mainAi.realName, ...chatInfo.members];
        const memberInfos = memberNames.map(name => {
            const char = db.characters.find(c => c.realName === name);
            return `- ${name} (人设: ${char ? char.persona : '通用人设'})`;
        }).join('\n');
        participantsPrompt = `这是一个名为“${chatInfo.groupName}”的群聊。
群成员信息:
${memberInfos}`;
    }

    let prompt = `你是一个AI角色扮演辅助工具。你的任务是根据以下信息，生成一段简短的对话记录。

# 对话背景
${participantsPrompt}
对话主题线索 (最后一条消息): "${chatInfo.lastMessage}"

# 任务要求
1.  生成一段连贯的对话，总消息数**不得超过15条**。
2.  所有角色的发言都必须严格符合他们各自的人设。
3.  对话内容应该与主题线索相关并自然发展。
4.  对话的视角应该是以 **${mainAi.realName}** 为主视角。
5.  你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

# 输出JSON格式示例:
[
  {"sender": "发送者真名", "content": "这是第一条消息。"},
  {"sender": "另一个发送者真名", "content": "这是第二条消息。"}
]
`;
    return prompt;
}
/**
 * [新增的辅助函数] 更智能地从AI返回的文本中提取并解析JSON。
 * @param {string} text - 从AI获取的原始文本回复。
 * @returns {object} - 解析成功后的JavaScript对象或数组。
 * @throws {Error} - 如果在文本中找不到或无法解析有效的JSON，则抛出错误。
 */
function extractAndParseJson(text) {
    // 优先尝试从Markdown代码块中提取JSON
    const codeBlockMatch = text.match(/```(json)?\s*([\s\S]+?)\s*```/);
    if (codeBlockMatch && codeBlockMatch) {
        try {
            return JSON.parse(codeBlockMatch);
        } catch (e) {
            console.warn("无法从Markdown代码块中解析JSON，将尝试后备方法。", e);
        }
    }

    // 后备方法：寻找第一个 '{' 或 '['，并匹配到其对应的 '}' 或 ']'
    const firstBracket = text.indexOf('[');
    const firstBrace = text.indexOf('{');
    let startIndex = -1;

    if (firstBracket === -1 && firstBrace === -1) {
        throw new Error("AI的回复中没有找到JSON对象或数组的起始符号。");
    }

    if (firstBracket === -1) {
        startIndex = firstBrace;
    } else if (firstBrace === -1) {
        startIndex = firstBracket;
    } else {
        startIndex = Math.min(firstBracket, firstBrace);
    }
    
    const startChar = text[startIndex];
    const endChar = startChar === '[' ? ']' : '}';
    
    let nestingLevel = 0;
    let endIndex = -1;

    for (let i = startIndex; i < text.length; i++) {
        if (text[i] === startChar) {
            nestingLevel++;
        } else if (text[i] === endChar) {
            nestingLevel--;
        }

        if (nestingLevel === 0) {
            endIndex = i;
            break;
        }
    }

    if (endIndex === -1) {
        throw new Error("无法在AI回复中找到匹配的JSON结束符号。");
    }

    const jsonString = text.substring(startIndex, endIndex + 1);
    
    try {
        return JSON.parse(jsonString);
    } catch (e) {
        console.error("最终JSON解析失败。提取出的字符串为:", jsonString);
        throw e; 
    }
}
/**
 /**
 * [重写] 设置AI空间应用的所有事件和逻辑
 */
function setupAiPovApp() {
    // 监听“AI角色选择列表”的点击事件
    document.getElementById('ai-character-select-list').addEventListener('click', async (e) => {
        const charItem = e.target.closest('.list-item');
        if (charItem && charItem.dataset.id) {
            currentAiPovId = charItem.dataset.id;
            const character = db.characters.find(c => c.id === currentAiPovId);
            if (!character) return;
            
            switchScreen('ai-chat-list-screen');

            // [新增] 检查缓存
            if (character.povCache && character.povCache.chatList) {
                console.log("从缓存加载AI聊天列表。");
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = character.povCache.chatList;
                currentAiPovData.conversations = character.povCache.conversations || {};
                renderAiChatList(character, character.povCache.chatList);
                return;
            }

            // 如果没有缓存，则生成
            document.getElementById('ai-chat-list-title').textContent = `正在生成 ${character.remarkName} 的聊天...`;
            document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text">请稍候...</p>`;

            try {
                const otherCharacters = db.characters.filter(c => c.id !== currentAiPovId);
                const userProfile = { name: character.myName };
                const prompt = generateAiChatListPrompt(character, otherCharacters, userProfile);

                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const chatList = extractAndParseJson(aiResponseText);

                // 存储AI生成的数据到临时变量和长期缓存
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = chatList;
                currentAiPovData.conversations = {};
                
                character.povCache = {
                    chatList: chatList,
                    conversations: {}
                };
                await saveData();

                renderAiChatList(character, chatList);

            } catch (error) {
                console.error("生成AI聊天列表失败:", error);
                showToast(`生成失败: ${error.message}`);
                document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text" style="color:red;">生成聊天列表失败。</p>`;
            }
        }
    });

    // 监听主屏幕上“AI空间”图标的点击
    document.body.addEventListener('click', e => {
        const icon = e.target.closest('[data-target="ai-character-select-screen"]');
        if (icon) {
            renderAiCharacterSelect();
        }
    });
    
    // 监听“AI的聊天列表”的点击事件
    document.getElementById('ai-chat-list-container').addEventListener('click', async (e) => {
        const chatItem = e.target.closest('.list-item');
        if (chatItem && chatItem.dataset.povChatId) {
            currentAiPovChatId = chatItem.dataset.povChatId;
            const chatInfo = currentAiPovData.chatList.find(c => c.chatId === currentAiPovChatId);
            if (!chatInfo) return;

            // [新增] 特殊处理：如果点击的是与用户的聊天
            if (chatInfo.otherParty && chatInfo.otherParty.type === 'user') {
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.mainAi.history);
                switchScreen('ai-chat-view-screen');
                return;
            }

            // [新增] 检查对话缓存
            if (currentAiPovData.conversations[currentAiPovChatId]) {
                console.log("从缓存加载AI间对话。");
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.conversations[currentAiPovChatId]);
                switchScreen('ai-chat-view-screen');
                return;
            }
            
            // 如果没有缓存，则生成
            switchScreen('ai-chat-view-screen');
            const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c=>c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
            document.getElementById('ai-chat-view-title').textContent = `正在生成与 ${otherPartyName} 的对话...`;
            document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text">请稍候...</p>`;

            try {
                const prompt = generateAiConversationPrompt(currentAiPovData.mainAi, chatInfo);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const conversation = extractAndParseJson(aiResponseText);

               

                // 存储到临时变量和长期缓存，并添加时间戳
const conversationData = {
    history: conversation,
    timestamp: Date.now() // <-- 核心新增：记录当前时间
};
currentAiPovData.conversations[currentAiPovChatId] = conversationData;
const character = db.characters.find(c => c.id === currentAiPovId);
if (character && character.povCache) {
    character.povCache.conversations[currentAiPovChatId] = conversationData;
    await saveData();
}


renderAiPovConversation(currentAiPovData.mainAi, chatInfo, conversation);

            } catch(error) {
                console.error("生成AI对话失败:", error);
                showToast(`生成失败: ${error.message}`);
                document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text" style="color:red;">生成对话失败。</p>`;
            }
        }
    });
}

/**
 * [重写] 渲染AI角色选择列表
 */
function renderAiCharacterSelect() {
    const container = document.getElementById('ai-character-select-list');
    const placeholder = document.getElementById('no-ai-chars-placeholder');
    container.innerHTML = '';
    
    if (!db.characters || db.characters.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        db.characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = char.id;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${char.avatar}" alt="${char.remarkName}" class="chat-avatar">
                <div class="item-details">
                    <div class="item-name">${char.remarkName}</div>
                    <div class="item-preview">查看 ${char.remarkName} 的聊天...</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
    switchScreen('ai-character-select-screen');
}

/**
 * [重写] 渲染由AI生成的聊天列表
 * @param {object} character - 主视角AI角色对象
 * @param {Array} chatList - AI生成的聊天列表数据
 */
function renderAiChatList(character, chatList) {
    document.getElementById('ai-chat-list-title').textContent = `${character.remarkName}的聊天列表`;
    const container = document.getElementById('ai-chat-list-container');
    const placeholder = document.getElementById('no-ai-chats-placeholder');
    container.innerHTML = '';
    
    if (!chatList || chatList.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        chatList.forEach(chat => {
            let avatar = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            let name = '未知';
            if (chat.type === 'private') {
                if (chat.otherParty.type === 'user') {
                    // 尝试从任何一个角色数据中找到用户的头像信息
                    const userChar = db.characters.find(c => c.myName === chat.otherParty.name);
                    avatar = userChar ? userChar.myAvatar : (db.characters[0]?.myAvatar || avatar);
                    name = chat.otherParty.name;
                } else {
                    const otherAi = db.characters.find(c => c.realName === chat.otherParty.name);
                    avatar = otherAi ? otherAi.avatar : avatar;
                    name = otherAi ? otherAi.remarkName : chat.otherParty.name;
                }
            } else { // group
                avatar = 'https://i.postimg.cc/fTLCngk1/image.jpg'; // 默认群头像
                name = chat.groupName;
            }
            
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.povChatId = chat.chatId;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${avatar}" alt="${name}" class="chat-avatar ${chat.type === 'group' ? 'group-avatar' : ''}">
                <div class="item-details">
                    <div class="item-name">${name}</div>
                    <div class="item-preview">${chat.lastMessage}</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
}

/**
 * [重写] 渲染由AI生成的对话内容或真实的用户对话
 * @param {object} mainAi - 主视角AI角色对象
 * @param {object} chatInfo - 被点击的聊天条目的信息
 * @param {Array} conversationHistory - AI生成的对话历史或真实的聊天记录
 */
           function renderAiPovConversation(mainAi, chatInfo, conversationHistory) {
            const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c=>c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
            document.getElementById('ai-chat-view-title').textContent = `与 ${otherPartyName} 的对话`;
            const messageArea = document.getElementById('ai-message-area');
            messageArea.innerHTML = '';

            // 区分真实历史记录和AI生成的模拟对话
            const isRealHistory = conversationHistory.some(msg => msg.role);

            const historyToRender = isRealHistory 
                ? conversationHistory // 如果是真实历史，直接使用
                : conversationHistory.map(msg => ({ // 如果是AI模拟的，转换格式
                    content: msg.content,
                    senderId: msg.sender // AI生成的sender是真名，需要转换
                }));

            historyToRender.forEach(msg => {
                // --- ▼▼▼ 核心修改：复用主聊天界面的渲染逻辑 ---
                // 创建一个临时的消息对象，使其结构与 createMessageBubbleElement 兼容
                const tempMessage = {
                    id: msg.id || `pov_${Date.now()}_${Math.random()}`,
                    content: msg.content,
                    timestamp: msg.timestamp || Date.now(),
                    role: msg.role || (msg.senderId === mainAi.realName ? 'assistant' : 'user'),
                    senderId: msg.senderId
                };
                
                // 借用主渲染函数来创建气泡元素
                const bubbleElement = createMessageBubbleElement(tempMessage);
                
                if (bubbleElement) {
                    // AI空间不需要头像和时间，我们只提取气泡本身
                    const bubble = bubbleElement.querySelector('.message-bubble, .ai-generated-theater, .system-notification-bubble, .image-bubble, .pv-card, .transfer-card, .gift-card, .file-card, .location-card, .music-card');
                    
                    if(bubble) {
                        const wrapper = document.createElement('div');
                        // 判断消息是主AI发的还是对方发的
                        const isSentByMainAi = (isRealHistory && msg.role === 'assistant') || (!isRealHistory && msg.senderId === mainAi.realName);
                        wrapper.className = `message-wrapper ${isSentByMainAi ? 'sent' : 'received'}`;
                        wrapper.style.alignItems = isSentByMainAi ? 'flex-end' : 'flex-start'; // 强制对齐
                        wrapper.style.marginBottom = '10px';
                        
                        // 直接将解析好的气泡放入wrapper
                        wrapper.appendChild(bubble.cloneNode(true));
                        messageArea.appendChild(wrapper);
                    }
                }
                // --- ▲▲▲ 修改结束 ▲▲▲
            });

            setTimeout(() => { messageArea.scrollTop = messageArea.scrollHeight; }, 50);
        }
       
/**
 * [重写] 背景对话生成功能，以确保与AI空间功能解耦
 */
/**
 * [新的辅助函数] 检查两个角色是否可能根据其人设和世界书相互认识。
 * @param {object} charA - 第一个角色对象。
 * @param {object} charB - 第二个角色对象。
 * @returns {boolean} - 如果确认相识则返回 true，否则返回 false。
 */
function charactersAreAcquainted(charA, charB) {
    // 获取两个角色的所有已知名称，用于检查提及。
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // 将人设和所有关联的世界书内容合并为每个角色的单个上下文字符串。
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // 进行双向检查。
    // 角色A的上下文（人设或世界书）是否提及了角色B的名字？
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // 角色B的上下文（人设或世界书）是否提及了角色A的名字？
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // 只要任意一方的上下文中提到了对方，就认为他们相识。
    return aKnowsB || bKnowsA;
}


/**
 * [修订版] 触发并生成两个AI角色之间的后台对话。
 * 该对话只会在两个角色被确认相互认识的情况下发生。
 * @param {object} characterA - 刚刚与用户互动的那个角色。
 */
async function generateBackgroundChat(characterA) {
    // 如果没有足够的角色进行对话，则中止。
    if (currentChatType !== 'private' || db.characters.length < 2) return;

    // 找到用户的最后一条消息，作为对话的触发器。
    const lastUserMessage = characterA.history.findLast(m => m.role === 'user');
    if (!lastUserMessage) return;

    const otherCharacters = db.characters.filter(c => c.id !== characterA.id);

    // --- 核心逻辑变更 ---
    // 筛选潜在的聊天伙伴列表，只保留那些认识 characterA 的角色。
    const potentialPartners = otherCharacters.filter(charB => charactersAreAcquainted(characterA, charB));

    // 如果没有找到认识的角色，则不执行任何操作。
    if (potentialPartners.length === 0) {
        console.log(`[后台聊天] ${characterA.remarkName} 没有认识的伙伴可以聊天。`);
        return;
    }

    // 从认识的角色列表中随机选择一个伙伴。
    const characterB = potentialPartners[Math.floor(Math.random() * potentialPartners.length)];
    // --- 核心逻辑变更结束 ---

    const prompt = `你是一个聊天模拟器。你的任务是根据一个触发事件，在两个AI角色之间生成一段简短、真实的对话。
    
    角色A (对话发起者):
    - 名字: ${characterA.realName}
    - 人设: ${characterA.persona}
    
    角色B (对话接收者):
    - 名字: ${characterB.realName}
    - 人设: ${characterB.persona}

    触发事件 (这是用户刚刚对角色A说的话): "${lastUserMessage.content.replace(/\[.*?的消息：|\]/g, '')}"

    任务:
    1. 角色A主动找角色B，就“触发事件”开始一段对话。
    2. 生成2到4句对话。
    3. 严格保持两个角色的人设。
    4. 你的输出必须是严格的JSON数组格式，像这样: [{"sender": "${characterA.realName}", "content": "第一句话"}, {"sender": "${characterB.realName}", "content": "第二句话"}]
    
    请直接开始生成JSON，不要包含任何额外的解释。`;

    try {
        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        const jsonMatch = aiResponseText.match(/\[[\s\S]*?\]/);
        if (!jsonMatch) {
            console.warn("背景对话生成失败: AI回复中未找到有效的JSON数组。", aiResponseText);
            return;
        }

        const newMessages = JSON.parse(jsonMatch[0]);

        if (!characterA.povChats) characterA.povChats = [];
        
        let povChat = characterA.povChats.find(pc => pc.otherCharId === characterB.id);
        if (!povChat) {
            povChat = {
                id: `pov_${characterA.id}_${characterB.id}`,
                otherCharId: characterB.id,
                history: []
            };
            characterA.povChats.push(povChat);
        }

        povChat.history.push(...newMessages);
        if (povChat.history.length > 20) {
            povChat.history = povChat.history.slice(povChat.history.length - 20);
        }
        
        console.log(`已生成 ${characterA.remarkName} 和 ${characterB.remarkName} 之间的背景对话。`);

    } catch (error) {
        console.error("生成背景对话失败:", error);
    }
}
        init();
    });
</script>





<!-- === ChatGPT 插入：气泡预设脚本 === -->
<script>
(function(){
  if (window._bubblePresetsScriptLoaded) return;
  window._bubblePresetsScriptLoaded = true;

  // localStorage key
  const PRES_KEY = 'bubblePresets';

  function _getBubblePresets() {
    try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
    catch(e){ return []; }
  }
  function _saveBubblePresets(arr) {
    localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
  }

  function populateBubblePresetSelect() {
    const sel = document.getElementById('bubble-preset-select');
    if (!sel) return;
    const presets = _getBubblePresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }
function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}
  async function applyPresetToCurrentChat(presetName) {
    const presets = _getBubblePresets();
    const preset = presets.find(p => p.name === presetName);
    if (!preset) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }
    // 更新界面 textarea
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (textarea) textarea.value = preset.css;

    // 尝试找到当前 chat 对象并写入。如果没有现成的 db 对象，仅更新 preview 和 textarea。
    try {
      if (typeof currentChatId !== 'undefined' && typeof currentChatType !== 'undefined' && window.db) {
        const chat = (currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null);
        if (chat) {
          chat.customBubbleCss = preset.css;
          chat.useCustomBubbleCss = true;
        }
      }
    } catch(e){
      console.warn('applyPresetToCurrentChat: cannot write to db object', e);
    }

    // 更新页面样式预览：优先使用已有的 updateBubbleCssPreview 或 updateCustomBubbleStyle
    try {
      if (typeof updateCustomBubbleStyle === 'function') {
        try { updateCustomBubbleStyle(window.currentChatId || null, preset.css, true); } catch(e){ /* ignore */ }
      }
      const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
      if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, preset.css, false);
      (window.showToast && showToast('预设已应用到当前聊天并保存')) || alert('预设已应用（若页面支持）');
      if (typeof saveData === 'function') {
        try { await saveData(); } catch(e){ /* ignore */ }
      }
    } catch(e){
      console.error('applyPresetToCurrentChat error', e);
    }
  }

  function saveCurrentTextareaAsPreset() {
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (!textarea) return (window.showToast && showToast('找不到自定义 CSS 文本框')) || alert('找不到自定义 CSS 文本框');
    const css = textarea.value.trim();
    if (!css) return (window.showToast && showToast('当前 CSS 为空，无法保存')) || alert('当前 CSS 为空，无法保存');
    let name = prompt('请输入预设名称（将覆盖同名预设）:');
    if (!name) return;
    const presets = _getBubblePresets();
    const idx = presets.findIndex(p => p.name === name);
    if (idx >= 0) presets[idx].css = css;
    else presets.push({name, css});
    _saveBubblePresets(presets);
    populateBubblePresetSelect();
    (window.showToast && showToast('预设已保存')) || alert('预设已保存');
  }

  function openManagePresetsModal() {
    const modal = document.getElementById('bubble-presets-modal');
    const list = document.getElementById('bubble-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getBubblePresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const presetsAll = _getBubblePresets();
        presetsAll[idx].name = newName;
        _saveBubblePresets(presetsAll);
        openManagePresetsModal(); // refresh
        populateBubblePresetSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-danger';
      delBtn.style.padding = '6px 8px;border-radius:8px';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){
        if (!confirm('确定删除预设 \"' + p.name + '\" ?')) return;
        const presetsAll = _getBubblePresets();
        presetsAll.splice(idx, 1);
        _saveBubblePresets(presetsAll);
        openManagePresetsModal();
        populateBubblePresetSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(delBtn);
      row.appendChild(btnWrap);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  function bindBubblePresetUI() {
    populateBubblePresetSelect();
    const sel = document.getElementById('bubble-preset-select');
    const applyBtn = document.getElementById('apply-preset-btn');
    const saveBtn = document.getElementById('save-preset-btn');
    const manageBtn = document.getElementById('manage-presets-btn');
    const modalClose = document.getElementById('close-presets-modal');

    if (sel) {
      sel.addEventListener('change', (e) => {
        const val = e.target.value;
        const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
        if (!val) {
          // restore preview from current chat theme or textarea
          try {
            const chat = (typeof currentChatType !== 'undefined' && typeof currentChatId !== 'undefined' && window.db) ? ((currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null)) : null;
            const baseCss = (chat && chat.customBubbleCss) ? chat.customBubbleCss : (document.getElementById('setting-custom-bubble-css') ? document.getElementById('setting-custom-bubble-css').value : '');
            if (previewBox && typeof updateBubbleCssPreview === 'function') {
              updateBubbleCssPreview(previewBox, baseCss, !chat || !chat.useCustomBubbleCss);
            }
          } catch(e){ /* ignore */ }
          return;
        }
        const presets = _getBubblePresets();
        const p = presets.find(x => x.name === val);
        if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, p ? p.css : '', false);
      });
    }
    if (applyBtn) applyBtn.addEventListener('click', () => {
      const selVal = document.getElementById('bubble-preset-select').value;
      if (!selVal) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设');
      applyPresetToCurrentChat(selVal);
    });
    if (saveBtn) saveBtn.addEventListener('click', saveCurrentTextareaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManagePresetsModal);
    if (modalClose) modalClose.addEventListener('click', () => {
      document.getElementById('bubble-presets-modal').style.display = 'none';
    });
  }

  // 初始化绑定
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } });
  } else {
    setTimeout(() => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } }, 50);
  }
})();
</script>
<!-- === /ChatGPT 插入：气泡预设脚本 === -->





<!-- === ChatGPT 插入：API 预设脚本 === -->
<script>
(function(){
  if (window._apiPresetsScriptLoaded) return;
  window._apiPresetsScriptLoaded = true;

  function _getApiPresets() {
    try { return JSON.parse(localStorage.getItem('apiPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveApiPresets(arr) {
    localStorage.setItem('apiPresets', JSON.stringify(arr || []));
  }

  function populateApiSelect() {
    const sel = document.getElementById('api-preset-select');
    if (!sel) return;
    const presets = _getApiPresets();
    sel.innerHTML = '<option value="">— 选择 API 预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  function saveCurrentApiAsPreset() {
    // Try to gather API settings fields: try to detect common fields like #setting-api-key, #setting-api-url, etc.
    const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
    const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
    const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

    const data = {
      apiKey: apiKeyEl ? apiKeyEl.value : '',
      apiUrl: apiUrlEl ? apiUrlEl.value : '',
      provider: providerEl ? providerEl.value : '',
      // capture whole form as fallback
      raw: {}
    };
    // gather inputs inside same settings container if possible
    const container = apiKeyEl ? apiKeyEl.closest('form,div') : null;
    if (container) {
      const inputs = container.querySelectorAll('input,select,textarea');
      inputs.forEach(i => { try { data.raw[i.name || i.id || i.getAttribute('data-key') || ('f_'+Math.random().toString(36).slice(2))] = i.value; } catch(e){} });
    }
    let name = prompt('为该 API 预设填写名称（会覆盖同名预设）：');
    if (!name) return;
    const presets = _getApiPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = {name: name, data: data};
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveApiPresets(presets);
    populateApiSelect();
    (window.showToast && showToast('API 预设已保存')) || console.log('API 预设已保存');
  }

  async function applyApiPreset(name) {
    const presets = _getApiPresets();
    const p = presets.find(x => x.name === name);
    if (!p) return (window.showToast && showToast('未找到该预设')) || alert('未找到该预设');
    // Try to populate detected fields
    try {
      const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
      const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
      const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

      if (apiKeyEl && p.data && typeof p.data.apiKey !== 'undefined') apiKeyEl.value = p.data.apiKey;
      if (apiUrlEl && p.data && typeof p.data.apiUrl !== 'undefined') apiUrlEl.value = p.data.apiUrl;
      if (providerEl && p.data && typeof p.data.provider !== 'undefined') providerEl.value = p.data.provider;

      // populate raw fields if present
      if (p.data && p.data.raw) {
        for (const k in p.data.raw) {
          try {
            const el = document.querySelector('#'+k+', [name="'+k+'"]');
            if (el) el.value = p.data.raw[k];
          } catch(e){}
        }
      }

      (window.showToast && showToast('已应用 API 预设')) || console.log('已应用 API 预设');
    } catch(e) {
      console.error('applyApiPreset error', e);
    }
  }

  function openApiManageModal() {
    const modal = document.getElementById('api-presets-modal');
    const list = document.getElementById('api-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getApiPresets();
    if (!presets.length) {
      list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    }
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 6px';
      row.style.borderBottom = '1px solid #f6f6f6';

      const left = document.createElement('div');
      left.style.flex = '1';
      left.style.minWidth = '0';
      left.innerHTML = '<div style="font-weight:600;">'+p.name+'</div><div style="font-size:12px;color:#666;margin-top:4px;">' + (p.data && p.data.provider ? ('提供者：'+p.data.provider) : '') + '</div>';

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyApiPreset(p.name); modal.style.display='none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getApiPresets();
        all[idx].name = newName;
        _saveApiPresets(all);
        openApiManageModal();
        populateApiSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){ if(!confirm('确定删除 "'+p.name+'" ?')) return; const all=_getApiPresets(); all.splice(idx,1); _saveApiPresets(all); openApiManageModal(); populateApiSelect(); };

      btns.appendChild(applyBtn); btns.appendChild(renameBtn); btns.appendChild(delBtn);

      row.appendChild(left); row.appendChild(btns);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  // export / import handlers
  function exportApiPresets() {
    const presets = _getApiPresets();
    const blob = new Blob([JSON.stringify(presets, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'api_presets.json'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  function importApiPresets() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'application/json';
    inp.onchange = function(e){
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = function(){ try { const data = JSON.parse(r.result); if (Array.isArray(data)) { _saveApiPresets(data); populateApiSelect(); openApiManageModal(); } else alert('文件格式不正确'); } catch(e){ alert('导入失败：'+e.message); } };
      r.readAsText(f);
    };
    inp.click();
  }

  // bind UI
  function bind() {
    populateApiSelect();
    const saveBtn = document.getElementById('api-save-preset');
    const manageBtn = document.getElementById('api-manage-presets');
    const applyBtn = document.getElementById('api-apply-preset');
    const select = document.getElementById('api-preset-select');
    const modalClose = document.getElementById('api-close-modal');
    const importBtn = document.getElementById('api-import-presets');
    const exportBtn = document.getElementById('api-export-presets');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentApiAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openApiManageModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v=select.value; if(!v) return (window.showToast&&showToast('请选择预设'))||alert('请选择预设'); applyApiPreset(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('api-presets-modal').style.display='none'; });
    if (importBtn) importBtn.addEventListener('click', importApiPresets);
    if (exportBtn) exportBtn.addEventListener('click', exportApiPresets);

    if (select) select.addEventListener('change', function(){ /* optional: preview selection */ });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();
</script>
<!-- === /ChatGPT 插入：API 预设脚本 === -->


<!-- === ChatGPT 插入脚本：我的人设预设逻辑（放到页面脚本块） === -->
<script>
(function(){
  if (window._myPersonaPresetScriptLoaded) return;
  window._myPersonaPresetScriptLoaded = true;

  // 存取 localStorage
  function _getMyPersonaPresets() {
    try { return JSON.parse(localStorage.getItem('myPersonaPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveMyPersonaPresets(arr) {
    localStorage.setItem('myPersonaPresets', JSON.stringify(arr || []));
  }

  // 填充下拉
  function populateMyPersonaSelect() {
    const sel = document.getElementById('mypersona-preset-select');
    if (!sel) return;
    const presets = _getMyPersonaPresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  // 保存当前侧栏（我的人设 + 我的头像）为预设
  function saveCurrentMyPersonaAsPreset() {
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (!personaEl || !avatarEl) return (window.showToast && showToast('找不到我的人设或头像控件')) || alert('找不到我的人设或头像控件');
    const persona = personaEl.value.trim();
    const avatar = avatarEl.src || '';
    if (!persona && !avatar) return (window.showToast && showToast('人设和头像都为空，无法保存')) || alert('人设和头像都为空，无法保存');
    const name = prompt('请输入预设名称（将覆盖同名预设）：');
    if (!name) return;
    const presets = _getMyPersonaPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = { name, persona, avatar };
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveMyPersonaPresets(presets);
    populateMyPersonaSelect();
    (window.showToast && showToast('我的人设预设已保存')) || console.log('我的人设预设已保存');
  }

  // 将预设应用到当前聊天（同时写 UI + db.characters，并保存）
  async function applyMyPersonaPresetToCurrentChat(presetName) {
    const presets = _getMyPersonaPresets();
    const p = presets.find(x => x.name === presetName);
    if (!p) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }

    // 更新界面
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (personaEl) personaEl.value = p.persona || '';
    if (avatarEl) avatarEl.src = p.avatar || '';

    // 尝试写入当前 chat 对象（与气泡预设做法一致）
    try {
      if (typeof currentChatId !== 'undefined' && window.db && Array.isArray(db.characters)) {
        const e = db.characters.find(c => c.id === currentChatId);
        if (e) {
          e.myPersona = p.persona || '';
          e.myAvatar = p.avatar || '';
          if (typeof saveData === 'function') await saveData();
          (window.showToast && showToast('预设已应用并保存到当前聊天')) || console.log('预设已应用');
          // 刷新侧栏与列表以显示更新
          if (typeof loadSettingsToSidebar === 'function') try{ loadSettingsToSidebar(); }catch(e){}
          if (typeof renderChatList === 'function') try{ renderChatList(); }catch(e){}
        }
      } else {
        (window.showToast && showToast('预设已应用到界面（未检测到当前聊天保存入口）')) || console.log('预设已应用到界面');
      }
    } catch(err) {
      console.error('applyMyPersonaPresetToCurrentChat error', err);
    }
  }

  // 管理 Modal
  function openManageMyPersonaModal() {
    const modal = document.getElementById('mypersona-presets-modal');
    const list = document.getElementById('mypersona-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getMyPersonaPresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';

      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyMyPersonaPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getMyPersonaPresets();
        all[idx].name = newName;
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.style.padding = '6px 8px;border-radius:8px;color:#e53935';
      deleteBtn.textContent = '删除';
      deleteBtn.onclick = function(){
        if (!confirm('确认删除该预设？')) return;
        const all = _getMyPersonaPresets();
        all.splice(idx,1);
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(deleteBtn);
      row.appendChild(btnWrap);

      list.appendChild(row);
    });

    modal.style.display = 'flex';
  }

  // 绑定 UI
  function bind() {
    populateMyPersonaSelect();
    const saveBtn = document.getElementById('mypersona-save-btn');
    const manageBtn = document.getElementById('mypersona-manage-btn');
    const applyBtn = document.getElementById('mypersona-apply-btn');
    const select = document.getElementById('mypersona-preset-select');
    const modalClose = document.getElementById('mypersona-close-modal');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentMyPersonaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManageMyPersonaModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v = select.value; if(!v) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设'); applyMyPersonaPresetToCurrentChat(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('mypersona-presets-modal').style.display='none'; });

    // 页面可能在加载后改变侧栏数据，尝试在 DOMContentLoaded 或已有绑定后初始化
    // 当有其他代码重置 sidebar 时，可手动调用 populateMyPersonaSelect()
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);
  

})();
</script>
<!-- === /我的人设预设脚本 === -->
<!-- ================= Moments 页面（动态） ================= -->
<div class="screen" id="moments-screen" style="display:none;">
  <header class="app-header">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container"><h1 class="title">动态</h1></div>
    <div class="action-btn-group">
      <button class="action-btn" id="moments-delete-btn">删除</button>
      <button class="action-btn" id="open-post-modal">发布</button>
    </div>
  </header>
  <main class="content" id="moments-list">

<!-- === BEGIN ICITY-STYLE USER HEADER SNIPPET (inserted by assistant) === -->
<style>
  /* 尽量隔离命名避免冲突 */
  .icity-moments-wrap { width:100%; margin-bottom: 14px; display:flex; justify-content:center; }
  .icity-moments-inner {
    width: calc(100% - 20px);
    max-width: 760px; /* 自适应手机与桌面 */
    position: relative;
  }

  /* 黑色背景 / 顶图 */
  .icity-hero {
    height: 150px;
    background: #000; /* 默认纯黑 */
    border-radius: 14px 14px 0 0;
    overflow: hidden;
    position: relative;
    background-size: cover; /* 恢复：让图片填满容器 */
    background-position: center; /* 保持：让图片居中显示 */
  }

  /* 白色头像圆（位于 hero 底部居中，部分覆盖下方白卡） */
  .icity-avatar-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -46px; /* 头像会覆盖到下方信息卡 */
    width: 110px;
    height: 110px;
    border-radius: 50%;
    background: #fff; /* 默认头像纯白 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    display:flex;
    align-items:center;
    justify-content:center;
    border: 6px solid rgba(255,255,255,0.9);
  }

  .icity-avatar-wrap img { width:80%; height:80%; border-radius:50%; object-fit:cover; display:block; }

  /* 白色信息卡 */
  .icity-info-card {
    background: #fff;
    border-radius: 14px;
    padding: 64px 18px 18px; /* top padding 留出头像区域 */
    box-shadow: 0 6px 18px rgba(0,0,0,0.04);
    margin-top: 10px;
    box-sizing: border-box;
    text-align: center;
  }

  .icity-name {
    font-size: 22px;
    font-weight: 700;
    color: #111;
    margin: 0;
    line-height: 1;
  }

  .icity-id-loc {
    margin-top: 8px;
    display:flex;
    justify-content:center;
    gap:10px;
    align-items:center;
    font-size:13px;
    color:#888;
  }

  .icity-signature {
    margin-top: 12px;
    color:#666;
    font-size:14px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* 小图标（定位标识） */
  .icity-id-loc .dot {
    width:6px; height:6px; border-radius:50%; background:#ddd; display:inline-block; margin-right:6px;
  }

  /* 响应：小屏时适配 */
  @media (max-width:420px) {
    .icity-avatar-wrap { width:90px; height:90px; bottom:-40px; }
    .icity-info-card { padding-top:56px; }
    .icity-name { font-size:20px; }
  }

/* --- 动态多选模式样式 (最终版) --- */
#moments-screen.is-delete-mode .moment-item { 
    cursor: pointer; 
    user-select: none; 
}
.moment-item.is-selected { 
    outline: 2px solid var(--accent-color, #4c9ffe); 
    position: relative; 
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(76, 159, 254, 0.2) !important;
}
.moment-item.is-selected::after {
  content: '✓';
  position: absolute; right: 8px; top: 8px;
  width: 22px; height: 22px; line-height: 22px; text-align: center;
  border-radius: 50%;
  background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
  z-index: 10;
}

/* 底部多选操作栏 */
.multi-select-bar {
  position: fixed; left: 0; right: 0; bottom: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px;
  background: #111; color: #fff;
  transform: translateY(100%); transition: transform .25s ease;
  z-index: 250;
}
.multi-select-bar.show { transform: translateY(0%); }
.multi-select-bar .danger { color: #fff; background: #e5484d; border-radius: 10px; padding: 8px 12px; }
.action-btn-group { display: inline-flex; gap: 8px; align-items: center; }


/* --- Memories Feature Styles --- */
#memories-screen .content,
#memory-detail-screen .content {
    padding: 10px;
}

#memories-list-container .list-item {
    flex-direction: column;
    align-items: flex-start;
}

#memories-list-container .item-name { /* 这是回忆标题 */
    font-size: 16px;
    margin-bottom: 4px;
}

#memories-list-container .item-preview { /* 这是日期 */
    font-size: 12px;
    color: #aaa;
}

#memory-detail-content {
    padding: 20px;
    line-height: 1.7;
}

.memory-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--primary-color);
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}

.memory-main-content {
    font-size: 15px;
    color: var(--text-color);
    margin-bottom: 25px;
    white-space: pre-wrap; /* 保留AI生成内容里的换行 */
}

.memory-commentary {
    background-color: #fff8fa;
    border-left: 4px solid var(--secondary-color);
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 0 8px 8px 0;
    font-style: italic;
    color: #666;
}

.memory-signature {
    text-align: right;
    color: #888;
    font-size: 14px;
}

.memory-signature .ai-name {
    display: block;
    margin-bottom: 5px;
}
  
  /* --- 最终修复：“我的钱包”等页面内容溢出，让其被包裹在手机内部 --- */
#wallet-screen .content,
#forum-screen .content,
#forum-thread-screen .content,
#chat-list-screen .content,
#world-book-screen .content,
#api-settings-screen .content,
#diary-screen .content,
#memories-screen .content,
#ai-character-select-screen .content,
#ai-chat-list-screen .content,
#ai-chat-view-screen .content {
    flex-grow: 1; /* 关键：让内容区占据所有剩余空间 */
    overflow-y: auto; /* 关键：当内容超出时，只滚动内容区本身 */
    height: auto; /* 移除固定的100%高度 */
    min-height: 0; /* flex布局的一个小技巧，防止内容撑破容器 */
}

/* 为钱包和论坛等页面的内容区增加底部内边距，防止被底部导航栏遮挡 */
#wallet-screen .content,
#forum-screen .content,
#forum-thread-screen .content {
    padding-bottom: 80px; 
}
</style>

<div class="icity-moments-wrap" id="icity-moments-wrap">
  <div class="icity-moments-inner" role="region" aria-label="用户动态头部">
    <div class="icity-hero" id="icity-hero"></div>

    <!-- 头像 -->
    <div class="icity-avatar-wrap" id="icity-avatar-wrap" aria-hidden="false">
      <!-- 默认头像：纯白圆（可替换为 dataURL 或真实图片） -->
      <img id="icity-avatar" alt="头像" src="data:image/svg+xml;utf8,
        %3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E
        %3Crect width='100%25' height='100%25' fill='%23ffffff'/%3E
        %3C/svg%3E" />
    </div>

    <!-- 信息白卡 -->
    <div class="icity-info-card">
      <h2 class="icity-name" id="icity-name">Skeleton</h2>

      <div class="icity-id-loc">
        <span class="icity-id">ID：<strong id="icity-id">user</strong></span>
        <span style="opacity:0.4;">·</span>
        <span class="icity-loc"><span class="dot"></span><span id="icity-loc-text">自定义定位</span></span>
      </div>

      <div class="icity-signature" id="icity-signature">把心情写在这里吧♥</div>
    </div>
  </div>
</div>

<script>
  // 初始化默认值（可按需替换为动态数据）
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
      try {
        // 默认文本，遵循你的要求
        const defaults = {
          name: 'Skeleton',
          signature: '把心情写在这里吧♥',
          id: 'user',
          location: '自定义定位',
          avatarSrc: null, // null 使用白色默认图
          heroBg: '#000' // 纯黑背景
        };

        const nameEl = document.getElementById('icity-name');
        const sigEl = document.getElementById('icity-signature');
        const idEl = document.getElementById('icity-id');
        const locEl = document.getElementById('icity-loc-text');
        const avatarEl = document.getElementById('icity-avatar');
        const heroEl = document.getElementById('icity-hero');

        if (nameEl) nameEl.textContent = defaults.name;
        if (sigEl) sigEl.textContent = defaults.signature;
        if (idEl) idEl.textContent = defaults.id;
        if (locEl) locEl.textContent = defaults.location;
        if (heroEl) heroEl.style.background = defaults.heroBg;

        // ---- Profile helpers: load/save/render ----
        window.loadProfileFromStorage = function(){
            return {
                name: localStorage.getItem('myTopName') || defaults.name,
                id: localStorage.getItem('myTopId') || defaults.id,
                location: localStorage.getItem('myTopLoc') || defaults.location,
                signature: localStorage.getItem('myTopSignature') || defaults.signature,
                avatar: localStorage.getItem('myTopAvatar') || (defaults.avatarSrc || ''),
                heroBg: localStorage.getItem('myTopBg') || (defaults.heroBg || '')
            };
        }
        function saveProfileToStorage(profile){
            if(profile.name!=null) localStorage.setItem('myTopName', profile.name);
            if(profile.id!=null) localStorage.setItem('myTopId', profile.id);
            if(profile.location!=null) localStorage.setItem('myTopLoc', profile.location);
            if(profile.signature!=null) localStorage.setItem('myTopSignature', profile.signature);
            if(profile.avatar!=null) localStorage.setItem('myTopAvatar', profile.avatar);
            if(profile.heroBg!=null) localStorage.setItem('myTopBg', profile.heroBg);
        }
        function renderProfileAndSync(){
            const p = loadProfileFromStorage();
            if(nameEl) nameEl.textContent = p.name;
            if(sigEl) sigEl.textContent = p.signature;
            if(idEl) idEl.textContent = p.id;
            if(locEl) locEl.textContent = p.location;
            if(avatarEl){
                if(p.avatar) avatarEl.src = p.avatar;
                // also update global avatar displays
                document.querySelectorAll('.my-avatar, #moments-screen .top-avatar, .top-avatar').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || '';
                    else img.style.backgroundImage = p.avatar? `url('${p.avatar}')` : '';
                });
                // update moment avatars (sync instead of snapshot)
                document.querySelectorAll('.moment-avatar, .post .avatar-img').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || img.src;
                });
            }
            if(heroEl){
                if(p.heroBg){
                    if(p.heroBg.startsWith('http') || p.heroBg.startsWith('data:') || p.heroBg.startsWith('url(')){
                        heroEl.style.backgroundImage = `url('${p.heroBg}')`;
                        heroEl.style.backgroundSize = 'cover';
                        heroEl.style.backgroundPosition = 'center';
                    } else {
                        heroEl.style.background = p.heroBg;
                    }
                } else {
                    heroEl.style.background = defaults.heroBg;
                }
            }
            // If there is a moments renderer, call it to re-render posts with updated profile data
            if(typeof renderMoments === 'function') {
                try{ renderMoments(); }catch(e){}
            } else if(typeof window.renderMomentsSafe === 'function'){
                try{ window.renderMomentsSafe(); }catch(e){}
            }
        }

        // ---- Click handlers per your requirement (separate triggers) ----
        // Clicking hero edits background; clicking avatar edits avatar
        try {
            const bgBtn = document.getElementById('edit-bg-btn');
            const avatarBtn = document.getElementById('edit-avatar-btn');
            if(heroEl) heroEl.addEventListener('click', ()=> { if(bgBtn) bgBtn.click(); });
            if(avatarEl) avatarEl.addEventListener('click', ()=> { if(avatarBtn) avatarBtn.click(); });
        } catch(e){ console.warn('bind bg/avatar click failed', e); }

        // Inline edit helper for text fields (name, id, location, signature)
        function inlineEditText(el, key, placeholder){
            if(!el) return;
            el.style.cursor = 'text';
            el.addEventListener('click', function handler(e){
                e.stopPropagation();
                const old = el.textContent || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = old;
                input.placeholder = placeholder || '';
                input.style.fontSize = window.getComputedStyle(el).fontSize;
                input.style.width = '100%';
                input.style.boxSizing = 'border-box';
                el.replaceWith(input);
                input.focus();
                function commit(){
                    const v = input.value.trim();
                    const profile = loadProfileFromStorage();
                    profile[key] = v;
                    saveProfileToStorage(profile);
                    renderProfileAndSync();
                    input.removeEventListener('blur', onBlur);
                    input.removeEventListener('keydown', onKey);
                }
                function onBlur(){ commit(); input.replaceWith(el); }
                function onKey(ev){ if(ev.key === 'Enter'){ commit(); input.replaceWith(el); } else if(ev.key==='Escape'){ input.replaceWith(el); } }
                input.addEventListener('blur', onBlur);
                input.addEventListener('keydown', onKey);
            }, { once: false });
        }

        inlineEditText(nameEl, 'name', '请输入名称');
        inlineEditText(idEl, 'id', '请输入ID（将作为 authorId）');
        inlineEditText(locEl, 'location', '请输入定位文本');
        inlineEditText(sigEl, 'signature', '请输入个性签名');

        // Initial render from storage
        renderProfileAndSync();

        if (defaults.avatarSrc) {
          avatarEl.src = defaults.avatarSrc;
        }

        // 头像点击事件占位
        const wrap = document.getElementById('icity-avatar-wrap');
        if (wrap) {
          wrap.addEventListener('click', function(){
            console.log('icity avatar clicked');
          });
        }

      } catch (e) {
        console.warn('icity header init error', e);
      }
    });
  })();
</script>
<!-- === END ICITY-STYLE USER HEADER SNIPPET === -->

    <p class="placeholder-text" id="moments-empty">还没有动态，点击右上角发布吧~</p>
    <div id="moments-container"></div>
  </main>
</div>

<!-- 发布动态模态框 -->
<div class="modal-overlay" id="post-modal" style="display:none;">
  <div class="modal-window">
    <h3>发布动态</h3>
    <form id="post-form">
      <div class="form-group">
        <label>动态内容</label>
        <textarea id="post-text" placeholder="说点什么..." required rows="4"></textarea>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="add-image"> 添加图片</label>
      </div>
      <div class="form-group" id="image-input-group" style="display:none;">
  <label>图片描述</label>
  <input type="text" id="image-description" placeholder="描述图片内容（如：海边日落）">
</div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn btn-secondary" type="button" id="cancel-post-btn">取消</button>
        <button class="btn btn-primary" type="submit">发布</button>
      </div>
    </form>
  </div>
</div>

<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<style>
  #moments-multi-select-bar { display: none !important; }
  /* 微调底部导航样式（不会影响你原有 .dock） */
  .bottom-nav {
    position: absolute;
    left: 0;
    right: 0;
    height: 68px;
    display: flex;
    gap: 6px;
    align-items: center;
    justify-content: center;
    padding: 10px 14px;
    box-sizing: border-box;
    background: rgba(255,255,255,0.85);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: 0 -6px 20px rgba(0,0,0,0.06);
    z-index: 50;
    bottom: 0;
  }
  .bottom-nav .nav-btn {
    flex: 1;
    height: 48px;
    border-radius: 12px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--text-color, #444);
  }
  .bottom-nav .nav-btn.active {
    background: var(--primary-color, #ff80ab);
    color: #fff;
    box-shadow: 0 6px 16px rgba(255,128,171,0.22);
  }

  /* moments 列表项 */
  .moment-item {
    background: #fff;
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.03);
  }
  .moment-head { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
  .moment-avatar { width:44px; height:44px; border-radius:50%; object-fit:cover; background:#eee; flex-shrink:0; }
  .moment-meta { font-size:13px; }
  .moment-text { margin:8px 0; white-space:pre-wrap; color:var(--text-color,#333); }
  .moment-image { width:100%; max-height:260px; object-fit:cover; border-radius:10px; margin-top:8px; }
  .moment-comments { margin-top:10px; padding-top:8px; border-top:1px solid #faf0f4; color:#666; font-size:13px; }
  .moment-comment { margin-bottom:6px; }

  /* --- 新增：动态操作栏 (点赞/评论) --- */
  .moment-actions {
    display: flex;
    gap: 12px;
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #f5f5f5;
  }
  .moment-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: #888;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
  }
  .moment-action-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }
  .moment-action-btn.liked {
    color: var(--primary-color);
  }

  /* --- 新增：点赞列表显示 --- */
  .moment-likes {
    background-color: #f9f9f9;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    margin-top: 8px;
    display: none; /* 默认隐藏 */
  }
  .moment-likes.visible {
    display: block;
  }
  .moment-likes .like-icon {
    color: var(--primary-color);
    margin-right: 4px;
  }

  /* --- 新增：用户评论输入区域 --- */
  .moment-comment-input-area {
    display: none; /* Default hidden */
    gap: 8px;
    margin-top: 10px;
  }
  .moment-comment-input-area.visible {
    display: flex;
  }
  .moment-comment-input {
    flex-grow: 1;
    border: 1px solid #eee;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
  }
  .moment-comment-input:focus {
    outline: none;
    border-color: var(--primary-color);
  }
  .post-comment-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    cursor: pointer;
    flex-shrink: 0;
  }



  /* --- 在 <style> 标签内添加 --- */
.message-bubble .quoted-content {
    /* --- 在这里调整引用块的大小和样式 --- */
    --quote-font-size: 0.6em;       /* 引用文字大小 (em是相对于气泡文字大小的单位) */
    --quote-padding: 4px 6px;      /* 引用块的内边距 (上下 左右) */
    --quote-bottom-margin: 5px;     /* 引用块与下方回复文字的间距 */
    --quote-border-thickness: 2px;  /* 左侧引用竖线的粗细 */
    /* --- 调整结束 --- */

    font-size: var(--quote-font-size);
    padding: var(--quote-padding);
    margin-bottom: var(--quote-bottom-margin);
    border-left: var(--quote-border-thickness) solid var(--accent-color);
    
    background-color: rgba(0,0,0,0.05);
    border-radius: 8px;
    color: #555;
    word-wrap: break-word;
    white-space: pre-wrap;
}

.message-bubble .quoted-content .quoted-text {
    opacity: 0.8;
}
.message-bubble .reply-text {
    margin-top: 5px;
}
  /* --- 论坛“+”号发帖按钮美化与定位 --- */
.new-post-btn {
    position: absolute; /* 使用绝对定位，让它浮动起来 */
    bottom: 80px;       /* 距离底部20像素 */
    right: 20px;        /* 距离右侧20像素 */
    
    /* 以下是美化样式 */
    width: 60px;
    height: 60px;
    border-radius: 50%; /* 变成圆形 */
    background-color: var(--primary-color); /* 使用主题粉色 */
    color: white;
    font-size: 36px;
    font-weight: 300; /* 让“+”号细一点，更好看 */
    line-height: 60px; /* 垂直居中“+”号 */
    text-align: center; /* 水平居中“+”号 */
    box-shadow: 0 4px 15px rgba(255,128,171,0.4); /* 添加漂亮的粉色阴影 */
    cursor: pointer;
    z-index: 100; /* 确保它在帖子列表的上方 */
    transition: transform 0.2s ease; /* 添加一个小的交互动画 */
}

/* 鼠标悬停时，按钮稍微放大一点点 */
.new-post-btn:hover {
    transform: scale(1.1);
}

/* --- 支付密码开关Toggle Switch样式 --- */
.form-group.toggle-group {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
}
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.toggle-switch .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 28px;
}
.toggle-switch .slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}
input:checked + .slider {
    background-color: var(--primary-color);
}
input:checked + .slider:before {
    transform: translateX(22px);
}
  
/* --- 在 <style> 标签末尾添加 --- */

/* --- 论坛功能最终布局和样式 (严格参考已有范例) --- */

/* 核心：让内容区正确填充，并居中版块按钮 */
#forum-screen .content {
    height: auto !important;
    flex-grow: 1 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 20px !important;
    position: relative;
    overflow: hidden; /* 防止动画元素溢出 */
}

/* 顶部导航栏下拉菜单触发器 */
#forum-screen .forum-header {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
}
#forum-screen .forum-header h1 {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
    color: var(--text-color);
}
#forum-screen .forum-header .dropdown-arrow {
    width: 24px;
    height: 24px;
    fill: var(--text-color);
    margin-left: 5px;
    transition: transform 0.2s ease;
}
#forum-screen .forum-header.open .dropdown-arrow {
    transform: rotate(180deg);
}

/* 下拉菜单本体 */
.forum-dropdown-menu {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    z-index: 200;
    display: none;
}
.forum-dropdown-menu.visible {
    display: block;
}
.forum-dropdown-item {
    padding: 15px 20px;
    font-size: 16px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
}
.forum-dropdown-item:last-child {
    border-bottom: none;
}
.forum-dropdown-item:hover {
    background-color: #fce4ec;
}

/* 动画效果 */
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* 四个版块的格子布局 */
.forum-board-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    width: 100%;
}

/* 版块卡片美化 */
.forum-board-card {
    background: linear-gradient(145deg, #ffffff, #fff0f5);
    border-radius: 24px;
    padding: 20px;
    box-shadow: 0 8px 25px rgba(255, 128, 171, 0.1);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    opacity: 0;
    animation: fadeInUp 0.5s ease forwards;
}
.forum-board-card:nth-child(1) { animation-delay: 0.1s; }
.forum-board-card:nth-child(2) { animation-delay: 0.2s; }
.forum-board-card:nth-child(3) { animation-delay: 0.3s; }
.forum-board-card:nth-child(4) { animation-delay: 0.4s; }
.forum-board-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 12px 30px rgba(255, 128, 171, 0.2);
}
.forum-board-card img {
    width: 48px;
    height: 48px;
    object-fit: contain;
}
.forum-board-card .board-name {
    font-size: 16px;
    font-weight: 600;
    color: var(--secondary-color);
}
  
.notification-banner {
    position: absolute;
    top: 45px; /* 根据你的header高度微调 */
    left: 50%;
    transform: translateX(-50%) translateY(-200%);
    width: 90%;
    max-width: 380px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    padding: 10px;
    z-index: 999;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
}

.notification-banner.show {
    transform: translateX(-50%) translateY(0);
}

.notification-banner img {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    margin-right: 10px;
    object-fit: cover;
    flex-shrink: 0;
}

.notification-banner #notification-text {
    flex-grow: 1;
    font-size: 14px;
    color: #333;
    line-height: 1.4;
}

.notification-banner button {
    background: none;
    border: none;
    font-size: 24px;
    color: #aaa;
    cursor: pointer;
    padding: 0 5px;
}
  /* --- 论坛发帖弹窗美化 --- */
#new-post-modal .modal-window {
    background: #fff8fa; /* 淡粉色背景 */
    border: 1px solid #fce4ec;
}
#new-post-modal h3 {
    color: var(--primary-color);
    text-align: center;
}
#new-post-modal .form-group label {
    color: var(--secondary-color);
    font-weight: 600;
    font-size: 14px;
}
#new-post-modal .form-group input[type="text"],
#new-post-modal .form-group textarea {
    background-color: #fff;
    border: 2px solid #fde9f2;
    border-radius: 12px;
    padding: 12px;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#new-post-modal .form-group input[type="text"]:focus,
#new-post-modal .form-group textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 8px rgba(255, 128, 171, 0.2);
    outline: none;
}
#new-post-modal .form-group input[type="checkbox"] {
    accent-color: var(--primary-color); /* 让勾选框也变成粉色 */
    transform: scale(1.2); /* 稍微放大一点点 */
    cursor: pointer;
}


  /* --- 论坛帖子列表与详情页美化 --- */

/* 帖子列表项的整体样式 */
.thread-list-item {
    background-color: #fff;
    border-radius: 16px;
    padding: 18px;
    margin-bottom: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    border: 1px solid #f0f0f0;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.thread-list-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
}
.thread-list-item.pinned {
    background-color: #fffafc;
    border-left: 4px solid var(--primary-color);
}
/* 帖子标题 */
.thread-title {
    font-weight: bold;
    font-size: 17px;
    margin-bottom: 12px;
    color: #333;
    display: flex;
    align-items: center;
}
.thread-title .hot-icon { font-size: 18px; margin-right: 5px; }

/* 作者、点赞等元信息 */
.thread-meta {
    font-size: 13px;
    color: #999;
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f5f5f5;
}
.thread-meta .author {
    color: #5c7e9f;
    font-weight: bold;
}
.thread-meta .likes {
    color: var(--primary-color);
    font-weight: bold;
}

/* 评论预览区 */
.thread-comment-preview {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
}
.thread-comment-preview .comment { margin-bottom: 8px; }
.thread-comment-preview .comment:last-child { margin-bottom: 0; }
.thread-comment-preview .comment-author {
    font-weight: bold;
    color: #444;
    margin-right: 5px;
}

/* --- 帖子详情页美化 --- */
.thread-full-content {
    padding: 20px;
}
.thread-full-content h2 { /* 详情页标题 */
    font-size: 22px;
    font-weight: 700;
    color: #333;
    margin: 0 0 10px 0;
}
.thread-full-content .author-line { /* 作者信息行 */
    font-size: 14px;
    color: #888;
    margin: 0 0 20px 0;
}
.thread-full-content .main-post-body { /* 帖子正文 */
    font-size: 16px;
    line-height: 1.8;
    color: #444;
}
.comments-section {
    padding: 0 20px 20px 20px;
}
.comments-section h3 { /* “评论区”标题 */
    font-size: 18px;
    font-weight: 600;
    color: var(--secondary-color);
    padding-bottom: 10px;
    border-bottom: 2px solid #fce4ec;
    margin-bottom: 15px;
}
.thread-comment {
    border-bottom: 1px solid #f5f5f5;
    padding: 15px 0;
}
.thread-comment:last-child {
    border-bottom: none;
}
.thread-reply { /* 楼中楼回复 */
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    margin-top: 10px;
    margin-left: 20px;
    font-size: 14px;
}

/* --- 论坛内容区域防遮挡修复 --- */
#forum-screen .thread-list-container,
#forum-thread-screen .content {
    /* 增加一个足够高的底部内边距，为导航栏留出空间 */
    padding-bottom: 80px; 
}
/* --- 视频通话功能样式 (最终修正版) --- */
.sticker-bar-btn#voice-call-btn {
    display: none;
}

#voice-call-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 300;
    display: none;
    flex-direction: column;
    align-items: center;
    color: white;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    animation: fadeIn 0.3s ease;
}

#voice-call-overlay.visible {
    display: flex;
}

.call-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 15px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    margin-top: 40px; 
    flex-shrink: 0;
}

.call-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.call-status {
    font-size: 16px;
    color: #ccc;
    min-height: 24px;
    margin-bottom: 15px;
    flex-shrink: 0;
}

/* 聊天记录区域的核心修复 */
#call-transcript-area {
    flex: 1; /* 关键：让此区域自动伸展并占据所有剩余空间 */
    width: 100%;
    overflow-y: auto; /* 内容多时可以滚动 */
    min-height: 0; /* flex布局的关键技巧，防止内容溢出 */
    padding: 10px;
    font-size: 15px;
    line-height: 1.7;
    text-align: left;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.call-transcript-line {
    margin-bottom: 12px;
}
.call-transcript-line .action {
    color: #aaa;
    font-style: italic;
}
.call-transcript-line .dialog {
    color: #fff;
}

/* 底部输入框和按钮 */
#call-input-area {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0 0 0; /* 只保留上边距 */
    width: 100%;
    flex-shrink: 0;
}
#call-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
#call-input::placeholder {
    color: #ccc;
}
#send-call-message-btn {
    background: var(--primary-color);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    color: white;
    font-size: 18px;
    flex-shrink: 0;
}

/* 通话按钮组 */
.call-button-group {
    position: absolute;
    bottom: 80px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    background: none;
    border: none;
    color: white;
}
.call-button .icon-wrapper {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}
.call-button svg {
    width: 36px;
    height: 36px;
    fill: white;
}
.call-button.decline .icon-wrapper {
    background-color: #ef5350;
}
.call-button.accept .icon-wrapper {
    background-color: #4CAF50;
}
/* 将挂断按钮也放入这个组，但由JS控制显隐 */
#hangup-button-container {
    position: static;
    padding: 10px 0;
    flex-shrink: 0;
}
/* --- 在 <style> 标签末尾添加 --- */



  
.mention-panel {
    position: absolute;
    background: white;
    border: 1px solid #eee;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    max-height: 150px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
}
.mention-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.mention-item:hover {
    background-color: #f5f5f5;
}
.mention-item img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
}

/* --- AI轨迹弹窗样式 --- */
#trajectory-modal {
    z-index: 105; /* 确保它在其他元素之上 */
}

#trajectory-modal .modal-window {
    width: 90%;
    max-width: 380px;
    padding: 20px;
}

#trajectory-timeline {
    max-height: 60vh;
    overflow-y: auto;
    padding-right: 15px; /* 为滚动条留出空间 */
    position: relative;
    border-left: 2px solid #fce4ec; /* 时间轴的竖线 */
    margin-left: 25px;
}

.trajectory-item {
    position: relative;
    padding: 10px 0 15px 25px;
}

.trajectory-item::before {
    content: '';
    position: absolute;
    left: -7px; /* (12px / 2) + 2px border */
    top: 12px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--primary-color);
    border: 2px solid #fff;
    z-index: 1;
}

.trajectory-time {
    font-weight: bold;
    color: var(--primary-color);
    font-size: 16px;
    display: block;
    margin-bottom: 5px;
}

.trajectory-event {
    font-size: 14px;
    color: var(--text-color);
    line-height: 1.5;
}
/* --- 时间日期小部件样式修改 --- */

/* 1. 将小部件容器改为绝对定位，放置在屏幕顶部，并使用flex布局 */
.time-widget {
    position: absolute;
    top: 0px;  /* 距离屏幕顶部的间距 */
    left: 0;
    width: 100%;
    padding: 0 20px; /* 左右两边的间距 */
    
    /* 核心改动：使用flex布局实现左右对齐 */
    display: flex;
    justify-content: space-between; 
    align-items: center;
    
    text-align: unset; /* 取消原有的居中对齐 */
    color: var(--text-color); /* 为日期和时间设置统一的默认颜色 */
}

/* 2. 统一修改日期和时间的字体样式 */
.time-widget .date,
.time-widget .time {
    font-size: 11px;      /* 缩小字体大小 */
    font-weight: 500;     /* 统一字体粗细为中等 */
    color: inherit;       /* 继承来自父容器 .time-widget 的颜色 */
}

/* 3. 确保日间模式下的颜色依然生效 */
#home-screen.day-mode .time-widget {
    color: var(--white-color); /* 日间模式统一使用白色 */
}
/* --- 最终版主屏幕布局样式 --- */

/* 1. 整体屏幕和内容区设定 */
#home-screen {
    justify-content: flex-start; /* 内容从顶部开始排列 */
    padding-top: 50px; /* 增加顶部内边距，为时间日期小部件留出空间 */
}

#home-screen .main-content-area {
    display: flex;
    width: 100%; /* 宽度占满，以便左右对齐 */
    justify-content: space-between; /* 核心：将左右两列推向屏幕边缘 */
    align-items: flex-start;
    padding: 0 40px; /* 屏幕左右留出边距 */
    margin-top: 20px; /* 与上方元素的间距 */
}

/* 2. 左右两列的容器 */
.left-column, .right-column {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 列内元素的垂直间距 */
}

/* 3. 左侧联系人组件样式（进一步缩小） */
.contact-widgets-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.contact-widget {
    background-color: #f5f5f5;
    border-radius: 50px;
    padding: 5px 12px 5px 5px; /* 缩小内边距 */
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 160px; /* 缩小宽度 */
    box-shadow: none; /* 移除阴影，更简洁 */
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.contact-widget:hover {
    background-color: #e9e9e9;
}
.contact-widget img {
    width: 40px; /* 缩小头像 */
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}
.contact-widget span {
    font-weight: 500;
    color: #444;
    font-size: 13px; /* 缩小字体 */
}
.contact-widget.avatar-right {
    flex-direction: row-reverse;
    padding: 5px 5px 5px 12px;
}

/* 4. 左侧下方的“自定义”和“壁纸”容器（改为横向排列） */
.secondary-apps-dock {
    display: flex;
    justify-content: center; /* 图标居中排列 */
    gap: 15px; /* 图标间距 */
    padding: 8px;
    border-radius: 18px;
}

/* 5. 右侧2x2应用网格（缩小尺寸） */
.small-app-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
}
.small-app-grid .app-icon .icon-img,
.secondary-apps-dock .app-icon .icon-img {
    width: 50px; /* 统一缩小图标尺寸 */
    height: 50px;
    border-radius: 11px;
    margin-bottom: 4px;
}
.small-app-grid .app-icon .app-name,
.secondary-apps-dock .app-icon .app-name {
    font-size: 10px; /* 统一缩小文字大小 */
}

/* 6. 音乐播放器新位置和尺寸 */
.record-player-widget {
    --music-widget-scale: 1.2; /* 再次缩小组件 */
    margin: 0 auto; /* 移除上下外边距，由父容器gap控制 */
    width: 100%; /* 宽度与父容器（右列）对齐 */
    max-width: calc(130px * var(--music-widget-scale));
    height: calc(100px * var(--music-widget-scale));
}
.record-player-widget .vinyl-record {
    right: -12%;
}

/* 7. 底部Dock栏调整 */
.dock {
    margin: 60px 20px 10px; /* 上 左右 下 的间距 */
}

/* 8. 确保旧的布局规则被禁用 */
#home-screen .top-row, 
#home-screen .bottom-row,
#home-screen .app-grid,
#home-screen .decorative-component {
    display: none !important;
}

</style>


<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<div id="bottom-nav-host" data-managed-by="injection" style="display:none;">
  <div class="bottom-nav" id="bottom-nav">
    <button class="nav-btn active" data-target="chat-list-screen">聊天</button>
    <button class="nav-btn" data-target="moments-screen">动态</button>
    <button class="nav-btn" data-target="forum-screen">论坛</button>
    <button class="nav-btn" data-target="wallet-screen">我</button>
  </div>
</div>

<script>
(function() {
  // 等 DOM 完全加载
  document.addEventListener('DOMContentLoaded', () => {
    // --- 全局辅助函数 ---
    window.getAuthorNameById = function(authorId) {
        if (!authorId) return '未知';
        // 优先从顶栏信息获取自己的名字
        if (typeof loadProfileFromStorage === 'function') {
            const myProfile = loadProfileFromStorage();
            if (myProfile && myProfile.id === authorId) {
                return myProfile.name || '我';
            }
        }
        // 从全局 db 对象查找
        if (window.db) { // This now refers to the main data object, not Dexie.
            if (window.db.characters) {
                const character = window.db.characters.find(c => c.id === authorId);
                if (character) return character.remarkName;
            }
            if (window.db.groups) {
                for (const group of window.db.groups) {
                    if (group.members) {
                        const member = group.members.find(m => m.id === authorId);
                        if (member) return member.groupNickname;
                    }
                }
            }
        }
        // Fallback
        return authorId.startsWith('char_') ? '某角色' : authorId;
    };

    // --- 简单工具函数 ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function escapeText(t) { return String(t == null ? '' : t); }

    // 1) 初始化 Dexie（使用页面已引入的 Dexie）
    let db;
    try {
      db = new Dexie('AppDB_Moments');
      db.version(1).stores({
        moments: 'id,timestamp,commentedBy' // comments 和 likes 存在于对象内
      });
      // expose to window so external scripts can access the Dexie instance
      try{ window.AppDB_Moments = db; }catch(e){}

    } catch (e) {
      console.error('Dexie init failed', e);
      showToast('本地数据库初始化失败，动态功能受限');
      return;
    }
    // 2) DOM 元素
    const openPostBtn = $('#open-post-modal');
    const postModal = $('#post-modal');
    const postForm = $('#post-form');
    const addImageCheckbox = $('#add-image');
    const imageInputGroup = $('#image-input-group');
    const postImageInput = $('#post-image');
    const imageDescInput = $('#image-description');
    const postImagePreview = $('#post-image-preview');
    const cancelPostBtn = $('#cancel-post-btn');
    const momentsContainer = $('#moments-container');
    const momentsEmpty = $('#moments-empty');
    const momentsScreen = $('#moments-screen');
    const bottomNavHost = document.getElementById('bottom-nav-host');
if (typeof setupMentions === 'function') {
        try {
            setupMentions();
        } catch (e) {
            console.error("在动态模块中初始化提及功能失败:", e);
        }
    }
    // 3) 绑定打开/关闭发布模态
    if (openPostBtn) openPostBtn.addEventListener('click', () => {
      postModal.style.display = 'flex';
      postModal.classList.add('visible');
    });
    if (cancelPostBtn) cancelPostBtn.addEventListener('click', closePostModal);
    function closePostModal() {
      postModal.style.display = 'none';
      postModal.classList.remove('visible');
      postForm.reset();
      // 清理图片预览与文件输入，避免残留 dataURL 或页面 URL 导致后续发布异常
      try { postImagePreview.src = ''; } catch(e){}
      try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){}
      postImagePreview.style.display = 'none';
      imageInputGroup.style.display = 'none';
    }

    addImageCheckbox.addEventListener('change', e => {
      // 如果取消添加图片，清理之前的预览和文件输入
      if (!addImageCheckbox.checked) { try { postImagePreview.src = ''; } catch(e){} try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){} }

      imageInputGroup.style.display = e.target.checked ? 'block' : 'none';
    });

    

    async function fileToDataURLAndCompress(file, maxWidth = 1200, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if (w > maxWidth) {
              nw = maxWidth;
              nh = Math.round(h * (maxWidth / w));
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw;
            canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            const out = canvas.toDataURL('image/jpeg', quality);
            resolve(out);
          };
          img.onerror = reject;
          img.src = ev.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 4) 发布动态（写入 Dexie）
    

// --- Safe addMoment helper (injected by assistant) ---
async function addMomentToDB(momentObj) {
  // 1) Prefer global Dexie instance AppDB_Moments if available
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.add === 'function') {
      return window.AppDB_Moments.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 2) If window.db.moments looks like Dexie, use it
  try {
    if (window.db && window.db.moments && typeof window.db.moments.add === 'function') {
      return window.db.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 3) Fallback to in-memory array and try to persist via saveData()
  if (!window.db) window.db = {};
  if (!Array.isArray(window.db.moments)) window.db.moments = [];
  window.db.moments.push(momentObj);

  if (typeof window.saveData === 'function') {
    try { await window.saveData(); } catch(e){ console.warn('saveData fallback failed', e); }
  }

  // 4) Try to mirror into AppDB_Moments (put to avoid duplicate key issues)
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.put === 'function') {
      await window.AppDB_Moments.moments.put(momentObj);
    }
  } catch(e){ console.warn('mirror to AppDB_Moments failed', e); }

  return Promise.resolve();
}

// --- Replaced postForm submit handler (injected by assistant) ---
postForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const submitBtn = postForm.querySelector('button[type=\"submit\"]');
  if (submitBtn) submitBtn.disabled = true;

  // adapt these IDs to match your form inputs if they differ
  const textEl = document.getElementById('post-text');
  const addImageEl = document.getElementById('add-image');
  const imageDescEl = document.getElementById('image-description');

  const text = textEl ? textEl.value.trim() : '';
  const addImage = addImageEl ? addImageEl.checked : false;
  const imageDesc = imageDescEl ? imageDescEl.value.trim() : '';

  if (!text && !addImage) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入动态内容');
    return;
  }

  if (addImage && !imageDesc) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入图片描述');
    return;
  }

  const id = 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
  const momentObj = {
    id,
    authorId: (localStorage.getItem('myTopId') || 'user'),
    authorAvatar: (localStorage.getItem('myTopAvatar') || null),
    text,
    imageDesc: addImage ? imageDesc : '',
    timestamp: Date.now(),
    commentedBy: [],
    comments: [],
    likes: []
  };

  try {
    await addMomentToDB(momentObj);

    if (typeof showToast === 'function') showToast('发布成功');
    try { if (typeof closePostModal === 'function') closePostModal(); } catch(e){}

    // Force immediate re-render of moments
    if (typeof renderMoments === 'function') {
      try { await renderMoments(); } catch(e){ console.warn('renderMoments failed', e); }
    } else if (typeof window.renderMomentsSafe === 'function') {
      try { await window.renderMomentsSafe(); } catch(e){ console.warn('renderMomentsSafe failed', e); }
    } else {
      // last resort: toggle screen class to force repaint
      const ms = document.getElementById('moments-screen');
      if (ms) {
        ms.classList.remove('active');
        setTimeout(()=>ms.classList.add('active'), 10);
      }
    }
  } catch (e) {
    console.error('add moment err', e);
    if (typeof showToast === 'function') showToast('保存失败: ' + (e && e.message ? e.message : String(e)));
  } finally {
    if (submitBtn) submitBtn.disabled = false;
  }
});



    // 5) 渲染动态列表
    async function renderMoments() {
  const list = await db.moments.orderBy('timestamp').reverse().toArray();
  const momentsContainer = document.getElementById('moments-container');
  const momentsEmpty = document.getElementById('moments-empty');

  if (!momentsContainer) {
      console.error("Fatal Error: #moments-container element not found.");
      return;
  }

  momentsContainer.innerHTML = '';

  if (!list.length) {
    if (momentsEmpty) momentsEmpty.style.display = 'block';
    return;
  } else {
    if (momentsEmpty) momentsEmpty.style.display = 'none';
  }

  const myProfile = loadProfileFromStorage();
  const myId = myProfile.id || 'user';

  list.forEach(m => {
    const div = document.createElement('div');
    div.className = 'moment-item';
    div.dataset.id = m.id || (m.id = ('m_' + Date.now() + Math.random()));

    const head = document.createElement('div');
    head.className = 'moment-head';
    const avatar = document.createElement('img');
    avatar.className = 'moment-avatar';
    avatar.src = m.authorAvatar || 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23e9f5ff%22/%3E%3Ccircle%20cx%3D%2232%22%20cy%3D%2224%22%20r%3D%2212%22%20fill%3D%22%237fb3ff%22/%3E%3Crect%20x%3D%228%22%20y%3D%2240%22%20width%3D%2248%22%20height%3D%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
    const meta = document.createElement('div');
    meta.className = 'moment-meta';
    const name = document.createElement('div');
    name.style.fontWeight = '700';
    name.textContent = window.getAuthorNameById(m.authorId) || m.author || '我';
    const time = document.createElement('div');
    time.style.fontSize = '12px';
    time.style.color = '#999';
    try {
      time.textContent = new Date(m.timestamp).toLocaleString();
    } catch (e) {
      time.textContent = '';
    }
    meta.appendChild(name);
    meta.appendChild(time);
    head.appendChild(avatar);
    head.appendChild(meta);
    div.appendChild(head);

    const txt = document.createElement('div');
    txt.className = 'moment-text';
    txt.textContent = m.text || '';
    div.appendChild(txt);

    if (m.imageData && m.imageData.length > 10) {
      const im = document.createElement('img');
      im.className = 'moment-image';
      im.src = m.imageData;
      im.alt = m.imageDesc || m.text || '动态图片';
      div.appendChild(im);
    } else if (m.imageDesc) {
      const descCard = document.createElement('div');
      descCard.className = 'moment-image-desc-card';
      const descContent = document.createElement('p');
      descContent.className = 'desc-content';
      descContent.textContent = m.imageDesc;
      descCard.appendChild(descContent);
      div.appendChild(descCard);
    }

    const actions = document.createElement('div');
    actions.className = 'moment-actions';
    const likeBtn = document.createElement('button');
    likeBtn.className = 'moment-action-btn';
    const likes = m.likes || [];
    if (likes.includes(myId)) {
      likeBtn.classList.add('liked');
    }
    likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
    likeBtn.addEventListener('click', async (event) => {
      const btn = event.currentTarget;
      const momentItem = btn.closest('.moment-item');
      const currentLikes = m.likes || [];
      const myIdx = currentLikes.indexOf(myId);
      if (myIdx > -1) {
        currentLikes.splice(myIdx, 1);
        btn.classList.remove('liked');
      } else {
        currentLikes.push(myId);
        btn.classList.add('liked');
      }
      m.likes = currentLikes;
      await db.moments.put(m);
      btn.querySelector('span').textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
      const likesWrap = momentItem.querySelector('.moment-likes');
      if (likesWrap) {
        if (currentLikes.length > 0) {
          const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
          likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
          likesWrap.classList.add('visible');
        } else {
          likesWrap.classList.remove('visible');
        }
      }
    });
    const commentBtn = document.createElement('button');
    commentBtn.className = 'moment-action-btn';
    commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
    // *** 修改：评论按钮点击逻辑 ***
    commentBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const momentItem = event.currentTarget.closest('.moment-item');
        if (momentItem) {
            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            if (inputArea) {
                inputArea.classList.toggle('visible');
                const input = inputArea.querySelector('input');
                const postBtn = inputArea.querySelector('button');
                // 重置为对动态的直接评论
                input.placeholder = '添加评论...';
                delete postBtn.dataset.replyToCommentId;
                delete postBtn.dataset.replyToAuthorName;
                if (inputArea.classList.contains('visible')) {
                    input.focus();
                }
            }
        }
    });

    actions.appendChild(likeBtn);
    actions.appendChild(commentBtn);
    div.appendChild(actions);

    const likesWrap = document.createElement('div');
    likesWrap.className = 'moment-likes';
    if (likes.length > 0) {
      const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
      likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
      likesWrap.classList.add('visible');
    }
    div.appendChild(likesWrap);

    const commentsWrap = document.createElement('div');
    commentsWrap.className = 'moment-comments';
    
    // *** 修改：渲染评论时添加 data- 属性 ***
    const renderCommentTree = (comments, level = 0) => {
        if (!comments || comments.length === 0) {
            return level === 0 ? '<div style="color:#bbb; font-style: italic; padding: 4px 0;">还没有评论，快来抢沙发吧！</div>' : '';
        }
        let html = '';
        comments.forEach(c => {
            const authorName = window.getAuthorNameById(c.roleId);
            // 添加 data-comment-id 和 data-author-id
            html += `<div class="moment-comment" data-comment-id="${c.id}" data-author-id="${c.roleId}" style="margin-left: ${level * 20}px;"><strong>${authorName}:</strong> <span>${c.text}</span></div>`;
            if (c.replies && c.replies.length > 0) {
                c.replies.forEach(reply => {
                   const replyAuthorName = window.getAuthorNameById(reply.roleId);
                   const replyToName = window.getAuthorNameById(c.roleId);
                   html += `<div class="moment-comment" data-comment-id="${reply.id}" data-author-id="${reply.roleId}" style="margin-left: ${(level + 1) * 20}px;"><strong>${replyAuthorName}</strong> <span style="color:#888;">回复</span> <strong>${replyToName}:</strong> <span>${reply.text}</span></div>`;
                });
            }
        });
        return html;
    };

    commentsWrap.innerHTML = renderCommentTree(m.comments);
    div.appendChild(commentsWrap);
    
    // *** 新增：为所有评论添加点击回复的事件委托 ***
    

    const commentInputArea = document.createElement('div');
    commentInputArea.className = 'moment-comment-input-area';
    commentInputArea.innerHTML = `
      <input type="text" class="moment-comment-input" placeholder="添加评论...">
      <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
    `;
    div.appendChild(commentInputArea);

    momentsContainer.appendChild(div);
  });
}
// --- 新增: 保存评论和点赞的辅助函数 ---
async function saveUserComment(momentId, commentText, replyToCommentId = null, replyToAuthorName = null) {
    try {
        if (!db || !momentId || !commentText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        const myName = myProfile.name || '我';

        const newComment = {
            id: `comment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
            roleId: myId,
            text: commentText,
            ts: Date.now(),
            replies: []
        };

        let notificationTargetCharacter = null;
        let notificationContent = '';
        
        if (replyToCommentId) {
            // 这是对一条评论的回复
            const findComment = (comments) => {
                for (const c of comments) {
                    if (c.id === replyToCommentId) return c;
                    // 注意：目前的设计AI回复和用户回复都存在replies数组，这里需要递归查找
                    if (c.replies && c.replies.length > 0) {
                        const found = findComment(c.replies);
                        if (found) return found;
                    }
                }
                return null;
            };
            const parentComment = findComment(moment.comments || []);
            
            if (parentComment) {
                parentComment.replies = parentComment.replies || [];
                parentComment.replies.push(newComment);
                
                // 如果回复的是AI，创建通知
                if (parentComment.roleId && parentComment.roleId.startsWith('char_')) {
                    notificationTargetCharacter = window.db.characters.find(c => c.id === parentComment.roleId);
                    const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                    notificationContent = `[system: ${myName} 回复了你对动态 "${momentSnippet}" 的评论: "${commentText}"]`;
                }
            } else {
                 // 如果找不到父评论（可能已被删除），则作为新评论添加
                 moment.comments = moment.comments || [];
                 moment.comments.push(newComment);
            }
        } else {
            // 这是对动态的新评论
            moment.comments = moment.comments || [];
            moment.comments.push(newComment);
            
            // 如果动态是AI发的，创建通知
            if (moment.authorId && moment.authorId.startsWith('char_')) {
                notificationTargetCharacter = window.db.characters.find(c => c.id === moment.authorId);
                const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                notificationContent = `[system: ${myName} 评论了你的动态 "${momentSnippet}": "${commentText}"]`;
            }
        }

        moment.commentedBy = moment.commentedBy || [];
        if (!moment.commentedBy.includes(myId)) {
            moment.commentedBy.push(myId);
        }

        await db.moments.put(moment);

        // 如果需要发送通知给AI，则注入上下文消息
        if (notificationTargetCharacter && notificationContent) {
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: notificationContent,
                parts: [{ type: 'text', text: notificationContent }],
                timestamp: Date.now()
            };
            notificationTargetCharacter.history.push(contextMessage);
            if (typeof window.saveData === 'function') {
                await window.saveData();
            }
        }
        
        renderMoments();
    } catch (e) {
        console.error(`Failed to save user comment for moment ${momentId}:`, e);
        showToast('评论失败');
    }
}

async function saveMomentComment(momentId, authorId, commentText) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.comments = moment.comments || [];
            moment.commentedBy = moment.commentedBy || [];
            moment.comments.push({
                roleId: authorId,
                text: commentText,
                ts: Date.now()
            });
            if (!moment.commentedBy.includes(authorId)) {
                moment.commentedBy.push(authorId);
            }
            await window.AppDB_Moments.moments.put(moment);
            if (typeof renderMoments === 'function') renderMoments();
        }
    } catch (e) {
        console.error(`Failed to save comment for moment ${momentId}:`, e);
    }
}

async function saveMomentLike(momentId, authorId) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.likes = moment.likes || [];
            if (!moment.likes.includes(authorId)) {
                moment.likes.push(authorId);
                await window.AppDB_Moments.moments.put(moment);
                if (typeof renderMoments === 'function') renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save like for moment ${momentId}:`, e);
    }
}
// --- end 新增 ---


    // 6) 获取尚未被某角色评论的动态（limit）
    async function getPendingMomentsForRole(roleId, limit = 5) {
      const all = await db.moments.orderBy('timestamp').reverse().toArray();
      const pending = all.filter(m => !(m.commentedBy || []).includes(roleId));
      return pending.slice(0, limit);
    }

    // 7) 将 AI 的评论写回数据库并标记 commentedBy
    async function markMomentsCommentedBy(commentsArray, roleId) {
      // commentsArray: [{momentId, commentText}, ...]
      try {
        await db.transaction('rw', db.moments, async () => {
          for (const c of commentsArray) {
            const m = await db.moments.get(c.momentId);
            if (!m) continue;
            const cbSet = new Set(m.commentedBy || []);
            cbSet.add(roleId);
            m.commentedBy = Array.from(cbSet);
            m.comments = m.comments || [];
            m.comments.push({ roleId, text: c.commentText, ts: Date.now() });
            await db.moments.put(m);
          }
        });
        renderMoments();
      } catch (e) {
        console.error('mark comments err', e);
      }
    }

    // 8) hook 底部导航显示逻辑（只在聊天列表 screen 可见时显示）
    // 把 bottom-nav-host 插入到 .phone-screen 内底部，使它在聊天页底部显示
    const phoneScreen = document.querySelector('.phone-screen');

    // === Step3 fix: ensure modal overlays are placed inside .phone-screen so absolute positioning works ===
    (function ensureModalsInPhoneScreen() {
      try {
        const phone = document.querySelector('.phone-screen');
        if (!phone) return;
        // move all modal overlays (only once)
        const modalSelectors = ['#post-modal', '.modal-overlay', '#sticker-modal', '#add-sticker-modal', '#time-skip-modal', '#group-recipient-selection-modal'];
        // Use querySelectorAll to move elements that exist and are not already inside phone
        document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar, #post-modal, #sticker-modal, #add-sticker-modal, #time-skip-modal, #group-recipient-selection-modal').forEach(el => {
          if (!el) return;
          if (phone.contains(el)) return;
          phone.appendChild(el);
        });
      } catch (e) {
        console.error('ensureModalsInPhoneScreen error', e);
      }
    })();

    
if (phoneScreen && bottomNavHost) {
      // 把导航放入 chat-list-screen 底部，使其仅在该 screen 内渲染与定位
      const chatListScreen = document.getElementById('chat-list-screen');
      if (phoneScreen && bottomNavHost.parentElement !== phoneScreen) {
        phoneScreen.appendChild(bottomNavHost);
      }
      bottomNavHost.style.display = 'none'; // 初始隐藏

      // --- 新增：为用户评论按钮添加事件委托 ---
      momentsContainer.addEventListener('click', async (e) => {
                // ... 在 momentsContainer 的 click 监听器内部 ...
      const postBtn = e.target.closest('.post-comment-btn');
      if (postBtn) {
          e.preventDefault();
          const momentId = postBtn.dataset.momentId;
          const input = postBtn.previousElementSibling;
          const commentText = input.value.trim();

          // 获取回复所需信息
          const replyToCommentId = postBtn.dataset.replyToCommentId || null;
          const replyToAuthorName = postBtn.dataset.replyToAuthorName || null;

          if (commentText) {
              await saveUserComment(momentId, commentText, replyToCommentId, replyToAuthorName);
              // 清理输入框和自定义属性
              input.value = '';
              input.placeholder = '添加评论...';
              delete postBtn.dataset.replyToCommentId;
              delete postBtn.dataset.replyToAuthorName;
              postBtn.closest('.moment-comment-input-area').classList.remove('visible');
          } else {
              showToast('评论内容不能为空');
          }
      }
});
      // 绑定按钮（若已有绑定则保持）
      const navButtons = bottomNavHost.querySelectorAll('.nav-btn');
      navButtons.forEach(btn => {
        if (btn._bound) return;
        btn.addEventListener('click', () => {
          navButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          const target = btn.getAttribute('data-target');
          if (typeof window.switchScreen === 'function') {
            window.switchScreen(target);
          } else {
            // 简单回退：切换 active 类并触发自定义事件
            document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === target));
            document.dispatchEvent(new CustomEvent('app:screenChanged', { detail: { targetId: target } }));
          }
        });
        btn._bound = true;
      });

      // 初始：如果当前 active 是 chat-list-screen，则显示并保持 chat 按钮 active
      const initActive = document.querySelector('.screen.active');
      if (initActive && initActive.id === 'chat-list-screen') {
        bottomNavHost.style.display = '';
        navButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
      
async function saveAiReplyToComment(momentId, commentId, replyText, aiAuthorId) {
    try {
        if (!db || !momentId || !commentId || !replyText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        // 递归查找要回复的评论
        const findCommentAndAddReply = (comments) => {
            for (const c of comments) {
                if (c.id === commentId) {
                    c.replies = c.replies || [];
                    c.replies.push({
                        id: `comment_${Date.now()}`,
                        roleId: aiAuthorId,
                        text: replyText,
                        ts: Date.now(),
                        replyTo: c.roleId // 记录这条回复是回复给谁的
                    });
                    return true;
                }
                if (c.replies && findCommentAndAddReply(c.replies)) {
                    return true;
                }
            }
            return false;
        };

        if (findCommentAndAddReply(moment.comments || [])) {
            await db.moments.put(moment);
            if (typeof renderMoments === 'function') {
                renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save AI reply for comment ${commentId}:`, e);
    }
}
      // 位置更新函数：根据 chat-list-screen 的 active 类显示/隐藏
function updateBottomNavVisibilityByActive() {
    const chatCls = document.getElementById('chat-list-screen');
    const momentsCls = document.getElementById('moments-screen');
    const forumScreen = document.getElementById('forum-screen');
    const forumThreadScreen = document.getElementById('forum-thread-screen');
    const walletScreen = document.getElementById('wallet-screen'); // <-- 新增这一行

    // --- 修改：在判断条件里加入对论坛和钱包页面的检查 ---
    if ((chatCls && chatCls.classList.contains('active')) ||
        (momentsCls && momentsCls.classList.contains('active')) ||
        (forumScreen && forumScreen.classList.contains('active')) ||
        (forumThreadScreen && forumThreadScreen.classList.contains('active')) ||
        (walletScreen && walletScreen.classList.contains('active')) // <-- 新增这一行
       ) {
      bottomNavHost.style.display = '';
    } else {
      bottomNavHost.style.display = 'none';
    }
}
// ▲▲▲ 替换结束 ▲▲▲
      // 立即执行一次
      updateBottomNavVisibilityByActive();

      // 监听 .phone-screen 下 class 变化（屏幕切换通常会触发 class 变化）
      const moTarget = phoneScreen;
      try {
        const mo = new MutationObserver(() => updateBottomNavVisibilityByActive());
        mo.observe(moTarget, { attributes: true, subtree: true, attributeFilter: ['class'] });
      } catch (e) {
        // ignore observer errors
      }
    }
    // 全局切换 screen 的小函数（与页面已有切换保持一致）
    function switchScreen(targetId) {
      // 仅切换 active 类，避免直接改写 style.display 导致布局（flex）异常
      document.querySelectorAll('.screen').forEach(s => {
        s.classList.toggle('active', s.id === targetId);
      });
      // 触发全局事件，通知其他模块屏幕已切换
      try {
        const ev = new CustomEvent('app:screenChanged', { detail: { targetId } });
        document.dispatchEvent(ev);
      } catch (e) {
        console.warn('dispatch app:screenChanged failed', e);
      }
      // 如果进入 moments-screen，渲染
      if (targetId === 'moments-screen' && typeof renderMoments === 'function') renderMoments();
    }

    // 9) 将动态内容与聊天一起发给 AI（挂到 #get-reply-btn）
    const getReplyBtn = $('#get-reply-btn');
    if (getReplyBtn) {
      getReplyBtn.addEventListener('click', async (ev) => {
        // Determine current roleId: try chat-room-title text
        const roleTitleEl = $('#chat-room-title');
        let roleId = roleTitleEl ? roleTitleEl.textContent.trim() : 'role_unknown';
        if (!roleId) roleId = 'role_unknown';

        // collect chat history from #message-area DOM
        const chatArea = $('#message-area');
        let chatText = '';
        if (chatArea) {
          const messages = chatArea.querySelectorAll('.message-bubble');
          const arr = [];
          messages.forEach(mb => {
            // get role name if exists, else fallback to bubble's class
            const wrapper = mb.closest('.message-wrapper');
            let who = wrapper && wrapper.classList.contains('sent') ? '我' : (wrapper && wrapper.classList.contains('received') ? roleId : '');
            arr.push(`${who}: ${mb.textContent.trim()}`);
          });
          chatText = arr.join('\n');
        }

        // pending moments
        const pending = await getPendingMomentsForRole(roleId, 5);

        // build a structured prompt (we'll ask AI to return JSON)
        let prompt = `系统：请按 JSON 格式输出：{"chat_reply":"...","moment_comments":[{"momentId":"...","comment":"..."}]}\n\n`;
        prompt += `聊天记录：\n${chatText}\n\n`;
        if (pending && pending.length) {
          prompt += `需要评论的动态（最多 ${pending.length} 条，按序对应 id）：\n`;
          pending.forEach((m, i) => {
            prompt += `${i+1}) id:${m.id}\ntext:${m.text}\nimageDesc:${m.imageDesc || ''}\n\n`;
          });
        } else {
          prompt += '（无待评论的动态）\n';
        }

        // Try to call existing global sendToAI-like function if exists
        let aiRaw = null;
        try {
          if (typeof window.sendToAI === 'function') {
            aiRaw = await window.sendToAI(prompt);
          } else if (typeof window.callAI === 'function') {
            aiRaw = await window.callAI(prompt);
          } else if (typeof window.sendMessageToModel === 'function') {
            aiRaw = await window.sendMessageToModel(prompt);
          }
        } catch (e) {
          console.error('AI call failed', e);
          showToast('AI 请求失败：' + (e.message || e));
          return;
        }

        // 解析 AI 返回（优先 JSON）
        let parsed = null;
        try {
          parsed = typeof aiRaw === 'string' ? JSON.parse(aiRaw) : aiRaw;
        } catch (e) {
          // fallback: 使用原始文本作为 chat 回复
          parsed = { chat_reply: String(aiRaw || ''), moment_comments: [] };
        }

        // 处理聊天回复：把 parsed.chat_reply 插入聊天区域（若页面已有 appendAIMessageToChat 函数优先使用）
        if (parsed && parsed.chat_reply) {
          if (typeof window.appendAIMessageToChat === 'function') {
            window.appendAIMessageToChat(parsed.chat_reply, roleId);
          } else {
            // 尝试在页面直接插入（如果 message-area 存在）
            const mArea = $('#message-area');
            if (mArea) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-wrapper received';
              const row = document.createElement('div');
              row.className = 'message-bubble received';
              row.textContent = parsed.chat_reply;
              wrapper.appendChild(row);
              mArea.appendChild(wrapper);
              mArea.scrollTop = mArea.scrollHeight;
            }
          }
        }

        // 处理 moment 评论
        if (parsed && Array.isArray(parsed.moment_comments) && parsed.moment_comments.length) {
          // Normalize to array of {momentId, commentText}
          const normalized = parsed.moment_comments.map(mc => {
            return { momentId: mc.momentId || mc.momentId || mc.id || mc.id, commentText: mc.comment || mc.commentText || mc.text || '' };
          }).filter(x => x.momentId);
          if (normalized.length) {
            await markMomentsCommentedBy(normalized, roleId);
          }
        }

      }); // end getReplyBtn click
    } // end if getReplyBtn

    // small toast helper (reuse existing #toast-notification if exists)
    function showToast(msg, timeout = 2400) {
      const t = $('#toast-notification');
      if (t) {
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), timeout);
      } else {
        // fallback
        alert(msg);
      }
    }

    /* simulateAIResponse removed: local simulated AI replies disabled by user request */

// 初始：如果页面当前在 chat-list-screen，显示 bottom nav
    const currentActive = document.querySelector('.screen.active');
    if (currentActive && currentActive.id === 'chat-list-screen') {
      // keep bottom nav visible and make chat button active
      const botNav = document.getElementById('bottom-nav');
      if (botNav) {
        botNav.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
    }

    // 如果初始存在 moments screen active，则 render
    if (currentActive && currentActive.id === 'moments-screen') renderMoments();

    // --- 将关键函数暴露到全局作用域，以便其他模块调用 ---
    window.getPendingMomentsForRole = getPendingMomentsForRole;
    window.saveMomentComment = saveMomentComment;
    window.saveMomentLike = saveMomentLike;
    window.markMomentsCommentedBy = markMomentsCommentedBy;
    window.renderMoments = renderMoments; // 暴露渲染函数，以便外部模块可以刷新动态列表

  }); // DOMContentLoaded end
})();
</script>


<!-- Begin: Render moments safe patch (injected for step4) -->
<script>
(function(){
  console.log('[injected patch] renderMomentsSafe initializing...');
  try {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
      console.warn('[injected patch] #moments-screen not found.');
    }
    // Ensure a container exists
    let momentsContainer = document.getElementById('moments-container');
    if (!momentsContainer && momentsScreen) {
      const content = momentsScreen.querySelector('.content') || momentsScreen;
      momentsContainer = document.createElement('div');
      momentsContainer.id = 'moments-container';
      content.appendChild(momentsContainer);
      console.log('[injected patch] created #moments-container');
    }
    // Safe Dexie wrapper
    let _db = null;
    if (typeof Dexie !== 'undefined') {
        // Use the existing global instance if available
        if (window.AppDB_Moments) {
            _db = window.AppDB_Moments;
        } else {
            try {
                _db = new Dexie('AppDB_Moments');
                _db.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                window.AppDB_Moments = _db; // Ensure it's globally available
            } catch (e) {
                console.warn('[injected patch] Dexie init failed:', e);
                _db = null;
            }
        }
    } else {
        console.warn('[injected patch] Dexie not available.');
    }

// ▼▼▼ 在 renderMomentsSafe 函数的正上方，粘贴这个新函数 ▼▼▼
function getAuthorProfile(authorId) {
    // 默认备用信息
    let profile = { name: '未知用户', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg' };

    // 1. 检查是不是用户自己
    const myProfile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {};
    if (authorId === (myProfile.id || 'user')) {
        return { name: myProfile.name || '我', avatar: myProfile.avatar };
    }

    // 2. 在所有AI角色中查找
    if (window.db && Array.isArray(window.db.characters)) {
        const character = window.db.characters.find(c => c.id === authorId);
        if (character) {
            return { name: character.remarkName, avatar: character.avatar };
        }
    }

    // 3. 在所有群聊的成员中查找 (以防是群聊成员发的动态)
    if (window.db && Array.isArray(window.db.groups)) {
        for (const group of window.db.groups) {
            if (Array.isArray(group.members)) {
                const member = group.members.find(m => m.id === authorId);
                if (member) {
                    return { name: member.groupNickname, avatar: member.avatar };
                }
            }
        }
    }
    
    return profile; // 如果都找不到，返回默认信息
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 用这个新版本，完整替换掉旧的 renderMomentsSafe 函数 ▼▼▼
    window.renderMomentsSafe = async function renderMomentsSafe() {
      try {
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('#moments-container'));
        if (!container) {
          console.warn('[injected patch] No container found for moments.');
          return;
        }
        let list = [];
        if (_db && _db.moments) {
          try {
            list = await _db.moments.orderBy('timestamp').reverse().toArray();
          } catch (e) {
            console.error('[injected patch] Failed reading moments from IndexedDB:', e);
            list = [];
          }
        } else {
          try {
            const maybeDb = window.AppDB_Moments || null;
            if (maybeDb && maybeDb.moments) {
              list = await maybeDb.moments.orderBy('timestamp').reverse().toArray();
            }
          } catch (e) {
            list = [];
          }
        }

        container.innerHTML = '';
        const momentsEmpty = document.getElementById('moments-empty');
        if (!list || !list.length) {
          if (momentsEmpty) momentsEmpty.style.display = 'block';
          else {
            const p = document.createElement('p');
            p.className = 'placeholder-text';
            p.textContent = '还没有动态，点击右上角发布吧~';
            container.appendChild(p);
          }
          return;
        } else {
          if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        list.forEach(m => {
          try {
            const div = document.createElement('div'); div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
            const head = document.createElement('div'); head.className = 'moment-head';
            const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.style.fontWeight='700';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            
            // --- 核心修改在这里 ---
            const authorInfo = getAuthorProfile(m.authorId); // 使用新函数查找作者信息
            name.textContent = authorInfo.name || m.author || '未知用户'; // 优先用新找到的名字，找不到再用快照里的旧名字
            avatar.src = authorInfo.avatar || m.authorAvatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg'; // 优先用新找到的头像，找不到再用快照里的
            // --- 修改结束 ---

            meta.appendChild(name);
            meta.appendChild(time);
            head.appendChild(avatar);
            head.appendChild(meta);
            div.appendChild(head);

            const txt = document.createElement('div'); txt.className='moment-text'; txt.textContent = m.text || '';
            div.appendChild(txt);

            if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
              const im = document.createElement('img'); im.className = 'moment-image';
              im.src = m.imageData;
              im.alt = m.imageDesc ? m.imageDesc : (m.text || '动态图片');
              div.appendChild(im);
              if (m.imageDesc) {
                const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
                desc.textContent = '图片：' + m.imageDesc;
                div.appendChild(desc);
              }
            } else if (m.imageDesc) {
              const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
              if (m.id) descCard.dataset.momentId = m.id || '';
              const descContent = document.createElement('p'); descContent.className = 'desc-content';
              descContent.textContent = m.imageDesc;
              descCard.appendChild(descContent);
              descCard.setAttribute('role', 'img');
              descCard.setAttribute('aria-label', m.imageDesc);
              descCard.addEventListener('click', function () { /* show detail */ });
              div.appendChild(descCard);
            }

            const actions = document.createElement('div');
            actions.className = 'moment-actions';
            
            const likeBtn = document.createElement('button');
            likeBtn.className = 'moment-action-btn';
            const likes = m.likes || [];
            const myProfile = loadProfileFromStorage();
            const myId = myProfile.id || 'user';
            if (likes.includes(myId)) {
                likeBtn.classList.add('liked');
            }
            likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
            
            likeBtn.addEventListener('click', async (event) => {
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                const currentLikes = m.likes || [];
                const myIdx = currentLikes.indexOf(myId);

                if (myIdx > -1) {
                    currentLikes.splice(myIdx, 1);
                    btn.classList.remove('liked');
                } else {
                    currentLikes.push(myId);
                    btn.classList.add('liked');
                }
                m.likes = currentLikes;
                await db.moments.put(m);

                const span = btn.querySelector('span');
                if (span) {
                    span.textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
                }

                const likesWrap = momentItem.querySelector('.moment-likes');
                if (likesWrap) {
                    if (currentLikes.length > 0) {
                        const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                        likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                        likesWrap.classList.add('visible');
                    } else {
                        likesWrap.classList.remove('visible');
                    }
                }
            });

            const commentBtn = document.createElement('button');
            commentBtn.className = 'moment-action-btn';
            commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
            commentBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                if (momentItem) {
                    const inputArea = momentItem.querySelector('.moment-comment-input-area');
                    if (inputArea) {
                        inputArea.classList.toggle('visible');
                        if (inputArea.classList.contains('visible')) {
                            inputArea.querySelector('input').focus();
                        }
                    }
                }
            });

            actions.appendChild(likeBtn);
            actions.appendChild(commentBtn);
            div.appendChild(actions);

            if (likes.length > 0) {
                const likesWrap = document.createElement('div');
                likesWrap.className = 'moment-likes visible';
                const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                div.appendChild(likesWrap);
            }

            const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
            if (m.comments && m.comments.length) {
              m.comments.forEach(c => {
                const cm = document.createElement('div'); cm.className='moment-comment';
                const authorName = window.getAuthorNameById(c.roleId || c.role);
                cm.textContent = `${authorName}：${c.text}`;
                commentsWrap.appendChild(cm);
              });
            } else {
              const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = '暂时没有评论';
              commentsWrap.appendChild(none);
            }
            div.appendChild(commentsWrap);

            const commentInputArea = document.createElement('div');
            commentInputArea.className = 'moment-comment-input-area';
            commentInputArea.innerHTML = `
              <input type="text" class="moment-comment-input" placeholder="添加评论...">
              <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
            `;
            div.appendChild(commentInputArea);
            container.appendChild(div);
          } catch (innerErr) {
            console.error('[injected patch] render single moment failed', innerErr, m);
          }
        });

      } catch (err) {
        console.error('[injected patch] renderMomentsSafe failed', err);
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('.content'));
        if (container) {
          container.innerHTML = '<div style="color:#b00;padding:12px;border-radius:10px;background:#fff8f8;">加载动态时出错（详情见 Console）</div>';
        }
      }
    };
// ▲▲▲ 替换结束 ▲▲▲
  

    // Attach to app:screenChanged and mutation observer
    document.addEventListener('app:screenChanged', (ev) => {
      try {
        if (ev && ev.detail && ev.detail.targetId === 'moments-screen') {
          window.renderMomentsSafe();
        }
      } catch (e) { console.error('[injected patch] app:screenChanged handler failed', e); }
    });

    const phone = document.querySelector('.phone-screen') || document.body;
    const mo = new MutationObserver((mutations) => {
  try {
    // 只在 phone 节点本身的 class 发生变化时才触发（避免子元素的 class 变动导致重渲染）
    const phoneClassChanged = mutations.some(m =>
      m.type === 'attributes' && m.attributeName === 'class' && m.target === phone
    );
    if (!phoneClassChanged) return;

    const active = document.querySelector('.screen.active');
    if (active && active.id === 'moments-screen') {
      window.renderMomentsSafe();
    }
  } catch (e) { console.error('[injected patch] MutationObserver callback failed', e); }
});
// 仅观察 phone 自身的 attributes（不要 subtree=true）
mo.observe(phone, { attributes: true, subtree: false, attributeFilter: ['class'] });


    // try initial render
    setTimeout(() => {
      try { window.renderMomentsSafe(); } catch(e) { console.warn('[injected patch] initial render failed', e); }
    }, 300);

  } catch (e) {
    console.error('[injected patch] initialization failed', e);
  }
})();
</script>
<!-- End: Render moments safe patch -->


<script>
/* === 确保 #moments-screen 永远在 .phone-screen 内，并清除会把它推出视窗的内联样式 (自动插入补丁) === */

(function ensureMomentsStaysInPhone() {
  function fixPlacementAndStyles() {
    const phone = document.querySelector('.phone-screen');
    const moments = document.getElementById('moments-screen');
    if (!phone) return;

    // If moments exists, ensure it's inside phone but *do not force inline styles on it*
    if (moments && !phone.contains(moments)) {
      phone.appendChild(moments);
      console.log('[patch] moved #moments-screen into .phone-screen');
    }

    // Only normalize styles for screens *other than* moments-screen or elements managed by injection
    document.querySelectorAll('.screen').forEach(s => {
      if (s.id === 'moments-screen' || s.dataset.managedBy === 'injection') {
        // make sure its stacking context is reasonable but don't clobber its layout
        s.style.zIndex = s.style.zIndex || '0';
        return;
      }
      // Apply conservative safe defaults to other screens
      s.style.position = s.style.position || 'absolute';
      s.style.top = s.style.top || '0';
      s.style.left = s.style.left || '0';
      s.style.right = s.style.right || '0';
      s.style.bottom = s.style.bottom || '0';
      // Avoid removing transforms which some screens might rely on; only clear very specific problematic inline styles
      if ((s.style.transform || '').includes('translate') || (s.style.transform || '').includes('translateY')) {
        // leave transforms intact to avoid breaking animations
      } else {
        s.style.transform = s.style.transform || '';
      }
      s.style.margin = s.style.margin || '';
      // ensure screens stack below nav/modals
      s.style.zIndex = s.style.zIndex || '0';
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPlacementAndStyles);
  } else {
    fixPlacementAndStyles();
  }
  // only run on custom app events; do not poll aggressively to avoid fighting the injected UI
  document.addEventListener('app:screenChanged', fixPlacementAndStyles);
  // run a very infrequent check as a last resort
  setInterval(fixPlacementAndStyles, 5000);
})();
</script>

<!-- === /patch === -->

<!-- Avatar overlap CSS override (scaled to 70%) inserted by assistant -->
<style>
.icity-moments-inner {
  --icity-hero-h: 154px;      /* 70% of original 220px */
  --icity-avatar-size: 98px;  /* 70% of original 140px */
  position: relative;
  box-sizing: border-box;
}

.icity-hero {
  height: var(--icity-hero-h) !important;
  position: relative;
  overflow: hidden;
  border-radius: 14px 14px 0 0;
  box-sizing: border-box;
}

.icity-avatar-wrap {
  position: absolute !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  width: var(--icity-avatar-size) !important;
  height: var(--icity-avatar-size) !important;
  border-radius: 50% !important;
  top: calc(var(--icity-hero-h) - (var(--icity-avatar-size) * 0.7)) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  z-index: 50 !important;
  background: #fff !important;
  box-shadow: 0 8px 22px rgba(0,0,0,0.12) !important;
  border: 6px solid rgba(255,255,255,0.95) !important;
  box-sizing: border-box !important;
  overflow: visible !important;
}

.icity-avatar-wrap img,
.icity-avatar-wrap .avatar-img {
  width: 80% !important;
  height: 80% !important;
  border-radius: 50% !important;
  object-fit: cover !important;
  display: block !important;
}

.icity-info-card {
  position: relative !important;
  padding-top: calc(var(--icity-avatar-size) * 0.2 + 4px) !important; /* Reduced top padding */
  padding-right: 18px !important;
  padding-left: 18px !important;
  padding-bottom: 10px !important; /* Reduced bottom padding */
  margin-top: 10px !important;
  background: #fff !important;
  border-radius: 14px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,0.04) !important;
  box-sizing: border-box !important;
  text-align: center !important;
}

/* Reduce vertical spacing and font sizes for a more compact info card */
.icity-name {
    font-size: 18px !important;
    line-height: 1.1 !important;
}
.icity-id-loc {
    margin-top: 6px !important;
    font-size: 12px !important;
    line-height: 1.1 !important;
}
.icity-signature {
    margin-top: 8px !important;
    font-size: 13px !important;
    line-height: 1.2 !important;
}

@media (max-width: 420px) {
  .icity-moments-inner {
    --icity-hero-h: 112px;  /* 70% of previous 160px */
    --icity-avatar-size: 77px; /* 70% of previous 110px */
  }
}
  
</style>
<!-- End assistant-inserted CSS -->

<!-- === Avatar & Background Edit Feature === -->
<div class="action-sheet-overlay" id="edit-top-section-actionsheet">
  <div class="action-sheet">
    <button class="action-sheet-button" id="edit-bg-btn">更换背景图</button>
    <button class="action-sheet-button" id="edit-avatar-btn">更换头像</button>
    <button class="action-sheet-button danger" id="cancel-edit-top-btn">取消</button>
  </div>
</div>
<input type="file" accept="image/*" id="top-section-file-input" style="display:none;" />

<script>
(function(){
    const topSection = document.querySelector('#moments-screen .icity-moments-inner .icity-hero') || document.querySelector('#moments-screen .icity-hero') || document.querySelector('#moments-screen .top-section') || document.querySelector('#moments-screen header');
    const editSheet = document.getElementById('edit-top-section-actionsheet');
    const bgBtn = document.getElementById('edit-bg-btn');
    const avatarBtn = document.getElementById('edit-avatar-btn');
    const cancelBtn = document.getElementById('cancel-edit-top-btn');
    const fileInput = document.getElementById('top-section-file-input');

    let currentEditTarget = null;

    // Restore saved bg & avatar
    const savedBg = localStorage.getItem('myTopBg');
    const savedAvatar = localStorage.getItem('myTopAvatar');
    if(savedBg && topSection) {
        topSection.style.backgroundImage = `url('${savedBg}')`;
        topSection.style.backgroundSize = 'cover';
        topSection.style.backgroundPosition = 'center';
    }
    if(savedAvatar) {
        document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
            if(img.tagName === 'IMG') img.src = savedAvatar;
            else img.style.backgroundImage = `url('${savedAvatar}')`;
        });
    }

    // Previously opened the whole topSection on click — removed to avoid accidental edits during publish.
    // Now only explicit edit controls (avatar/background buttons and per-field clicks) will trigger edits.

    cancelBtn.addEventListener('click', ()=>{
        editSheet.classList.remove('visible');
    });

    function chooseSource(targetType) {
        const url = prompt('输入图片URL，或留空选择本地文件：');
        if(url) {
            applyImage(targetType, url);
        } else {
            currentEditTarget = targetType;
            fileInput.click();
        }
    }

    function applyImage(targetType, dataUrl) {
        if(targetType === 'bg') {
            if(topSection) {
                topSection.style.backgroundImage = `url('${dataUrl}')`;
                topSection.style.backgroundSize = 'cover';
                topSection.style.backgroundPosition = 'center';
            }
            localStorage.setItem('myTopBg', dataUrl);
        } else if(targetType === 'avatar') {
            localStorage.setItem('myTopAvatar', dataUrl);
            document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 同步动态列表头像（moment-avatar 为动态列表头像类）
            document.querySelectorAll('.post .avatar-img, .moment-avatar').forEach(img => {
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 尝试更新数据库中属于当前用户(authorId匹配)或无 authorId 但 author 名称匹配的 moments 的 authorAvatar 字段（若存在 db）
            try{
                if(window.AppDB_Moments && typeof AppDB_Moments !== 'undefined' && AppDB_Moments.moments){
                    (async ()=>{
                        try{
                            const all = await AppDB_Moments.moments.toArray();
                            const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                                name: localStorage.getItem('myTopName') || '我',
                                id: localStorage.getItem('myTopId') || 'user',
                                avatar: localStorage.getItem('myTopAvatar') || null
                            };
                            for(const m of all){
                                // Update moments that explicitly reference this author's id
                                if((m.authorId && m.authorId === profile.id) || (!m.authorId && m.author === profile.name)){
                                    m.authorAvatar = dataUrl;
                                    // If the moment had no authorId, bind it to current profile.id so future syncs work
                                    if(!m.authorId) m.authorId = profile.id;
                                    try{ await AppDB_Moments.moments.put(m); }catch(e){ /* ignore put errors for individual items */ }
                                }
                            }
                            // After DB updates, re-render moments so DOM reflects DB changes
                            if(typeof renderMoments === 'function') try{ renderMoments(); }catch(e){}
                            else if(typeof window.renderMomentsSafe === 'function') try{ window.renderMomentsSafe(); }catch(e){}
                        }catch(e){}
                    })();
                }
            }catch(e){}
            // Ensure profile render + sync runs to update in-memory DOM and trigger any re-renders
            try{ if(typeof renderProfileAndSync === 'function') renderProfileAndSync(); }catch(e){}
        }
    }
fileInput.addEventListener('change', async (e)=>{
        const file = e.target.files[0];
        if(file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                applyImage(currentEditTarget, compressedUrl);
            } catch (error) {
                if(typeof showToast === 'function') showToast('图片处理失败，请重试');
                console.error('Background image compression failed:', error);
            }
        }
    });

    bgBtn.addEventListener('click', ()=> chooseSource('bg'));
    avatarBtn.addEventListener('click', ()=> chooseSource('avatar'));
})();
</script>
<!-- === /Avatar & Background Edit Feature === -->


<!-- Avatar sync patch: non-invasive, appended to avoid modifying original logic.
     Purpose: ensure top avatar updates immediately and moments list does not revert
     by synchronizing DOM and (if possible) the DB after avatar changes. -->
<script>
(function(){
  'use strict';

  // Utility: load profile from existing function if available, otherwise from localStorage
  function loadProfileFallback(){
    try {
      if(typeof loadProfileFromStorage === 'function'){
        var p = loadProfileFromStorage();
        if(p && (p.avatar || p.id || p.name)) return p;
      }
    } catch(e){}
    // fallback to localStorage keys used by the app
    try {
      return {
        id: localStorage.getItem('myTopId') || localStorage.getItem('icity-id') || localStorage.getItem('userId') || null,
        name: localStorage.getItem('myTopName') || localStorage.getItem('icity-name') || localStorage.getItem('userName') || null,
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('icity-avatar-src') || localStorage.getItem('userAvatar') || null,
        signature: localStorage.getItem('myTopSignature') || null,
        location: localStorage.getItem('myTopLocation') || null
      };
    } catch(e){
      return {};
    }
  }

  // Robustly update top-profile DOM elements and common avatar selectors
  function updateTopProfileAndAvatars(){
    try {
      var p = loadProfileFallback() || {};
      var avatar = p.avatar || null;
      // find common top avatar elements
      var avatarSelectors = [
        '#icity-avatar', // explicit id
        '.icity-avatar-wrap img',
        '.top-avatar',
        '.my-avatar',
        '.header-avatar img',
        '.profile-avatar img'
      ];
      avatarSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            if(!el) return;
            if(el.tagName === 'IMG'){
              if(avatar) el.src = avatar;
            } else {
              if(avatar) el.style.backgroundImage = "url('"+avatar+"')";
            }
          } catch(e){}
        });
      });

      // update textual profile elements defensively
      var nameEls = [document.getElementById('icity-name'), document.querySelector('.icity-name'), document.querySelector('.profile-name')];
      nameEls.forEach(function(el){
        if(el && p.name) try{ el.textContent = p.name; }catch(e){}
      });
      var sigEls = [document.getElementById('icity-signature'), document.querySelector('.icity-signature')];
      sigEls.forEach(function(el){
        if(el && p.signature) try{ el.textContent = p.signature; }catch(e){}
      });

      // update moments list avatars for moments authored by current profile (best-effort)
      try {
        var id = p.id || null;
        var name = p.name || null;
        var avatars = document.querySelectorAll('.moment-avatar, .post .avatar-img, .post .author-avatar, .item .avatar, .comment .avatar, img[data-role="avatar"]');
        avatars.forEach(function(img){
          try {
            if(!img) return;
            // try dataset or attributes
            var authorId = img.getAttribute('data-author-id') || img.dataset && img.dataset.authorId || null;
            var authorName = img.getAttribute('data-author') || img.getAttribute('data-author-name') || img.dataset && img.dataset.author || null;

            // also try to find author id/name from closest ancestor
            if(!authorId || !authorName){
              var ancestor = img.closest('[data-author-id], [data-author], .moment, .post');
              if(ancestor){
                if(!authorId) authorId = ancestor.getAttribute('data-author-id') || ancestor.getAttribute('data-author') || null;
                if(!authorName) authorName = ancestor.getAttribute('data-author-name') || ancestor.getAttribute('data-author') || null;
                // check for .author-name text
                if(!authorName){
                  var an = ancestor.querySelector('.author-name, .name, .post-author');
                  if(an) authorName = (an.textContent || '').trim();
                }
              }
            }

            // Decision: if authorId matches, or authorName matches (best-effort), update the img.src
            var shouldUpdate = false;
            if(id && authorId && String(authorId) === String(id)) shouldUpdate = true;
            if(!shouldUpdate && name && authorName && String((authorName||'').trim()) === String((name||'').trim())) shouldUpdate = true;

            if(shouldUpdate && avatar){
              if(img.tagName === 'IMG'){
                img.src = avatar;
              } else {
                img.style.backgroundImage = "url('"+avatar+"')";
              }
            }
          } catch(e){}
        });
      } catch(e){}
    } catch(e){}
  }

  // Try to update a Dexie/DB moments table authorAvatar entries for current user (best-effort, non-blocking)
  function tryUpdateDBMomentsAvatar(newAvatar){
    try {
      var p = loadProfileFallback();
      if(!p || !p.id || !newAvatar) return;
      // if window.AppDB_Moments and Dexie-like table exists, try to update entries where authorId matches
      if(window.AppDB_Moments && window.AppDB_Moments.moments){
        try {
          // If it's Dexie or has where API
          if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.toArray === 'function'){
            // best-effort: update authorAvatar for matching authorId
            // .where('authorId').equals(p.id).modify({ authorAvatar: newAvatar }) might exist
            if(typeof window.AppDB_Moments.moments.where === 'function'){
              try {
                var q = window.AppDB_Moments.moments.where('authorId').equals(p.id);
                if(q && typeof q.modify === 'function'){
                  q.modify(function(obj){ obj.authorAvatar = newAvatar; });
                } else {
                  // fallback: scan and put
                  window.AppDB_Moments.moments.toArray().then(function(arr){
                    arr.forEach(function(item){
                      try {
                        if(item.authorId && String(item.authorId) === String(p.id)){
                          item.authorAvatar = newAvatar;
                          if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item);
                        }
                      } catch(e){}
                    });
                  }).catch(function(){});
                }
              } catch(e){}
            }
          } else if(typeof window.AppDB_Moments.moments.update === 'function'){
            // unknown API: attempt to update each by scanning
            try {
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = newAvatar;
                    try { window.AppDB_Moments.moments.update(item.id, item); } catch(e){}
                  }
                });
              }).catch(function(){});
            } catch(e){}
          }
        } catch(e){}
      }
    } catch(e){}
  }

  // Wrap existing applyImage (if present) so after changing avatar we sync
  if(typeof window.applyImage === 'function'){
    try {
      var origApplyImage = window.applyImage;
      window.applyImage = function(){
        try {
          var res = origApplyImage.apply(this, arguments);
          // schedule sync shortly after (some apps update DOM async)
          setTimeout(function(){
            try {
              updateTopProfileAndAvatars();
              var p = loadProfileFallback();
              if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
            } catch(e){}
          }, 100);
          return res;
        } catch(e){
          try { return origApplyImage.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  } else {
    // If applyImage not found, expose a safe function for callers to use
    window.__syncAvatarsAfterChange = function(){
      try {
        updateTopProfileAndAvatars();
        var p = loadProfileFallback();
        if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
      } catch(e){}
    };
  }

  // If renderMomentsSafe exists, wrap it to call our sync after running original
  if(typeof window.renderMomentsSafe === 'function'){
    try {
      var _origRenderMomentsSafe = window.renderMomentsSafe;
      window.renderMomentsSafe = function(){
        try {
          var res = _origRenderMomentsSafe.apply(this, arguments);
          // after render, ensure our avatars are applied
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMomentsSafe.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Also wrap any generic renderMoments function if present
  if(typeof window.renderMoments === 'function'){
    try {
      var _origRenderMoments = window.renderMoments;
      window.renderMoments = function(){
        try {
          var res = _origRenderMoments.apply(this, arguments);
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMoments.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Run once at load to align UI with stored avatar (without waiting for user action)
  try { setTimeout(updateTopProfileAndAvatars, 50); } catch(e){}

  // Expose for debugging (non-enumerable)
  try { Object.defineProperty(window, '__updateProfileAndAvatars', { value: updateTopProfileAndAvatars, writable: false }); } catch(e){}

  // Do not interfere with bottom navigation: avoid touching elements with ids/classes typically used by navbars.
  // The script only touches avatar/name related selectors and moment avatars; it is intentionally conservative.

})();
</script>

<!-- Stronger enforcement: bind moment avatars to top avatar persistently -->
<script>
(function(){
  'use strict';
  // Helper to read top avatar from DOM or storage
  function getTopAvatar(){
    try {
      // Try common selectors for top avatar
      var selectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img', '.my-avatar'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(el){
          if(el.tagName === 'IMG' && el.src) return el.src;
          var bg = window.getComputedStyle(el).backgroundImage;
          if(bg && bg !== 'none'){
            // extract url("...") content
            var m = bg.match(/url\(["']?(.*?)["']?\)/);
            if(m && m[1]) return m[1];
          }
        }
      }
      // fallback to storage
      var p = null;
      try { if(typeof loadProfileFromStorage === 'function') p = loadProfileFromStorage(); } catch(e){}
      if(!p) p = {
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('userAvatar') || localStorage.getItem('icity-avatar-src')
      };
      if(p && p.avatar) return p.avatar;
    } catch(e){}
    return null;
  }

  // Helper to determine if an avatar img belongs to current user (best-effort)
  function isAvatarForCurrentUser(imgEl){
    try {
      if(!imgEl) return false;
      var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : null;
      if(!p) p = { id: localStorage.getItem('myTopId'), name: localStorage.getItem('myTopName') };
      var authorId = imgEl.getAttribute('data-author-id') || (imgEl.dataset && imgEl.dataset.authorId) || null;
      var authorName = imgEl.getAttribute('data-author') || imgEl.getAttribute('data-author-name') || (imgEl.dataset && imgEl.dataset.author) || null;
      if(!authorId && !authorName){
        var anc = imgEl.closest('[data-author-id], [data-author], .moment, .post, .item');
        if(anc){
          authorId = authorId || anc.getAttribute('data-author-id') || anc.getAttribute('data-author');
          authorName = authorName || anc.getAttribute('data-author-name') || anc.getAttribute('data-author');
          if(!authorName){
            var authorNameNode = anc.querySelector('.author-name, .name, .post-author, .author');
            if(authorNameNode) authorName = (authorNameNode.textContent || '').trim();
          }
        }
      }
      if(p && p.id && authorId && String(p.id) === String(authorId)) return true;
      if(p && p.name && authorName && String((p.name||'').trim()) === String((authorName||'').trim())) return true;
      // Also check if img has attribute data-me or class 'me' etc
      if(imgEl.hasAttribute('data-me') || imgEl.classList.contains('me') || imgEl.classList.contains('self')) return true;
    } catch(e){}
    return false;
  }

  // Enforce top avatar on matching nodes
  function enforceTopAvatarOnNode(imgEl, topAvatar){
    try {
      if(!imgEl || !topAvatar) return;
      // Avoid touching nav icons: check ancestor tags that might be navbars
      var navAncestor = imgEl.closest('nav, .navbar, .bottom-nav, .footer');
      if(navAncestor) return; // don't modify nav images
      // Only enforce if this img seems like a moment/post avatar
      var selMatch = /(^|\s)(moment-avatar|avatar-img|author-avatar|post-avatar|item-avatar|my-avatar|top-avatar|author-avatar-img)(\s|$)/i;
      var classStr = imgEl.className || '';
      // If it looks like an avatar or is IMG inside .moment/.post, proceed
      var likelyAvatar = classStr && selMatch.test(classStr) || imgEl.closest('.moment, .post, .item, .comment') || imgEl.getAttribute('data-role') === 'avatar';
      if(!likelyAvatar) return;
      if(!isAvatarForCurrentUser(imgEl)) return;
      // If current src differs, set it
      if(imgEl.tagName === 'IMG'){
        if(imgEl.src !== topAvatar){
          try { imgEl.src = topAvatar; } catch(e){}
        }
      } else {
        try { imgEl.style.backgroundImage = "url('"+topAvatar+"')"; } catch(e){}
      }
      // mark as forced to avoid loops
      try { imgEl.setAttribute('data-avatar-forced','1'); } catch(e){}
    } catch(e){}
  }

  // Enforce across the document
  function enforceTopAvatarAll(topAvatar){
    if(!topAvatar) return;
    var selectors = ['.moment-avatar', '.post .avatar-img', '.post .author-avatar', '.item .avatar', '.comment .avatar', 'img[data-role="avatar"]', '.avatar-img'];
    selectors.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(img){
        enforceTopAvatarOnNode(img, topAvatar);
      });
    });
  }

  // Mutation observer to catch src changes and new nodes
  var observer = new MutationObserver(function(muts){
    try {
      var top = getTopAvatar();
      muts.forEach(function(m){
        try {
          if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'style' || m.attributeName === 'data-author-id' || m.attributeName === 'data-author')){
            var target = m.target;
            if(target && (target.tagName === 'IMG' || target.nodeType === 1)){
              enforceTopAvatarOnNode(target, top);
            }
          } else if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            m.addedNodes.forEach(function(node){
              try {
                if(node.nodeType !== 1) return;
                // find descendant avatar images
                var imgs = node.querySelectorAll && node.querySelectorAll('.moment-avatar, .avatar-img, img[data-role="avatar"], .author-avatar');
                if(imgs && imgs.length){
                  imgs.forEach(function(img){ enforceTopAvatarOnNode(img, top); });
                }
                // also if the node itself is an IMG
                if(node.tagName === 'IMG') enforceTopAvatarOnNode(node, top);
              } catch(e){}
            });
          }
        } catch(e){}
      });
    } catch(e){}
  });

  try {
    observer.observe(document.body, { attributes: true, childList: true, subtree: true, attributeFilter: ['src','style','data-author-id','data-author','data-author-name'] });
  } catch(e){}

  // Also run periodic enforcement for initial seconds to handle race conditions
  var enforcementRuns = 0;
  var enforcementTimer = setInterval(function(){
    try {
      enforcementRuns++;
      var top = getTopAvatar();
      if(top) enforceTopAvatarAll(top);
      // Try to update DB as well to persist
      try {
        if(top && typeof window.__updateProfileAndAvatars === 'function'){
          window.__updateProfileAndAvatars();
        }
      } catch(e){}
      if(enforcementRuns > 40) { // run ~40 times at 200ms => 8 seconds then stop
        clearInterval(enforcementTimer);
      }
    } catch(e){}
  }, 200);

  // Expose a function to explicitly bind list avatars to top avatar and optionally persist to DB
  window.bindMomentsAvatarsToTop = function(persistToDB){
    try {
      var top = getTopAvatar();
      if(!top) return;
      enforceTopAvatarAll(top);
      if(persistToDB){
        // try to update DB entries authorAvatar for current user
        try {
          var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : { id: localStorage.getItem('myTopId') };
          if(p && p.id && window.AppDB_Moments && window.AppDB_Moments.moments){
            if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.modify === 'function'){
              try { window.AppDB_Moments.moments.where('authorId').equals(p.id).modify(function(o){ o.authorAvatar = top; }); } catch(e){}
            } else if(typeof window.AppDB_Moments.moments.toArray === 'function'){
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item && item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = top;
                    try { if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item); } catch(e){}
                  }
                });
              }).catch(function(){});
            }
          }
        } catch(e){}
      }
    } catch(e){}
  };

  // Attempt immediate bind once loaded
  try { setTimeout(function(){ window.bindMomentsAvatarsToTop(true); }, 100); } catch(e){}

  // defensive cleanup if script re-inserted: no-op

})();
</script>

<!-- Remove/hide avatars in moments list while preserving top avatar -->



<!-- Avatar fill patch: make avatar image fully fill its circular container (remove inner white gap) -->
<style>
/* Conservative selectors for avatar containers and images */
.icity-avatar-wrap, .avatar-wrap, .profile-avatar, .header-avatar, .my-avatar, .top-avatar, .avatar-circle, .avatar-holder {
  background: transparent !important;
  padding: 0 !important;
  border: 0 !important;
  overflow: hidden !important;
  border-radius: 50% !important;
  display: inline-block !important;
}

/* Ensure the img fills the container */
.icity-avatar-wrap img, .avatar-wrap img, .profile-avatar img, .header-avatar img, .my-avatar img, .top-avatar img, img.avatar-img, img[data-role="avatar"] {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
  border-radius: 50% !important;
  background: transparent !important;
  padding: 0 !important;
  margin: 0 auto !important;
}

/* If the container uses an inner padding element, hide it */
.icity-avatar-wrap .inner-avatar, .avatar-wrap .inner, .avatar-inner {
  display: none !important;
}
</style>



<!-- Moments 多选删除底部操作栏 -->
<div id="moments-multi-select-bar" class="multi-select-bar" aria-hidden="true">
  <div class="msb-left">
    <span id="moments-selected-count">已选择 0 项</span>
  </div>
  <div class="msb-right">
    <button id="moments-confirm-delete" class="danger">确认删除</button>
    <button id="moments-cancel-delete">取消</button>
  </div>
</div>



<!-- 覆盖：确保 moment 图片描述卡的底色与文字颜色生效（放在文件末尾以覆盖所有样式） -->
<style>
.moment-image-desc-card {
  background: #eef0f3 !important; /* 浅灰底色 - 覆盖原有渐变 */
  border: 6px solid #ffffff !important;
  box-shadow: 0 6px 20px rgba(10,10,20,0.06) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;

  padding: 12px 14px !important;
  margin-top: 6px !important;
  min-height: 86px !important;
}
.moment-image-desc-card .desc-content { font-size: 13px !important; }

.moment-image-desc-card .desc-content,
.moment-image-desc-card p.desc-content {
  color: #66676b !important;
  background: transparent !important;
}
/* 如果存在内层容器，确保去掉其背景并使用浅灰色 */
.moment-image-desc-card > .inner,
.moment-image-desc-card > .card-inner,
.moment-image-desc-card > .content {
  background: transparent !important;
}
</style>



<!-- 覆盖：移除卡片内所有文字阴影，确保描述文字不带阴影 -->
<style>
.moment-image-desc-card, 
.moment-image-desc-card *,
.moment-image-desc-card .desc-content,
.moment-image-desc-card .description,
.moment-image-desc-card .image-desc,
.moment-image-desc-card .desc {
  text-shadow: none !important;
  -webkit-text-shadow: none !important;
  filter: none !important;
}
</style>


<!-- Modal layout fixes: align action buttons and tighten image checkbox spacing -->
<style>
/* Try to scope to likely modal/dialog containers without touching other buttons */
/* If your modal has a specific id or class, replace .publish-modal below with it. */
.publish-modal, .publish-dialog, .moment-publish-modal, .dialog-publish, .publishBox {
  /* ensure modal content uses flex column so footer aligns correctly */
  display: block;
}

/* Make the actions row use flex so buttons are equal size and aligned */
.publish-modal .actions,
.publish-dialog .actions,
.moment-publish-modal .actions,
.dialog-publish .actions,
.publishBox .actions,
.publish-actions {
  display: flex !important;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 0 !important;
}

/* Ensure buttons inside actions share equal width and similar height */
.publish-modal .actions button,
.publish-dialog .actions button,
.moment-publish-modal .actions button,
.dialog-publish .actions button,
.publishBox .actions button,
.publish-actions button {
  flex: 1 1 0;
  max-width: none;
  min-width: 0;
  height: 52px;
  border-radius: 12px;
  font-weight: 600;
  padding: 0 16px;
  box-sizing: border-box;
}

/* Make the cancel button visually secondary if needed */
.publish-modal .actions .cancel,
.publish-dialog .actions .cancel,
.publishBox .actions .cancel,
.publish-actions .cancel {
  background: #bfe6ff; /* light blue like your screenshot */
  color: #fff;
}

/* Publish button primary color */
.publish-modal .actions .primary,
.publish-dialog .actions .primary,
.publishBox .actions .primary,
.publish-actions .primary {
  background: #ff95bf; /* pink from screenshot */
  color: #fff;
}

/* Tighten spacing for the "add image" checkbox area */
.add-image-row, .add-image, .image-checkbox, .add-photo, .add-picture {
  margin-top: 6px !important;
  margin-bottom: 6px !important;
  display: flex !important;
  gap: 8px;
  align-items: center;
}

/* If checkbox itself has large margin, reduce it */
.add-image-row input[type="checkbox"],
.image-checkbox input[type="checkbox"],
.add-photo input[type="checkbox"] {
  margin: 0 !important;
  transform: scale(1.05);
}

/* Small screens: keep buttons stacked but full-width with proper gap */
@media (max-width: 420px) {
  .publish-modal .actions,
  .publish-dialog .actions,
  .moment-publish-modal .actions,
  .dialog-publish .actions,
  .publishBox .actions,
  .publish-actions {
    flex-direction: column;
  }
  .publish-modal .actions button,
  .publish-dialog .actions button,
  .moment-publish-modal .actions button,
  .dialog-publish .actions button,
  .publishBox .actions button,
  .publish-actions button {
    width: 100%;
  }
}
</style>


<!-- Precise fixes for the 发布动态 form: equalize buttons and tighten checkbox spacing -->
<style>
/* Scope strictly to the post form to avoid affecting other UIs */
#post-form { font-family: inherit; }

/* Find the action container which uses inline flex; ensure children buttons take equal space */
#post-form > div[style*="display:flex"] {
  display: flex !important;
  gap: 10px !important;
  margin-top: 12px !important;
  align-items: stretch !important;
}

/* Make buttons equal width, same height, and matching radius */
#post-form > div[style*="display:flex"] .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  height: 52px !important;
  padding: 0 16px !important;
  border-radius: 12px !important;
  box-sizing: border-box !important;
  font-weight: 600 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* If there are specific modifier classes, ensure colors remain similar to your theme */
#post-form > div[style*="display:flex"] .btn-sec { background: #bfe6ff !important; color: #fff !important; border: none !important; }
#post-form > div[style*="display:flex"] .btn-primary { background: #ff95bf !important; color: #fff !important; border: none !important; }

/* Tighten the "添加图片" checkbox row */
#post-form .form-group label {
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  margin-top: 6px !important;
  cursor: pointer;
}

#post-form #add-image {
  margin: 0 !important;
  transform: scale(1.05) !important;
  vertical-align: middle !important;
}

/* Ensure image input group sits closer */
#image-input-group { margin-top: 8px !important; margin-bottom: 6px !important; }

/* Small screens: stack buttons but keep spacing */
@media (max-width: 420px) {
  #post-form > div[style*="display:flex"] { flex-direction: column !important; }
  #post-form > div[style*="display:flex"] .btn { width: 100% !important; }
}
</style>


<!-- Fix: keep '添加图片' label on one line and allow it to lay out horizontally -->
<style>
/* Prevent the label text from wrapping and ensure layout is inline */
#post-form .form-group label {
  white-space: nowrap !important;
  flex-wrap: nowrap !important;
  width: auto !important;
}

/* If any spans inside the label are forced to block, make them inline */
#post-form .form-group label span,
#post-form .form-group label b,
#post-form .form-group label i {
  display: inline !important;
}

/* Allow the label to take available horizontal space so text doesn't collapse */
#post-form .form-group {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}

  
</style>

<script id="moments-delete-feature-script">
    (function() {
        // 防止脚本被重复执行
        if (window.momentsDeleteFeatureInitialized) {
            return;
        }
        window.momentsDeleteFeatureInitialized = true;

        // 步骤 A: 动态注入正确的CSS样式
        // 这样做可以强制覆盖掉任何可能残留的、导致按钮消失的旧样式
        const css = `
            #moments-screen.is-delete-mode .moment-item { 
                cursor: pointer; user-select: none; 
            }
            .moment-item.is-selected { 
                outline: 2px solid var(--accent-color, #4c9ffe); 
                position: relative; 
                border-radius: 14px;
                box-shadow: 0 6px 18px rgba(76, 159, 254, 0.2) !important;
            }
            .moment-item.is-selected::after {
              content: '✓';
              position: absolute; right: 8px; top: 8px;
              width: 22px; height: 22px; line-height: 22px; text-align: center;
              border-radius: 50%;
              background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
              z-index: 10;
            }
            /* 关键修正：强制确保按钮文字在任何情况下都可见 */
            #moments-screen.is-delete-mode .app-header #moments-delete-btn {
                font-size: 16px !important;
            }
            /* 关键修正：强制清除可能残留的、导致文字被替换的旧样式 */
            #moments-screen.is-delete-mode .app-header #moments-delete-btn::before {
                content: "" !important;
            }
        `;
        const style = document.createElement('style');
        style.type = 'text/css';
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);

        // 步骤 B: 绑定功能逻辑
        document.addEventListener('DOMContentLoaded', () => {
            const momentsScreen = document.getElementById('moments-screen');
            const deleteBtn = document.getElementById('moments-delete-btn');
            
            if (!momentsScreen || !deleteBtn) {
                console.error("动态删除功能初始化失败：找不到关键HTML元素。");
                return;
            }

            let selectedMomentsIds = new Set();

            function updateDeleteButtonState() {
                const isInDeleteMode = momentsScreen.classList.contains('is-delete-mode');
                if (!isInDeleteMode) {
                    deleteBtn.textContent = '删除';
                    deleteBtn.style.color = '';
                    deleteBtn.style.fontWeight = '';
                } else {
                    if (selectedMomentsIds.size > 0) {
                        deleteBtn.textContent = `删除 (${selectedMomentsIds.size})`;
                        deleteBtn.style.color = '#ef5350'; // 红色
                        deleteBtn.style.fontWeight = '600';
                    } else {
                        deleteBtn.textContent = '取消';
                        deleteBtn.style.color = 'var(--primary-color)'; // 主题色
                        deleteBtn.style.fontWeight = '600';
                    }
                }
            }

            function enterDeleteMode() {
                momentsScreen.classList.add('is-delete-mode');
                updateDeleteButtonState();
                if(typeof showToast === 'function') showToast('已进入选择模式');
            }

            function exitDeleteMode() {
                momentsScreen.classList.remove('is-delete-mode');
                document.querySelectorAll('.moment-item.is-selected').forEach(el => el.classList.remove('is-selected'));
                selectedMomentsIds.clear();
                updateDeleteButtonState();
            }
            
            async function confirmAndDelete() {
                if (confirm(`确定要删除选中的 ${selectedMomentsIds.size} 条动态吗？`)) {
                    try {
                        if (window.AppDB_Moments && typeof window.AppDB_Moments.moments.bulkDelete === 'function') {
                            await window.AppDB_Moments.moments.bulkDelete(Array.from(selectedMomentsIds));
                            if(typeof showToast === 'function') showToast('动态已成功删除');
                            exitDeleteMode();
                            if (typeof window.renderMomentsSafe === 'function') await window.renderMomentsSafe();
                        } else { throw new Error("数据库功能不可用。"); }
                    } catch (error) {
                        console.error('删除动态失败:', error);
                        if(typeof showToast === 'function') showToast('删除失败: ' + error.message);
                    }
                }
            }

            deleteBtn.addEventListener('click', () => {
                const isInDeleteMode = momentsScreen.classList.contains('is-delete-mode');
                if (!isInDeleteMode) {
                    enterDeleteMode();
                } else {
                    if (selectedMomentsIds.size > 0) {
                        confirmAndDelete();
                    } else {
                        exitDeleteMode();
                        if(typeof showToast === 'function') showToast('已取消选择');
                    }
                }
            });

            momentsScreen.addEventListener('click', (e) => {
                if (!momentsScreen.classList.contains('is-delete-mode')) return;
                const momentItem = e.target.closest('.moment-item');
                if (momentItem) {
                    e.stopPropagation(); e.preventDefault();
                    const momentId = momentItem.dataset.id;
                    if (!momentId) return;
                    if (selectedMomentsIds.has(momentId)) {
                        selectedMomentsIds.delete(momentId);
                        momentItem.classList.remove('is-selected');
                    } else {
                        selectedMomentsIds.add(momentId);
                        momentItem.classList.add('is-selected');
                    }
                    updateDeleteButtonState();
                }
            }, true);
            
            // 确保在init函数中调用过setupMomentsDeleteFeature后，这里的逻辑也能被正确执行
            if (typeof setupMomentsDeleteFeature === 'function') {
                console.log("setupMomentsDeleteFeature is already defined, skipping re-definition but ensuring execution.");
            }
        });
    })();
</script>

  

<!-- 在 </body> 之前添加 -->


    <div id="mention-panel" class="mention-panel"></div>

    <div class="modal-overlay" id="share-post-modal">
        <div class="modal-window">
            <h3>分享帖子给...</h3>
            <ul id="share-post-selection-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
                </ul>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-neutral" id="cancel-post-share-btn" style="flex: 1;">取消</button>
                <button class="btn btn-primary" id="confirm-post-share-btn" style="flex: 1;">确认分享</button>
            </div>
        </div>
    </div>
   
   

  
<div id="trajectory-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="trajectory-modal-title">Ta的轨迹</h3>
        <div id="trajectory-timeline">
            <div class="placeholder-text">正在加载轨迹...</div>
        </div>
        <button id="close-trajectory-modal-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>

<div id="mention-panel" class="mention-panel"></div>
<!-- ... (El resto de los scripts y styles finales) ... -->
	<!-- === 新增：回忆记录显示面板 (Modal) === -->
<div id="memory-summary-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>回忆记录</h3>
        <div class="form-group" style="max-height: 60vh; overflow-y: auto; background-color: #f9f9f9; padding: 10px; border-radius: 8px;">
            <pre id="memory-summary-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; color: #333;"></pre>
        </div>
        <button id="close-memory-summary-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- ... 紧跟在 memory-summary-modal 的 div 之后 ... -->



</body>

</html>